[^2-2-2.1]:参考佩亚诺余项运算

[toc]

# 一. 基本概念

> ==数据结构三要素：逻辑结构、数据的运算、物理结构(存储结构)==

1. 提取操作对象，找出操作对象之间的关系并用数学的语言描述就是数据结构。

   操作对象指：每位学生的信息(学号、姓名、性别.....)

   操作的算法指：查询、插入、修改、删除等。

2. 数据结构可分为：线性数据结构（数组，队列，线性表等）、非线性数据结构（集合，树，图等）。

   线性数据结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。如：学生管理系统，是一对一关系

   非线性数据结构：一个结点可能油多个直接前趋和直接后继。如：目录结构(树)、最短路径(图)，是一对多关系或多对多关系。

   [最短路径：](https://image.sybblogs.fun/img-common/202304052128205.png)

   ![导航节点](https://image.sybblogs.fun/img-common/202304052128205.png)

## 1. 概念及定义

### 数据(Data)

> 数据是能输入计算机且能被计算机处理的各种符号的集合。

数据特点：

1. 信息的载体

2. 是对客观事物符号化的表示

3. 能够被计算机识别存储和加工

数据包括：

1. 数值型的数据：整数、实数等。

2. 非数值型的数据：文字、图像、图形、声音等。

### 数据元素

> 数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。而一个数据元素可由多个数据项组成，数据项是构成数据元素不可分割最小单位。

也可称为元素，或称为记录、结点或顶点。如上面最短路径图，其中的每个点我们称之为结点。

- 数据项

  > 数据项是构成元素的不可分割的最小单位。

  [数据项：](https://image.sybblogs.fun/img-common/202304052131322.png)

  <img src="https://image.sybblogs.fun/img-common/202304052131322.png" alt="数据项" style="zoom:43%;" />

  上面每行可称为数据元素，而每列可以称之为数据元素中的**数据项**。

- 三者关系

  数据$>$数据元素$>$数据项

  例子：学生表$>$个人记录$>$学号、姓名....

### 数据对象

> 数据对象是性质相同的数据元素的集合，是数据的一个子集。

如：学籍表可以看作是一个数据对象，由若干条学生信息构成的子集。

- 数据元素和数据对象关系

  数据元素：组成数据的基本单位。其与数据的关系是：数据元素是集合的个体。

  数据对象：性质相同的数据元素的集合。其与数据的关系是：集合的子集。

[数据对象图例：](https://image.sybblogs.fun/img-common/202304162111379.png)

<img src="https://image.sybblogs.fun/img-common/202304162111379.png" alt="数据对象图例" style="zoom:33%;" />

### 数据结构

> 意义：数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构( Structure )
>
> 数据结构是指相互之间存在一种或多种特定关系的数据元素集合。或者说，数据结构是带结构的数据元素的集合。

- 数据结构包含内容：

  1. 数据元素之间的逻辑关系，也称为**逻辑结构**。
  2. 数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的**物理结构**或数据的**存储结构**。
  3. 数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。

- 数据结构的两个层次

  1. 逻辑结构：

     描述数据元素之间的逻辑关系

     与数据存储无关，独立于计算机

     是从具体问题抽象出来的数学模型

  2. 物理结构(存储结构)：

     数据元素及其关系在计算机存储器中的结构(存储方式)

     是数据结构在计算机中的表示

  3. 逻辑结构和存储结构的关系：

     存储结构是逻辑关系的映像与元素本身的映像。

     逻辑结构是数据结构的抽象，存储结构是数据结构的实现。

     两者综合起来建立了数据元素之间的结构关系。

## 2. 四种逻辑结构

> 逻辑结构和数据的运算是定义一种数据结构前提。

集合结构(大纲不考)：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

[集合结构例子：](https://image.sybblogs.fun/img-common/202304161957873.png)

<img src="https://image.sybblogs.fun/img-common/202304161957873.png" alt="集合结构例子" style="zoom:33%;" />

线性结构：结构中的数据元素之间存在着一对一的线性关系，除了除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。

基本运算：①查找第$i$个数据元素。②在第$i$个位置插入新的数据元素。③删除第$i$个位置数据元素.....

[线性结构例子：](https://image.sybblogs.fun/img-common/202304161959324.png)

<img src="https://image.sybblogs.fun/img-common/202304161959324.png" alt="线性结构例子" style="zoom:33%;" />

树形结构：结构中的数据元素之间存在着一对多的层次关系。

[树形结构例子：](https://image.sybblogs.fun/img-common/202304162001827.png)

<img src="https://image.sybblogs.fun/img-common/202304162001827.png" alt="树形结构例子" style="zoom:33%;" />

图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。

[图结构例子：](https://image.sybblogs.fun/img-common/202304162002143.png)

<img src="https://image.sybblogs.fun/img-common/202304162002143.png" alt="图结构例子" style="zoom:33%;" />

[逻辑结构分类：](https://image.sybblogs.fun/img-common/202304052216835.png)

<img src="https://image.sybblogs.fun/img-common/202304052216835.png" alt="逻辑结构分类" style="zoom: 50%;" />

## 3. 四种基本存储结构

> 当我们定义完一种数据结构后，需要用计算机来实现这种数据结构，此时用到基本存储结构。

### 顺序存储结构

含义：

1. 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
2. C语言中用数组来实现顺序存储结构

[顺序存储结构示例：](https://image.sybblogs.fun/img-common/202304052224091.png)

<img src="https://image.sybblogs.fun/img-common/202304052224091.png" alt="顺序存储结构" style="zoom:43%;" />

### 链式存储结构

含义：

1. 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针表示。
2. C语言中用指针来实现链式存储结构。

[链式存储结构：](https://image.sybblogs.fun/img-common/202304052231942.png)

<img src="https://image.sybblogs.fun/img-common/202304052231942.png" alt="链式存储结构" style="zoom:43%;" />

如：上图$bat$对应指针(地址)是$165$，后面$130$是下一个元素地址，即$cat$。没有即为$NULL$

### 索引存储结构

含义：

1. 在存储结点信息的同时，还建立附加的索引表。
2. 通俗讲索引就是目录，一般形式是：关键字、地址。
3. 关键字是能唯一标识一个结点的数据项。
4. 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引。

[索引存储结构：](https://image.sybblogs.fun/img-common/202304162013420.png)

<img src="https://image.sybblogs.fun/img-common/202304162013420.png" alt="索引存储结构2" style="zoom:33%;" />

### 散列存储结构

根据结点的关键字直接计算出该结点的存储地址。如：哈希表。

## 4. 数据类型、抽象数据类型

### 4.1 数据类型

> 数据类型是一个值的取值范围和定义在此范围上的一组操作(加减、取模等)的总称。

1. 原子类型：其值不可再分的数据类型。如$int$类型(可进行加、减、乘、除、取模等运算)，$bool$类型(可进行与、或、非等操作)
2. 结构类型：其值可以再分解为若干成分(分量)的数据类型。如定义一个可操作横坐标和纵坐标的函数。

### 4.2 抽象数据类型(ADT)

> 抽象数据类型是抽象数据组织及与之相关的操作。如：逻辑结构、数据运算、物理结构(存储结构)，这个过程。

# 二. 算法

## 1. 算法基本概念

> 算法就是如何高效地处理这些数据，以解决实际问题。
>
> 其定义是对特定问题求解步骤地一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

算法特点：

1. 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。

3. 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入。 一个算法有零个或多个输入， 这些输入取自于某个特定的对象的集合。
   输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

以上特点只要有一个不满足，就不能称之为算法。

一个好的算法所具备特质：

1. 正确性。算法能够正确解决求解问题。
2. 可读性。算法应具有良好的可读性，以帮助人们理解。==考试时候要写注释==。
3. 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 高效率和低存储。即算法时间复杂度低，空间复杂度低。

[算法基本概念总结：](https://image.sybblogs.fun/img-common/202304162133530.png)

<img src="https://image.sybblogs.fun/img-common/202304162133530.png" alt="算法基本概念总结" style="zoom: 33%;" />

## 2. ==算法效率度量==

算法复杂度度量可以从两个方面：①时间复杂度、②空间复杂度

### 2.1 时间复杂度

> 用事前预估算法时间开销$T(n)$与问题规模$n$的关系($T$表示"time")。

方法：

- 时间复杂度加法规则：

  我们可以通过对每一行有效代码进行时间记录，从而估计出代码所需的执行时间。如下：

  ~~~c++
  void loveYou(int n) { //n 为问题规模
      ①int i=1;//爱你的程度
      ②while(i<=n){
      ③    i++ ;
          //每次+1
      ④    printf("I Love You %d\n",i);
      }
      ⑤printf("I Love You More Than %d\n",n) ;
  }
  int main( ){
      loveYou(3000) ;
  }
  ~~~

  以上代码模拟打印3000遍I Love You。运行结果如下：

  ~~~c++
  ....
  I Love You 2994
  I Love You 2995
  I Love You 2996
  I Love You 2997
  I Love You 2998
  ....
  I Love You 3001
  I Love You More Than 3000
  ~~~

  我么可以估计一下语句执行时间：①⑤各执行一次，②执行3001次，③④执行3000次，所以变量$n$为3000时，所需执行时间为：

  $T(3000)=1+1+3001+2\times3000$。所以其时间开销$T$与问题规模$n$关系式子为：$T(n)=3n+3$。

  虽然我们通过如此简单方式得出这段程序所需执行时间，但是广义化之后该方法并不适用：如果代码是几万行的这种方法显然不适用。

  根据我们所学数学知识，我们想得到一个估计大小时，一个表达式中更低阶部分我们往往可以省略。所以上面可以写为$T(n)=3n$。假设有以下算法时间复杂度：
  $$
  \begin{equation*}
  	\begin{aligned}
  &T_1(n)=3n^2+3n+3000\xrightarrow{忽略低阶后}=3n^2\\
  \\
  &T_2(n)=n^3+n^2+9999\xrightarrow{忽略低阶后}=n^3
  	\end{aligned}
  \end{equation*}
  $$
  我们一般用$O$表示"同阶"(同等数量级。即，当$n\to\infty$时，二者极限之比为常数，来代替最高阶前面系数)，来规范时间复杂度的写法。所以上面规范写法如下：
  $$
  \begin{equation*}
  	\begin{aligned}
  &3n^2=O(n^2)\\
  \\
  &n^3=O(n^3)
  	\end{aligned}
  \end{equation*}
  $$
  结论：一个程序的算法复杂度可以只考虑阶数高的部分。以上是时间复杂度计算的加法规则，同样我们可以推出以下的规则：

- 乘法规则

  $T(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$

  即多项相乘，都保留。如：$T(n)=O(n^3)\times O(n^2)=O(n^5)$[^2-2-2.1]

- 混合运算规则

  $T(n)=O(f(n))+O(g(n))=max\{O(f(n))+O(g(n))\}$

  混合运算需要保留最大那个项。为了方便理解我们可以保留其中变化趋势最大函数，函数变化趋势如下：

  [复杂度变化趋势：](https://image.sybblogs.fun/img-common/202304171954955.png)

  <img src="https://image.sybblogs.fun/img-common/202304171954955.png" alt="复杂度变化趋势" style="zoom:43%;" />

  例子：$T(n)=n^3+n^2\log_2n=$$O(n^3)+O(n^2\log_2n)=$$O(n^3)$。

通过以上规则我们还要注意以下几点：

1. 顺序执行的代码只会影响常数项，所以可以忽略不记。
2. 循环执行代码中，我们只需要挑一个循环体基本操作，分析他的执行次数即可。
3. 如果有多层嵌套循环，我们只需要关注最深层代码循环次数即可。

例1：分析以下代码时间复杂度

~~~c++
//算法3- 指数递增型爱 你
void loveYou(int n) { //n 为问题规模
    int i=1;//爱你的程度
    while(i<=n){
        i=i*2; //每次翻倍
        printf("I Love You %d\n",i);        
    }
    printf("I Love You More Than %d\n",n);
}
~~~

> 答案：$T(n)=O(\log_2n)$
>
> 解析：我们直接看循环体，循环体中，赋值语句$i$每次翻倍，假设循环了$x$次，则循环结束时刚好满足$2^x>n$，所以$x=\log_2n+1$
>
> 则，时间复杂度$T(n)=O(\log_2n)$

例2：分析以下代码时间复杂度

~~~c++
void loveYou(int flag[]， int n) { //n 为问题规模
    printf("I Am Iron Man\n") ;
    for(int i=0; i<n; i++){ //从第一个元素开始查找
        if(flag[i]==n){ //找到元素n
            printf("I Love You %d\n"，n) ;
            break; //找 到后立即跳出循环
        }
    }
}
//其中flag数组是1~n个数，输入一个数n找出n在数组中的位置
int main(){
    int flag[n]={1...n};
    loveYou(flag,n); 
    return 0;
}
~~~

> 答案：最好情况：元素n在第一个位置，即最好时间复杂度$T(n)=O(1)$
> 最坏情况：元素n在最后一个位置，最坏时间复杂度$T(n)=O(n)$
> 平均情况：假设元素n在任意一个位置的概率相同为$\frac{1}{n}$，平均时间复杂度$T(n)=O(n)$
>
> 平均情况解析：循环次数$x=(1+2+3+...+n)\frac{1}{n}=(\frac{n(1+n)}{2})\frac{1}{n}=\frac{1+n}{2}$，即$T(n)=O(x)=O(n)$

注意：我们在评价一个算法时候一般只看最坏情况和平均情况，而最好情况一般参考意义不大。

[时间复杂度总结：](https://image.sybblogs.fun/img-common/202304172233517.png)

<img src="https://image.sybblogs.fun/img-common/202304172233517.png" alt="时间复杂度总结" style="zoom: 33%;" />

### 2.2 空间复杂度

空间复杂度需要时间复杂度中运算知识。空间复杂度我们用$S(n)$表示。

例1：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n];
    //声明一个长度为n的数组
    int i;
    //.....此处省略很多代码
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数所需要参数$n为int类型$占四个字节，下面的$i也是int$类型所以也是四字节，数组长度是$n$且为int类型，所以是$4n$，那么这个程序所需要空间为：$4n+8$。规范写法为$S(n)=O(n)$

结论：常数项同样不考虑，注意数组大小等。

例2：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n][n]; //声明 n*n的二维数组
    int otheg[n];
    //声明一个长度为n的数乡
    int i;
    //.... .此处省略很多代码
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：二维int类型n长度数组占大小为：$4n^2$，下面一维数组是$4n$，所以$S(n)=O(n^2)+O(n)+O(1)=O(n^2)$

例3：计算以下程序空间复杂度

~~~c++
void loveYou(int n) { //n 为问题规模
    int a,b,c; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数递归$n$次，每次变量大小占$16$，所以应该为$S(n)=16n=O(n)$

结论：递归问题空间复杂$=$递归调用深度。

例4：我们对例3进行改进，讲声明变量改为数组

~~~c++
void loveYou(int n) { //n 为问题规模
    int flag[n]; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：函数递归调用$n$次，每次数组长度为$n$，所以空间复杂度为：$1+2+3+...n=\frac{n(1+n)}{2}=\frac{1}{2}n^2+\frac{1}{2}n$，即答案。	 

[空间复杂度总结：](https://image.sybblogs.fun/img-common/202304172316612.png)

<img src="https://image.sybblogs.fun/img-common/202304172316612.png" alt="空间复杂度总结" style="zoom:43%;" />