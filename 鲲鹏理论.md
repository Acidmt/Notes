[toc]

# 一. 基本概念

> 鲲鹏BMS：裸金属服务
>
> Docker概念：容器镜像仓库
>
> 鲲鹏计算；鲲鹏通用计算增强型；2vCPU 4GB；kc1.large.2；公共镜像openEuler 20.03 64bit with ARM(40GB)；云硬盘 高IO 40GB
>
> OLTP：OLTP是传统关系数据库的主要应用。
>
> CS架构：客户端到服务器架构
>
> BS架构：通过浏览器访问服务器。
>
> 鲲鹏处理器：有四个芯片构成，分别为CPU，南桥，SAS存储控制器，网卡。

# 二. linux基础命令

## 1. Linux的基础命令

[Linux命令分类：](https://z3.ax1x.com/2021/11/02/IFHdWF.png)

[<img src="https://z3.ax1x.com/2021/11/02/IFHdWF.png" alt="IFHdWF.png" style="zoom:67%;" />](https://imgtu.com/i/IFHdWF)

步骤一：使用pwd命令查看当前所在目录位置。

```bash
[root@openeuler ~]# pwd
/root
```

回显所示表示当前在**/root**目录下。

步骤二：使用ls查看当前目录下的文件及文件夹:

```bash
[root@openeuler ~]# ls
anaconda-ks.cfg
[root@openeuler ~]# ls .
anaconda-ks.cfg
```

回显表示当前目录有一个anaconda-ks.cfg文件。

显示上一级目录的文件及文件夹：

```bash
[root@openeuler ~]# ls ..
bin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```

查看/tmp目录下的文件及文件夹：

```bash
[root@openeuler ~]# ls /tmp
systemd-private-83515ce5034447c68960d26c45b5c1a6-chronyd.service-pjjWmf  systemd-private-83515ce5034447c68960d26c45b5c1a6-systemd-logind.service-t4I5su
```

显示当前目录的所有文件及文件夹：

```bash
[root@openeuler ~]# ls -a
.  ..  anaconda-ks.cfg  .bash_history  .bash_logout  .bash_profile  .bashrc  .cshrc  .tcshrc
```

~~~bash
[root@openeuler ~]# ls -A		/*显示隐藏文件*/
.  ..  anaconda-ks.cfg  .bash_history  .bash_logout  .bash_profile  .bashrc  .cshrc  .tcshrc
~~~

回显表示当前目录存在隐藏文件及目录。

显示当前目录非隐藏的文件及文件夹详细信息：

```bash
[root@openeuler ~]# ls -l
-rw-------. 1 root root 1312 Feb 10 12:30 anaconda-ks.cfg
```

显示当前目录所有文件及文件夹详细信息：

```bash
[root@openeuler ~]# ls -al
dr-xr-x---.  2 root root 4096 Feb 10 13:10 .
dr-xr-xr-x. 18 root root 4096 Feb 10 12:27 ..
-rw-------.  1 root root 1312 Feb 10 12:30 anaconda-ks.cfg
-rw-------.  1 root root  451 Feb 10 13:44 .bash_history
-rw-r--r--.  1 root root   18 Oct 29 16:29 .bash_logout
-rw-r--r--.  1 root root  176 Oct 29 16:29 .bash_profile
-rw-r--r--.  1 root root  176 Oct 29 16:29 .bashrc
-rw-r--r--.  1 root root  100 Oct 29 16:29 .cshrc
-rw-r--r--.  1 root root  129 Oct 29 16:29 .tcshrc
```

步骤三：cd切换目录。

切换到系统根目录：

```bash
[root@openeuler ~]# cd /
[root@openeuler /]#
```

注意观察，“~”变成了“/”。

切换到“/etc/”目录：

```bash
[root@openeuler /]# cd /etc
[root@openeuler etc]#
```

切换到"/etc/sysconfig/"目录：

```bash
相对路径写法：
[root@openeuler etc]# cd sysconfig
[root@openeuler sysconfig]#

绝对路径写法：
[root@openeuler etc]# cd /etc/sysconfig
[root@openeuler sysconfig]#
```

切换到用户家目录：

```bash
方法一：
[root@openeuler sysconfig]# cd 
[root@openeuler ~]#

方法二：
[root@openeuler sysconfig]# cd ~
[root@openeuler ~]#
```

步骤四：mkdir创建目录。

在当前文件夹创建test1目录：

```bash
快速写法：
[root@openeuler ~]# mkdir test1
[root@openeuler ~]# ls
anaconda-ks.cfg  test1

相对路径写法：
[root@openeuler ~]# mkdir ./test1
[root@openeuler ~]# ls
anaconda-ks.cfg  test1

绝对路径写法：
[root@openeuler ~]# mkdir /root/test1
[root@openeuler ~]# ls
anaconda-ks.cfg  test1
```

步骤五：创建huawei.txt文件。

```bash
[root@openeuler ~]# touch huawei.txt
[root@openeuler ~]# ls
anaconda-ks.cfg  test1 huawei.txt
```

步骤六：复制huawei.txt到/mnt目录，并命名为huawei.txt.bak。

```bash
[root@openeuler ~]# cp huawei.txt /mnt/huawei.txt.bak
[root@openeuler ~]# ls /mnt
huawei.txt.bak
```

步骤七：复制text1目录到/mnt。

```bash
[root@openeuler ~]# cp -r test1 /mnt/
[root@openeuler ~]# ls /mnt
huawei.txt.bak test1
```

步骤八：删除/root目录下的huawei.txt文件。

```bash
[root@openeuler ~]# rm huawei.txt
rm: remove regular empty file 'huawei.txt'?    //这里输入y，同意删除
[root@openeuler ~]# ls
anaconda-ks.cfg  test1
```

步骤九：删除/root目录下的test1文件夹以及/mnt下的test1文件夹。

```bash
[root@openeuler ~]# rmdir test1
[root@openeuler ~]# rmdir /mnt/test1
```

步骤十：剪切/mnt目录下的huawei.txt.bak文件到/root目录下，并重命名为huawei.txt文件。

```bash
[root@openeuler ~]# mv /mnt/huawei.txt.bak  ~/huawei.txt
[root@openeuler ~]# ls
anaconda-ks.cfg  huawei.txt
```

步骤十一：创建huawei.txt的硬链接到/mnt，并命名为huawei1.txt。

```bash
[root@openeuler ~]# ln huawei.txt /mnt/huawei1.txt
[root@openeuler ~]# ls -l /mnt
-rw-------. 2 root root 0 Feb 10 14:11 huawei1.txt    //此处数字是2
```

步骤十二：创建huawei.txt的软链接到/mnt，并命名为huawei2.txt。

```bash
[root@openeuler ~]# ln -s huawei.txt /mnt/huawei2.txt
[root@openeuler ~]#ls -l /mnt
-rw-------. 2 root root  0 Feb 10 14:11 huawei1.txt
lrwxrwxrwx. 1 root root 10 Feb 10 14:15 huawei2.txt -> huawei.txt
```

步骤一：拷贝/etc/passwd文件到/root目录。

```bash
[root@openeuler ~]# cp /etc/passwd ~
```

步骤二：cat查看passwd文件的内容。

```bash
[root@openeuler ~]# cat passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin
systemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin
systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
systemd-resolve:x:193:193:systemd Resolver:/:/sbin/nologin
saslauth:x:998:76:Saslauthd user:/run/saslauthd:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
systemd-timesync:x:997:995:systemd Time Synchronization:/:/sbin/nologin
unbound:x:996:994:Unbound DNS resolver:/etc/unbound:/sbin/nologin
polkitd:x:995:993:User for polkitd:/:/sbin/nologin
rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
avahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologin
dnsmasq:x:991:991:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/usr/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
radvd:x:75:75:radvd user:/:/sbin/nologin
qemu:x:107:107:qemu user:/:/sbin/nologin
apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin
dhcpd:x:177:177:DHCP server:/:/sbin/nologin
named:x:25:25:Named:/var/named:/bin/false
setroubleshoot:x:990:989::/var/lib/setroubleshoot:/sbin/nologin
gluster:x:989:988:GlusterFS daemons:/run/gluster:/sbin/nologin
cockpit-ws:x:988:987:User for cockpit-ws:/:/sbin/nologin
stap-server:x:987:983:Systemtap Compile Server:/var/lib/stap-server:/sbin/nologin
chrony:x:986:982::/var/lib/chrony:/sbin/nologin
dbus:x:981:981:System Message Bus:/:/usr/sbin/nologin
test:x:1000:1000:test:/home/test:/bin/bash
```

步骤三：head查看文件前10行内容。

```bash
[root@openeuler ~]# head passwd      //head命令不加任何参数默认查看文件前10行内容。
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
```

步骤四：head查看文件前5行内容。

```bash
[root@openeuler ~]# head -n 5 passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

步骤五：head查看文件除最后20行以外的全部内容。

```bash
[root@openeuler ~]# head -n -20 passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin
systemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin
systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
systemd-resolve:x:193:193:systemd Resolver:/:/sbin/nologin
saslauth:x:998:76:Saslauthd user:/run/saslauthd:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
```

步骤六：head查看文件前10个字节内容。

```bash
[root@openeuler ~]# head -c 10 passwd
root:x:0:0[root@openeuler ~]#
```

**思考：如何查看文件除了最后100个字节以外的全部内容？**

步骤七：tail查看文件最后10行内容。

```bash
[root@openeuler ~]# tail passwd      //同head一样，默认显示最后10行内容。
apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin
dhcpd:x:177:177:DHCP server:/:/sbin/nologin
named:x:25:25:Named:/var/named:/bin/false
setroubleshoot:x:990:989::/var/lib/setroubleshoot:/sbin/nologin
gluster:x:989:988:GlusterFS daemons:/run/gluster:/sbin/nologin
cockpit-ws:x:988:987:User for cockpit-ws:/:/sbin/nologin
stap-server:x:987:983:Systemtap Compile Server:/var/lib/stap-server:/sbin/nologin
chrony:x:986:982::/var/lib/chrony:/sbin/nologin
dbus:x:981:981:System Message Bus:/:/usr/sbin/nologin
test:x:1000:1000:test:/home/test:/bin/bash
```

步骤八：tail查看文件后5行内容。

```bash
[root@openeuler ~]# tail -n 5 passwd
cockpit-ws:x:988:987:User for cockpit-ws:/:/sbin/nologin
stap-server:x:987:983:Systemtap Compile Server:/var/lib/stap-server:/sbin/nologin
chrony:x:986:982::/var/lib/chrony:/sbin/nologin
dbus:x:981:981:System Message Bus:/:/usr/sbin/nologin
test:x:1000:1000:test:/home/test:/bin/bash
```

步骤九：查看文件除了前面20行以外剩下的所有内容。

```bash
[root@openeuler ~]# tail -n -20 passwd
systemd-timesync:x:997:995:systemd Time Synchronization:/:/sbin/nologin
unbound:x:996:994:Unbound DNS resolver:/etc/unbound:/sbin/nologin
polkitd:x:995:993:User for polkitd:/:/sbin/nologin
rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
avahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologin
dnsmasq:x:991:991:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/usr/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
radvd:x:75:75:radvd user:/:/sbin/nologin
qemu:x:107:107:qemu user:/:/sbin/nologin
apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin
dhcpd:x:177:177:DHCP server:/:/sbin/nologin
named:x:25:25:Named:/var/named:/bin/false
setroubleshoot:x:990:989::/var/lib/setroubleshoot:/sbin/nologin
gluster:x:989:988:GlusterFS daemons:/run/gluster:/sbin/nologin
cockpit-ws:x:988:987:User for cockpit-ws:/:/sbin/nologin
stap-server:x:987:983:Systemtap Compile Server:/var/lib/stap-server:/sbin/nologin
chrony:x:986:982::/var/lib/chrony:/sbin/nologin
dbus:x:981:981:System Message Bus:/:/usr/sbin/nologin
test:x:1000:1000:test:/home/test:/bin/bash
```

步骤十：less查看文件，按上下键翻行，按空格键向下翻页，按Q键退出。

```bash
[root@openeuler ~]# less passwd
```

![img](https://cdn-source.zj-huawei.com:443/service-exam/e355da44_218.PNG?auth_key=1635840934-0-0-fab6f1d6096aa5e1eb6d999c50805f00)

步骤十一：more查看文件，按空格键向下翻页，直至退出。

```bash
[root@openeuler ~]# more passwd
```

![img](https://cdn-source.zj-huawei.com:443/service-exam/95b1d47a_231.PNG?auth_key=1635840935-0-0-eb652c1e751198d0e4a57c7e910ef9a5)

## 2. Linux主要目录用途

​							<img src="https://z3.ax1x.com/2021/11/02/IFqUv4.png" alt="IFqUv4.png" style="zoom:67%;" />](https://imgtu.com/i/IFqUv4)

​							[<img src="https://z3.ax1x.com/2021/11/02/IFqN2F.png" alt="IFqN2F.png" style="zoom:67%;" />](https://imgtu.com/i/IFqN2F)

- 文件目录：
  - /bin : bin是Binary的缩写,这个目录存放着最经常使用的命令。
  - /boot :这里存放的是启动Linux时使用的一-些核心文件,包括-些连接文件以及镜像文件。( 不要动)
  - /dev : dev是Device(设备)的缩写, 存放的是Linux的外部设备,在Linux中访问设备的方式和访问文件的方式是相同的。
  - ==/etc :这个目录用来存放所有的系统管理所需要的配置文件和子目录。==
  - ==/home :用户的主目录,在Linux中,每个用户都有一个自己的目录, - -般该目录名是以用户的账号命名的。==
  - /lib:这个目录里存放着系统最基本的动态连接共享库,其作用类似于Windows里的DLL文件。
  - /lost+found :这个目录- -般情况下是空的,当系统非法关机后,这里就存放了- -些文件。
  - /media : linux系统会自动识别一些设备,例如U盘、光驱等等,当识别后, linux会把识别的设备挂载到这个目录下。
  - /mnt :系统提供该目录是为了让用户临时挂载别的文件系统的,我们可以将光驱挂载在/mnt/上,然后进入该目录就可以查看光驱里的内容了。( 我们后面会把一些本地文件挂载在这个目录下)
  - ==/opt :这是给主机额外安装软件所摆放的目录。比如你安装-个ORACLE数据库则就可以放到这个目录下。 默认是空的。==
  - /proc:这个目录是一个虚拟的目录 ,它是系统内存的映射,我们可以通过直接访问这个目录来获取系统信息。
  - ==/root :该目录为系统管理员,也称作超级权限者的用户主目录。==
  - /sbin : s就是Super User的意思,这里存放的是系统管理员使用的系统管理程序。
  - /srv :该目录存放- -些服务启动之后需要提取的数据。
  - /sys :这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。
  - ==/tmp :这个目录是用来存放- -些临时文件的。==
  - ==/usr :这是一个非常重要的目录,用户的很多应用程序和文件都放在这个目录下,类似于windows下的program files目录。==
  - /usr/bin:系统用户使用的应用程序。
  - /usr/sbin :超级用户使用的比较高级的管理程序和系统守护程序。
  - /usr/src :内核源代码默认的放置目录。
  - ==/var :这个目录中存放着在不断扩充着的东西,我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。==
  - /run :是一个临时文件系统,存储系统启动以来的信息。当系统重启时,这个目录下的文件应该被删掉或清除。
  - /www :存放服务器网站相关的资源,环境.网站的项目。

## 3. Linux进程介绍

> 1. 交互进程，由shell启动的进程，交互进程既可以在前台运行，也可以在后台运行。
> 2. 批处理进程，与终端无关，它是被提交到个队列中的进程序列
> 3. 守护进程，又称监控进程，也就是通常说的Daemon进程，是Linux中的后台服务进程

- 虚拟内存

  > 虚拟内存就是在你电脑的物理内存不够用时把一部分硬盘空间作为内存来使用，这部分硬盘空间就叫作虚拟内存。

- ps命令

  > 常用来查看进程

  [ps输出命令字段含义:](https://z3.ax1x.com/2021/11/03/IAksN8.png)

  [<img src="https://z3.ax1x.com/2021/11/03/IAksN8.png" alt="IAksN8.png" style="zoom:67%;" />](https://imgtu.com/i/IAksN8)

- 进程的优先级

  > 在Linux中，按照时间片轮转法分配进程对CPU的使用时间，当一个进程使用完获得的CPU时间片后，就将其占用的处理机释放给其他进程
  > 操作系统赋予各进程不同的优先级，操作系统按照进程的优先级来安排其占用CPU顺序，优先级越高的进程越先获得CPU的使用权，并且CPU的使用时间也越多，进程就越快完成定义的任务
  > 一般进程的执行时的优先级范围为-20`~`19，其中-20的优先级最高，而19的优先级最低。优先级-1~-20只有管理员才可以设置，一个程序被启动时，系统设置的默认优先级是O。用户可以使用相应的工具来设置进程的优先等级
  >
  > nice和renice常用来设置系统优先级：
  >
  > 1. nice通过指定优先级启动一个特定的进程
  > 2. renice命令则用于调整已经运行的进程的优先级

- 设置安全加固

  > cron命令用于创建例行性任务。为避免任意用户通过cron命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户:
  >
  > 1. 删除/etc/cron.deny文件
  >    将/etc/cron.allow的文件属主改为root用户和root用户组
  > 2. 修改/etc/cron.allow的文件权限，仅root用户可操作

  ~~~bash
  chown root:root /etc/cron.allow
  ~~~

  ~~~bash
  chmod og-rwx /etc/cron.allow
  ~~~

## 4. linux目录管理

> Linux系统是一种典型的多用户系统 ,不同的用户处于不同的地位,拥有不同的权限。为了保护系统的安全性, Linux系统对不同的
> 用户访问同一文件(包括目录文件)的权限做了不同的规定。
> 在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组。

- 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等:
  - 当为[d]则是目录
  - 当为[-]则是文件;
  - 若是[l]则表示为链接文档( link file );
  - 若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置); 
  - 若是[c]则表示为装置文件里面的串行端口设备,例如键盘、鼠标( - -次性读取装置)。

[Linux的目录权限示例：](https://z3.ax1x.com/2021/11/25/okvbUx.png)

​							权限			文件数	属主	属组			大小	时间						—>表示l开头的链接文件指向谁

​					[<img src="https://z3.ax1x.com/2021/11/25/okvbUx.png" alt="okvbUx.png" style="zoom:50%;" />](https://imgtu.com/i/okvbUx)

如上图左侧字符中,以三个为一组,且均为「rwxJ的三个参数的组合。
其中，[r ]代表可读(read)、[ w ]代表可写(write)、[ X ]代表可执行(execute)、[-]表示没有执行权限。

[目录权限：](https://z3.ax1x.com/2021/11/25/oAuEKs.png)

​				[<img src="https://z3.ax1x.com/2021/11/25/oAuEKs.png" alt="oAuEKs.png" style="zoom:50%;" />](https://imgtu.com/i/oAuEKs)

- 修改文件属性

  - chgrp更改文件属组

    ~~~shell
    chgrp [-R] 想修改的属组名 文件名
    #-R:递归更改文件属组,就是在更改某个目录文件的属组时,如果加上-R的参数,那么该目录下的所有文件的属组都会更改。
    ~~~

  - chown更改文件属主，也可同时更改文件属组

    ~~~shell
    chown [-R] 属主名  文件名
    chown [-R] 属主名: 属组名 文件名
    ~~~

  - ==chmod更改文件九个属性==

    ~~~shell
    chmod [-R] xyz 文件或目录
    #上面说过linux文件权限属性一共十位：drwxr-xr-x，除了开头的一位字母是用来显示文件类型的，后面九位代表三组，每组有rwx三个属性。xyz则分别表示这三组每一组权重占比的和。
    ~~~

    > Linux下文件权重占比：
    >
    > r：4        w：2        x：1
    >
    > 可读可写不可执行：rw-    6
    >
    > 可读可写可执行：    rwx    7

    ~~~shell
    chmod -R 777 list					  #赋予list文件可读可写可执行权限
    ~~~

  ## 5. linux下查看文件

  ~~~shell
  cat 文件名									# 查看文件内容
  tac	文件名									# 到这查看文件内容
  nl	文件名									# 查看文件内容时显示行号
  more 文件名								# 一页一页的显示内容(空格代表翻页，Enter代表向下看一行)
  less 文件名								# 和more命令类似，但less可以向上翻页(空格翻页，上下键向上或向下翻一行)
  ~~~

  > 查找字符串'/'要查询的字符向下查询,向上查询使用'?'要查询的字符串

# 三. iSula容器

> iSula通用容器引擎相比Docker，是一种新的容器解决方案，提供统一的架构设计来满足CT和IT领域的不同需求;相比Golang编写的Docker，iSula轻量级容器使用C/C++实现，具有轻、灵、巧、快的特点，不受硬件规格和架构的限制，底层开销更小，可应用领域更为广泛。

[iSula容器：](https://z3.ax1x.com/2021/11/03/IVS2TS.png)

​						[<img src="https://z3.ax1x.com/2021/11/03/IVS2TS.png" alt="IVS2TS.png" style="zoom:67%;" />](https://imgtu.com/i/IVS2TS)

## 1. iSula容器的安装

- 使用yum命令安装

  ~~~bash
  yum install -y iSulad
  ~~~

- 使用rpm命令安装

  ~~~bash
  sudo rpm -ihv iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm
  ~~~

## 2. iSulad部署

> 轻量级容器引擎( iSulad)服务端daemon(守护进程)为isulad
>
> isulad可以通过配置文件进行配置，也可以通过命令行的方式进行配置优先级从高到低是:命令行方式>配置文件>代码中默认配置

- 命令行用法：isulad [global options]

  ~~~bash
  $ isulad -L DEBUG
  /*启动isulad，并将日志级别调整成DEBUG模式。*/
  ~~~

- 创建容器

  > 用法:isula create [OPTIONS] IMAGE [COMMAND] [ARG...]

  ~~~bash
  $ isula create busybox
  ~~~

- 查看所有的容器命令如下：

  ```bash
  $ docker ps -a
  ```

- 启动容器

  > isula start命令用于启动一个或多个容器
  > 用法: isula start [OPTIONS] CONTAINER[CONTAINER...] (容器ID)

  ~~~bash
  $ isula start fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1
  ~~~

- 运行容器

  > isula run命令用于创建一个新的容器并运行。会使用指定的容器镜像创建容器读写层，并且为运行指定的命令做好准备。创建完成后，系统会自动使用指定的命令启动该容器
  > 用法:isula run [OPTIONS]ROOTFS|IMAGE [COMMAND][ARG...]

  ~~~bash
  $ isula run -itd busybox
  -i: 交互式操作。
  -t: 终端。
  -d: 后台运行容器，并返回容器ID
  ~~~

- 进入容器

  > isula attach命令用于将当前终端的标准输入、标准输出和标准错误连接到止仕运行的容器
  > 用法:isula attach [OPTIONS] CONTAINERattach命令支持参数如下:
  > -H，-host，指定要连接的iSulad socket文件路径-D，-debug，开启debug模式
  > 约束限制:原生docker attach容器会直接进入容器，而isulad attach容器后需要敲一个回车才进入

  ```bash
  $ docker attach fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1
  ```

- 容器中运行命令

  > isula exec命令用于在运行中的容器里运行一个新命令。新运行的命令将在容器的默认目录中运行。如果基础镜像指定了自定义目录，则将使用该目录
  > 用法:isula exec [OPTIONS] CONTAINER COMMAND[ARG...] 

  ~~~bash
  $isula exec c75284634bee echo "hello,world"
  hello,world
  ~~~

- isula top用于查看容器中的进程信息:

  ~~~bash
  $ isula top 21fac8bb9ea8e0be4313c8acea765c8b4798b7d06e043bbab99fc20efa72629
  ~~~

- isula stats用于实时显示资源使用的统计信息:

  ~~~bash
  $ isula stats --no-stream 21fac8bb9ea8e0be4313c8acea765c8b4798b7d06e043bbab99fc20efa72
  ~~~

- isula其他命令

  [其他命令：](https://z3.ax1x.com/2021/11/03/IV3lfH.png)

  [<img src="https://z3.ax1x.com/2021/11/03/IV3lfH.png" alt="IV3lfH.png" style="zoom:67%;" />](https://imgtu.com/i/IV3lfH)

- 容器健康配置

  > iSula容器健康检查机制添加了用户自定义的对容器进行健康检查的功能
  > 在容器创建时配置-health-cmd选项，在容器内部周期性地执行命令，通过命令的返回值来监测容器的健康状态

  ~~~bash
  isula run -itd --health-cmd "echo iSulad >>/tmp/health_check_file || exit 1" --health-interval 5m --health-timeout 3s --health-exit-on-unhealthy centos bash
  ~~~

# 五. openGauss

## 1. GaussDB数据库总览

- OLTP概念：

  > OLTP是传统关系数据库的主要应用
  >
  > 1. 面向基本的，日常的事务处理，例如银行储蓄业务的存取交易，转账交易等。
  > 2. 特点
  >    - 大吞吐量:大量的短在线事务（插入、更新、删除），非常快速的查询处理。
  >    - 高并发，（准）实时响应。
  >
  > 3. 典型的OLTP场景
  >
  >    - 零售系统
  >
  >    - 金融交易系统
  >    - 火车票销售系统
  >    - 秒杀活动

- OLAP概念：

  > OLAP

## 2. 系统框架

[框架示意图：](https://z3.ax1x.com/2021/11/04/IVxyzn.png)

​													[<img src="https://z3.ax1x.com/2021/11/04/IVxyzn.png" alt="IVxyzn.png" style="zoom:67%;" />](https://imgtu.com/i/IVxyzn)

> OM:运维管理模块（ Operation Manager) 。提供集群日常运维、配置管理的管理接口、工具。
> 客户端驱动( client Driver) :负责接收来自应用的访问请求，并向应用返回执行结果;负责与openGauss实例的通信，下发soL在openGauss实例上执行，并接收命令执行结果。
> openGauss主备(Datanode ) :负责存储业务数据(支持行存、列存、内存表存储)、执行数据查询任务以及向客户端驱动返回执行结果。
> Storage:服务器的本地存储资源，持久化存储数据。

## 3. 数据库物理结构

> 数据库的文件默认保存在initdb时创建的数据目录中。在数据目录中有很多类型、功能不同的目录和文件，除了数据文件之外，还有参数文件、控制文件、数据库运行日志及预写日志等。

- 数据库结构：

  [结构示意图目录：](https://z3.ax1x.com/2021/11/04/IZSl3d.png)

  [<img src="https://z3.ax1x.com/2021/11/04/IZSl3d.png" alt="IZSl3d.png" style="zoom:67%;" />](https://imgtu.com/i/IZSl3d)

  [<img src="https://z3.ax1x.com/2021/11/04/IZSa4g.png" alt="IZSa4g.png" style="zoom:67%;" />](https://imgtu.com/i/IZSa4g)

# ==六. docker容器==

> 定义：容器是容器镜像运行的实例。
>
> 概念：容器是集装箱，为了解决开发时的环境部署问题。

## 1. docker的组成

[docker架构：](https://z3.ax1x.com/2021/11/17/I50s8U.png)

​						[<img src="https://z3.ax1x.com/2021/11/17/I50s8U.png" alt="I50s8U.png" style="zoom: 50%;" />](https://imgtu.com/i/I50s8U)

- 组成部分：

  1. **镜像(image):**

     > 镜像是一个模板，可以通过这个模板来创建容器服务：tomcat镜像----->run------>tomcat01(提供服务)，通过这个镜像我们可以创建多个容器(最终服务运行或者项目运行就是在容器中的)。

  2. **容器(container)**

     > docker利用容器技术，独立运行一个或者多个应用，通过镜像来创建。
     >
     > 可以用来启动，停止，删除，等一些基本命令。

  3. **仓库(repository)**

     > 仓库存放镜像的地方，该技术和应用类似于GitHub。
     >
     > 仓库分为公有仓库和私有仓库。仓库默认为官方仓库(docker Hub)。建议配置加速服务。

## 2. 安装docker

- 环境查看

  ~~~shell
  acid@acid-PC:~$ uname -r
  5.10.60-amd64-desktop
  #保持内核在3.10以上
  ~~~

- docker 安装

  1. 卸载旧版本

     ~~~shell
     yum remove docker \
         docker-client \
         docker-client-latest \
         docker-common \
         docker-latest \
         docker-latest-logrotate \
         docker-logrotate \
         docker-engine
     ~~~

  2.  安装安装包

     ~~~shell
     yum install -y yum-utils
     ~~~

  3.  设置镜像仓库,使用阿里云镜像

     ~~~shell
     yum-config-manager \
     	--add-repo \
     	http://mirrors.aliyun.com/docker-ce/1inux/centos/docker-ce.repo
     ~~~

  4.  安装docker引擎 docker-ce(社区版)	docker-ee(企业版)

     ~~~shell
     yum install docker-ce docker-ce-cli containerd.io
     ~~~

  5. 启动并验证docker

     ~~~shell
     systemctl start docker		#启动
     docker version				#验证版本信息等
     ~~~

  6. 测试并查看镜像

     ~~~shell
     docker run hello-world
     docker images
     ~~~

     [run的运行流程：](https://z3.ax1x.com/2021/11/17/I5hhOx.png)

     [<img src="https://z3.ax1x.com/2021/11/17/I5hhOx.png" alt="I5hhOx.png" style="zoom: 50%;" />](https://imgtu.com/i/I5hhOx)

- 卸载docker

  1. 卸载docker包： 

     ~~~shell
     yum remove docker-ce docker-ce-cli containerd.io
     ~~~

  2.   删除所有图像、容器和卷：

     ~~~shell
     rm -rf /var/lib/docker
     rm -rf /var/lib/containerd
     ~~~

## 3. docker底层原理

[docker工作原理图：](https://z3.ax1x.com/2021/11/18/IIgAMV.png)

[<img src="https://z3.ax1x.com/2021/11/18/IIgAMV.png" alt="IIgAMV.png" style="zoom: 67%;" />](https://imgtu.com/i/IIgAMV)

- docker比虚拟机快的原因

  1. docker有着比虚拟机更少的抽象层

     > 虚拟机要虚拟一整个操作系统。而docker是共享主机内核，直接运行服务，所有应用在服务里运行。

     [docker抽象层：](https://z3.ax1x.com/2021/11/18/II2o9A.png)

     [<img src="https://z3.ax1x.com/2021/11/18/II2o9A.png" alt="II2o9A.png" style="zoom:67%;" />](https://imgtu.com/i/II2o9A)

  2. docker利用的是宿主机的内核。如上图所示。

  3. [两者对比：](https://z3.ax1x.com/2021/11/18/IIRN8A.png)

     [<img src="https://z3.ax1x.com/2021/11/18/IIRN8A.png" alt="IIRN8A.png" style="zoom:67%;" />](https://imgtu.com/i/IIRN8A)

## 4. docker的常用命令

### 4.1 帮助命令

~~~shell
docker version					#版本信息
docker info						#docker信息
docker --help					#帮助信息
~~~

### 4.2 docker镜像命令

~~~shell
docker images --help
docker -a 						#列出所有镜像
docker -q						#只显示镜像ID
~~~

- docker搜索镜像

  ~~~shell
  docker search mysql			#官方仓库中搜索mysql镜像
  docker search mysql --filter=STARS=3000		#搜索收藏数大于3000的MySQL镜像
  ~~~

- 用pull下载镜像

  ~~~shell
  docker pull mysql			#下载最新版的MySQL镜像
  docker pull mysql:5.7		#下载5.7版本的MySQL
  ~~~

- 删除镜像

  ~~~shell
  docker rmi -f ID			#删除此id的所有镜像
  docker rmi -f $(docker images -aq)			#通过递归删除查询到的所有本地镜像
  ~~~

 ### 4.3 docker容器命令

> 有容器的情况下才能创建容器
>
> 新安装的docker需要下载系统镜像如：docker	pull	centos

- 新建容器并启动

  ~~~shell
  docker run [可选参数] image				
  --name="Name"				#容器的名字用来区分容器
  -d							#后台方式运行
  -it							#使用交互方式运行，进入容器查看内容
  -p							#指定容器的端口
  ~~~

- 启动并进入容器

  ~~~shell
  docker run -it centos /bin/bash
  docker run -it --rm centos		#启动并进入容器，并在容器关闭后删除容器
  ~~~

- 列出所有运行的容器

  ~~~shell
  docker ps -a				#列出当前正在运行的容器以及历史运行过的容器
  docker ps -a -n=1			#列出最近创建的一个容器
  ~~~

- 退出容器

  ~~~shell
  exit						#直接停止容器并推出
  Ctrl+p+q					#容器不停止推出
  ~~~

- 删除容器

  ~~~shell
  docker rm 容器ID					#删除指定的容器，不能删除运行中的容器
  docker rm -f 容器ID				#删除容器，无论容器是否正在运行
  docker rm -f $(docker ps -aq)	 #递归删除所有的容器	
  docker ps -a -q|xargs docker rm	 #递归删除所有容器
  ~~~

- 启动和停止容器的操作

  ~~~shell
  docker start 容器ID				#启动容器
  docker restart 容器ID				#重启容器
  docker stop 容器ID				#停止容器
  docker kill 容器ID				#强制停止容器
  ~~~

- 后台启动容器

  ~~~shell
  docker run -d centos			 #后台运行容器
  ~~~

  > 注意：当后台运行容器时，前台必须要有进程，否则后台的容器会自动结束进程。

- 查看日志命令

  ~~~shell
  docker logs -tf 容器ID			#显示日志
  ~~~

- 查看内部的进程信息

  ~~~shell
  docker top 容器ID					#查看进程
  ~~~

- 查看镜像源数据

  ~~~shell
  docker image inspect 容器ID				
  ~~~

- ==进入当前的正在进行的容器==

  ~~~shell
  docker exec -it 容器ID /bin/bash			#打开新端口进入容器,常用
  docker attch 容器ID						#在当前端口进入容器
  ~~~

- 拷贝容器文件到宿主机

  ~~~shell
  docker cp 容器ID:容器目录 宿主机目录		  #拷贝docker容器下的目录到宿主机指定目录
  #如：
  docker cp 2dadsihdowa:/home/test.txt /home	#将容器home文件夹下的test.txt文件拷贝到宿主机目录下
  ~~~

### 4.4 docker命令总结

~~~shell
attach			Attach to a running container						#当前she11下attach 连接指定运行镜像
build			Build an image from a Dockerfile					#通过Dockerfile定制镜像
commit			Create a new image from a container changes			#提交当前容器为新的镜像
cp				Copy files/folders from the containers filesystem to the host path	#从容器中拷贝指定文																						件或者目录到宿主机中
create			Create a new container								#创建一个新的容器，同run,但不启动容器
diff			Inspect changes on a container's filesys tem		#查看docker 容器变化
events			Get rea1 time events from the server				#从docker服务获取容器实时事件
exec			Run a command in an existing container				#在已存在的容器上运行命令
export			Stream the contentsI of a container as a tar archive#导出容器的内容流作为一个tar归档文件[对应
import]
history 		Show the history of an image						#展示一个镜像形成历史
images			List images											#列出系统当前镜像
import			Create a new filesystem image from the contents of a tarba11 #从tar包中的内容创建一个新的文件 																			  系统映像[对应export]
info			Display sys tem-wide information					#显示系统相关信息
inspect			Return 1ow-1eve1 information on a container			#查看容器详细信息
ki11			Ki11 a running container							# ki11指定docker容器
load			Load an image from a tar archive					#从一个tar包中加载-一个镜像[对应save]
1ogin			Register or Login to the docker registry server		#注册或者登陆一个docker源服务器
logout			Log out from a Docker registry server				#从当前Docker registry退出
1ogs			Fetch the 1ogs of a container 						#输出当前容器日志信息
port			Lookup the public-facing port which is NAT-ed to PRIVATE_ PORT#查看映射端口对应的容器内部源端
pause			Pause a11 processes within a container				#暂停容器
ps				List containers										#列出容器列表
pu11			Pu11 an image or a repository from the docker registry server	#从docker镜像源服务器拉取指																				  定镜像或者库镜像
push			Push an image or a repository to the docker registry server		#推送指定镜像或者库镜像至																					 docker源服务器
restart 		Restart a running container							#重启运行的容器
rm				Remove one or more containers						#移除一个或者多个容器
rmi				Remove one or more i mages							#移除一个或多个镜像[无容器使用该镜像才可删																	除，否则需删除相关容器才可继续或-f强制删除]
run				Run a command in a new container					#创建一个新的容器并运行一个命令
save			Save an image to a tar archive						#保存一个镜像为一个tar包[对应load]
search 			Search for an image on the Docker Hub				#在docker hub中搜索镜像
start			Start a stopped containers							#启动容器
stop			Stop a running containers							#停止容器
tag 			Tag an image into a repository						#给源中镜像打标签
top				Lookup the running processes of a container			#查看容器中运行的进程信息
unpause			Unpause a paused container							#取消暂停容器
version			Show the docker version information					#查看docker版本号
wait			B1ock until a container stops， then print its exit code	#截取容器停止时的退出状态值		
port  	  # 查看映射端口对应的容器内部源端口
pause	  # 暂停容器
ps        # 猎户容器列表
pull      # 从docker镜像源服务器拉取指定镜像或者库镜像
push      # 推送指定镜像或者库镜像至docker源服务器
restart   # 重启运行的容器
rm        # 移除一个或多个容器
rmi       # 移除一个或多个镜像 （无容器使用该镜像才可删除，否则需要删除相关容器才可继续或 -f 强制删除）
run       # 创建一个新的容器并运行一个命令
save      # 保存一个镜像为一个 tar 包【对应 load】
search    # 在 docker hub 中搜索镜像
start     # 启动容器
stop      # 停止容器
tag       # 给源中镜像打标签
top       # 查看容器中运行的进程信息
unpause   # 取消暂停容器
version   # 查看 docker版本号
wait      # 截取容器停止时的退出状态值
~~~

## 5. docker部署Nginx

~~~shell
docker pull nginx									#拉取nginx镜像
docker run -d --name nginx01 -p 8080:80 nginx		#运行名为nginx01的nginx容器，并将80端口映射给本地8080端口
~~~

> 参数详解
>
> -d		后台运行
>
> --name		给容器命名
>
> -p		端口暴露(映射)：宿主机端口：容器内部端口

- [端口暴露(映射)：](https://z3.ax1x.com/2021/11/18/I7FiUP.png)

  ​					[<img src="https://z3.ax1x.com/2021/11/18/I7FiUP.png" alt="I7FiUP.png" style="zoom: 67%;" />](https://imgtu.com/i/I7FiUP)

> 将nginx的80端口映射给宿主机，打通防火墙。

## 6. docker部署tomcat

~~~shell
docker pull tomcat
docker run -d -p 8080:8080 --name tomcat01 tomcat
curl localhost(或弹性公网):8080						#查看部署后的网页信息
~~~

## 7. docker镜像加载原理

- UnionFS(联合文件系统)

  > UnionFS (联合文件系统) : Union文件系统( UnionFS)是一种分层、轻量级并且高性能的文件系统,它支持对文件系统的修改
  > 作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual
  > filesystem)。Union 文件系统是Docker镜像的基础。镜像可以通过分层来进行继承,基于基础镜像(没有父镜像) , 可以制作各
  > 种具体的应用镜像。
  > 特性: 一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的
  > 文件系统会包含所有底层的文件和目录

- docker镜像加载原理

  > docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS。
  > bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系
  > 统,在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的 ,包含boot加载器和内核。当boot加载完成
  > 之后整个内核就都在内存中了,此时内存的使用权已由bootfs转交给内核,此时系统也会卸载bootfs.
  > rootfs (root file system) , 在bootfs之上。包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs就是
  > 各种不同的操作系统发行版,比如Ubuntu , Centos等等。

- [镜像加载原理图：](https://z3.ax1x.com/2021/11/18/I7KEo4.png)

​						[<img src="https://z3.ax1x.com/2021/11/18/I7KEo4.png" alt="I7KEo4.png" style="zoom:67%;" />](https://imgtu.com/i/I7KEo4)	

## 8. 镜像分层

- 原理

  > 所有的Docker镜像都起始于一个基础镜像层,当进行修改或增加新的内容时,就会在当前镜像层之上,创建新的镜像层。
  > 举一个简单的例子,假如基于Ubuntu Linux 16.04创建一个新的镜像 ,这就是新镜像的第一层;如果在该镜像中添加Python包，
  > 就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁,就会创建第三个镜像层。
  > 该镜像当前已经包含3个镜像层,如下图所示(这只是- -个用于演示的很简单的例子)。

[分层示意图：](https://z3.ax1x.com/2021/11/19/IHiLJf.png)

​						[<img src="https://z3.ax1x.com/2021/11/19/IHiLJf.png" alt="IHiLJf.png" style="zoom:67%;" />](https://imgtu.com/i/IHiLJf)

> 在添加额外的镜像层的同时,镜像始终保持是当前所有镜像的组合,理解这一点非常重要。 下图中举了一个简单的例子,每个镜像
> 层包含3个文件,而镜像包含了来自两个镜像层的6个文件。

[镜像文件：](https://z3.ax1x.com/2021/11/19/IHFJ6e.png)

​						[<img src="https://z3.ax1x.com/2021/11/19/IHFJ6e.png" alt="IHFJ6e.png" style="zoom:67%;" />](https://imgtu.com/i/IHFJ6e)				

> 上图中的镜像层跟之前图中的略有区别,主要目的是便于展示文件。
> 下图中展示了一个稍微复杂的三层镜像,在外部看来整个镜像只有6个文件,这是因为最上层中的文件7是文件5的一个更新版本。

[镜像文件2：](https://z3.ax1x.com/2021/11/19/IHn8L8.png)

​						[<img src="https://z3.ax1x.com/2021/11/19/IHn8L8.png" alt="IHn8L8.png" style="zoom:67%;" />](https://imgtu.com/i/IHn8L8)

> 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为-个新镜像层添加到镜像当中。
> Docker通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈,并保证多镜像层对外展示为统一的文件系统。
> Linux.上可用的存储引擎有AUFS、Overlay2、 Device Mapper、Btrfs 以及ZFS。顾名思义,每种存储弓|擎都基于Linux中对应的
> 文件系统或者块设备技术,并且每种存储弓|擎都有其独有的性能特点。
> Docker在Windows上仅支持windowsfilter -种存储引擎,该引擎基于NTFS文件系统之上实现了分层和CoW[1]。.
> 下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并,对外提供统一的视图。

[镜像文件3：](https://z3.ax1x.com/2021/11/19/IHuG11.png)

​							[<img src="https://z3.ax1x.com/2021/11/19/IHuG11.png" alt="IHuG11.png" style="zoom:67%;" />](https://imgtu.com/i/IHuG11)

- 特点：

  > Docker镜像都是只读的,当容器启动时,一个新的可写层被加载到镜像的顶部!
  > 这一层就是我们通常说的容器层,容器之下的都叫镜像层!

## 9. 制作镜像

> docker	commit	提交容器成为一个新的副本
>
> docker	commit	-m="提交的描述信息"	-a="作者"	容器ID	镜像名：[版本号]					#和Git原理类似

- 制作流程

  ~~~shell
  docker run -it -p 8080:8080 tomcat					#启动tomcat
  docker exec -it 容器ID /bin/bash					   #进入容器
  cp -r webapps.dist/* webapps						#拷贝webapps.dist下的所有文件到webapps，此时镜像改变
  exit			
  docker commit -a="syb" -m="web" 容器ID tomcat02:1.0  #新容器名字为tomcat02版本为1.0
  ~~~

  > 如果想保存当前容器状态，就可以使用这种方法来创建一个镜像节点(类似于VM的快照)。

## 10. 容器数据卷的使用

> 数据卷可以实现容器持久化和同步化操作，容器间也是可以数据共享的。

### 10.1 使用数据卷

> -v：挂在命令
>
> -v	需要挂到的宿主机目录：容器挂载目录
>
> 好处：以后只需要在本地修改文件即可，容器会自动同步。

~~~shell
docker run -it -v /home/test:/home centos /bin/bash	   #运行一个centos容器，将容器home目录挂载到宿主机的test目录
docker inspect 容器ID									  #查看容器挂在信息
~~~

### 10.2 安装部署MySQL

- 先获取镜像

  ~~~shell
  docker pull MySQL
  docker run -d -p 3310:3306 -v /home/mysq1/conf:/etc/mysq1/conf.d -v /home/mysq1/data:/var/1ib/mysq1 -e MYSQL_ ROOT_ PASSWORD=123456 --name mysq101 mysq1
  ~~~

  > 运行mysql01容器将配置文件conf.d映射个宿主机conf目录，将数据文件夹mysql映射给宿主机的data目录，使用-e参数配置数据库密码。启动数据库。
  >
  > -d	后台运行
  >
  > -p	端口映射
  >
  > -v	数据卷挂载
  >
  > -e	环境配置
  >
  > 可以使用sqlyog测试：sqlyog------>连接到服务器3310-------->3310和容器内的3306进行映射--------->连接成功

### 10.3 具名和匿名挂载

- 匿名挂载

  > 匿名挂载就是使用参数-v时不指定宿主机路径。

  ~~~shell
  docker run -d -P --name nginx01 -v /etc/nginx:rw nginx					#rw表示可读可写。默认为rw
  ~~~

- 剧名挂载

  > 剧名挂载就是在挂载时指定挂载卷的名字

  ~~~shell
  docker run -d -p --name nginx02 -v nginx-nginx02:/etc/nginx:ro nginx	#ro表示只读(只能通过宿主机修改文件)
  ~~~

- 总结

  > 不管是匿名挂载还是具名挂载其挂载到宿主机的路径是：/var/lib/docker/volumes/xxxx/_ data
  >
  > 大多数情况下使用具名挂载

  如何确定是具名挂载还是匿名挂载，还是指定挂载

  > 匿名挂载：-v   容器路径
  >
  > 具名挂载：-v   卷名：容器路径
  >
  > 指定挂载：-v    /宿主机路径：容器路径

## 10.4容器数据卷

> 主要解决容器与容器之间的互通问题
>
> 命令：挂载的子容器	--volumes-from	挂载的父容器	镜像

~~~shell
docker run -it --name docker01 docker
docker run -it --name docker02 --volumes-from docker01 dockerfile01
~~~

- 多个MySQL实现数据库共享

  ~~~shell
  docker run -d -p 3310:3306 -v /etc/mysq1/conf.d -v /var/lib/mysql -e MYSQL_ ROOT_ PASSWORD=123456 --name mysq101 mysq1											#启动mysql01并将两个数据卷进行匿名挂载
  docker run -d -p 3310:3306 -v -e MYSQL_ ROOT_ PASSWORD=123456 --name mysq102 --volumes-from mysql01 mysq1														#将mysql02绑定父容器mysql01
  ~~~

  > 容器之间配置信息的传递,数据卷容器的生命周期一直持续到没有容器使用为止。
  > 但是一旦你持久化到了本地，这个时候,本地的数据是不会删除的。

## 11 Dockerfile

> dockerfile和commit一样都是用来构建docker镜像文件的
>
> 本质是构建文件，命令参数脚本，每一行命令都会创建提交一个新的镜像，并提交。
>
> build	构建镜像
>
> push	发布镜像	

[dockerfile镜像构建：](https://z3.ax1x.com/2021/11/21/IXqtH0.png)

​											[<img src="https://z3.ax1x.com/2021/11/21/IXqtH0.png" alt="IXqtH0.png" style="zoom:67%;" />](https://imgtu.com/i/IXqtH0)

### 11.1 dockerfile命令

[命令详解：](https://z3.ax1x.com/2021/11/21/IXj9rd.png)

> FROM	基础镜像名(centos/ubunt........)，注意：FROM scratch为基层镜像，所有的镜像都是根据他构建的。
>
> MAINTAINER	姓名+邮箱
>
> RUN	运行镜像
>
> ADD	添加的内容(如项目需要用到tomcat，就需要添加tomcat压缩包)
>
> WORKDIR	镜像的工作目录
>
> VOLUME	挂载的目录位置
>
> EXPOSE	暴露端口配置(与-p参数一样)
>
> CMD	指定容器启动时要运行的命令，只有命令行中的最后一个参数生效，不能追加命令，可以被替代。
>
> ENTRYPOINT	指定这个容器启动时要运行的命令，可以追加命令。
>
> ONBUILD	当构建一个被继承的docekrfile，这个时候就会运行ONBUILD的指令，触发指令。
>
> COPY	类似ADD，将我们的文件拷贝到镜像中。
>
> ENV	构建的时候设置环境变量

​					[<img src="https://z3.ax1x.com/2021/11/21/IXj9rd.png" alt="IXj9rd.png" style="zoom:67%;" />](https://imgtu.com/i/IXj9rd)

### 11.2 dockerfile实例

- dockerfile脚本

  ~~~shell
  cd /home
  mkdir dockertest
  vim dockerfile01						#创建dockerfile文件
  #dockerfile01内容：指令要大写
  FROM centos								#基础镜像，表明开始构建镜像 
  VOLUME ["volume01","volume02"]			#进行匿名挂载
  CMD echo"*********************"
  CMD /bin/bash
  ~~~

- 生成镜像

  > docker	build	-f	dockerfile文件路径	-t	镜像名:版本号	.

  ~~~shell
  docker build -f /home/dockertest/dockerfile01 -t sybcentos:1.0 .
  ~~~

- dockerfile脚本(2)

  ~~~shell
  #mydockerfile
  FROM centos
  MAINTAINER syb<1973295103@qq.com>
  ENV MYPATH /usr/local
  WORKDIR $MYPATH
  RUN yum install vim
  RUN yum install net-tools
  EXPOSE 80
  CMD echo $MYPATH							#看看是否成功输出环境变量
  CMD /bin/bash								选择进入bin/bash命令行
  ~~~

- 生成镜像

  > docekr    build    -f    mydockerfile    -t    mycentos:1.0    .

### 11.3 CMD和ENTRYPOINT区别

  - CMD参数：

    ~~~shell
    #dockerfile:
    FROM centos
    CMD ["ls","-a"]
    ~~~

    ~~~shell
    docker build -f dockerfile -t cmdtest .
    docker run cmdtest
    ~~~

    > 上面构建了一个简单的centos镜像，执行后会得到容器内的所有目录.

    ~~~shell
    docker run cmdtest -l					#如果执行该命令后会报错，因为cmd不支持参数追加
    docker run cmdtest ls -al				#该命令执行后会替换掉镜像容器中的CMD ["ls","-a"]
    ~~~

  - ENTRYPOINT参数：

    ~~~shell
    #dockerfile2:
    FROM centos
    ENTRYPOINT ["ls","-a"]
    ~~~

    >该命令构建后执行如下命令会得到docker run cmdtest ls -al    一样的效果

    ~~~shell
    docke run dockerfile2 -l
    ~~~

  - 总结

    > CMD不能追加拼接命令
    >
    > ENTRYPOINT可以追加拼接命令

### 11.4 构建Tomcat镜像

### 11.5 发布镜像

~~~shell
docker push 作者/容器名(ID):版本号
~~~

## 12 docker网络原理

> docker处理网络问题

~~~shell
ip addr										查看内部网络地址
docker 
~~~

# 七 . Git

## 1. 什么是Git

> 记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统，版本管理器。
>
> Git的设计理念包括以下几点:
>
> 1. 速度快
> 2. 设计简单
> 3. 强力支持非线性开发，允许上千分支并行开发
> 4. 完全的分布式
> 5. 有能力高效管理类似L inux内核-样的超大规模项目( 速度和数据量)

- Git架构

  > 每台客户端都有完整的版本库，包括完整的版本更迭的历史记录，且有一个远程库，方便交换代码的修改，比如A程序员写好了一一个版本，要推送到远程库，然后B程序员克隆该版本到本地，进行本地的版本更迭,保证远程库代码与本地库一致。

 ### 1.1 Git存储机制

> Git中版本的保存是整体的快照，而不是单个/某些文件的版本差异
>
> 1. SVN会记录哪些文件做了更新，并更新了哪些内容(一组基本文件+每个文件随时间积累的差异)
> 2. Git在每次提交更新时,它会纵览一遍所有文件的指纹信息并对文件作- -快照，然后保存一个指向这次快照的索引
> 3. 通过对文件的内容或目录的结构计算出一个SHA-1哈希值，作为指纹字符串。该字串由40个十六进制字符(0-9及a-f)组成

[Git存储机制：](https://z3.ax1x.com/2021/11/22/IxjnBQ.png)

[<img src="https://z3.ax1x.com/2021/11/22/IxjnBQ.png" alt="IxjnBQ.png" style="zoom: 67%;" />](https://imgtu.com/i/IxjnBQ)

### 1.2 Git工作区域

> Git版本控制下的工作区域有以下几种:
>
> 1. 工作区( workspace) :日常工作的代码文件或者文档所在的文件夹
> 2. 暂存区( index/ Stage) :一般存放在工程根目录.git/index文件中，所以我们也可以把暂存区叫作索引( index)用于临时存放你的改动,事实上它只是-一个文件,保存即将提交到文件列表信息。
> 3. 仓库区( repository) :简单的理解一个目录， 这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。
> 4. Remote :远程仓库,托管代码的服务器,可以简单的认为是你项目组中的一台电脑用于远程数据交换。

[Git工作区域：](https://z3.ax1x.com/2021/11/22/oSMYX8.png)

​														[![oSMYX8.png](https://z3.ax1x.com/2021/11/22/oSMYX8.png)](https://imgtu.com/i/oSMYX8)

### 1.3 Git的文件状态

> Git版本控制下的文件状态以下几种:
>
> 1. 已修改( modified) :修改了某个文件，但还没有提交保存
> 2. 已提交( committed ) :该文件已经被安全地保存在本地数据库中了
> 3. 已暂存( staged) :把已修改的文件放在下次提交时要保存的清单中

[Git文件状态：](https://z3.ax1x.com/2021/11/22/IxzyvV.png)

​									[<img src="https://z3.ax1x.com/2021/11/22/IxzyvV.png" alt="IxzyvV.png" style="zoom:67%;" />](https://imgtu.com/i/IxzyvV)

### 1.4 Git的工作原理

> 基本的Git工作流程如下:
>
> 1. 在工作目录中修改文件.
> 2. 暂存文件，将文件的快照放入暂存区域
> 3. 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录

[Git工作原理：](https://z3.ax1x.com/2021/11/22/IzSKMV.png)

​						[<img src="https://z3.ax1x.com/2021/11/22/IzSKMV.png" alt="IzSKMV.png" style="zoom:67%;" />](https://imgtu.com/i/IzSKMV)

## 2. Git基础命令

[Git命令预览：](https://z3.ax1x.com/2021/11/23/oSX7kj.jpg)

​									[<img src="https://z3.ax1x.com/2021/11/23/oSX7kj.jpg" alt="oSX7kj.jpg" style="zoom: 50%;" />](https://imgtu.com/i/oSX7kj)

- 配置用户名和邮箱

  > 安装Git之后必须要设置用户名和邮箱

  ~~~shell
  git config --g1oba1 user.name "your name" 			#名称
  git config --g1oba1 user.emai "your email"			#邮箱
  ~~~

- 查看配置

  ~~~shell
  git config -l										#查看全局
  git config --global --list							#查看用户配置
  git status 文件名									  #查看指定文件状态 
  ~~~


- 查看历史

  ~~~shell
  git log                         					# 查看提交历史
  git log -p               							# 查看指定文件的提交历史
  git blame                 							# 以列表方式查看指定文件的提交历史
  ~~~

- 撤销

  ~~~shell
  git reset --hard HEAD           					# 撤消工作目录中所有未提交文件的修改内容
  git reset --hard       								# 撤销到某个特定版本
  git checkout HEAD         							# 撤消指定的未提交文件的修改内容
  git checkout --          							# 同上一个命令
  git revert              							# 撤消指定的提交分支与标签
  ~~~

- 分支与标签

  ~~~shell
  git branch                      					# 显示所有本地分支
  git checkout        								# 切换到指定分支或标签
  git branch          								# 创建新分支
  git branch -d           							# 删除本地分支
  git tag                         					# 列出所有本地标签
  git tag                								# 基于最新提交创建标签
  git tag -a "v1.0" -m "一些说明"  					 # -a指定标签名称，-m指定标签说明
  git tag -d             								# 删除标签
  git checkout dev                					# 合并特定的commit到dev分支上
  git cherry-pick 62ecb3
  ~~~

- 合并与衍合

  ~~~shell
  git merge               							# 合并指定分支到当前分支
  git merge --abort               					# 取消当前合并，重建合并前状态
  git merge dev -Xtheirs          					# 以合并dev分支到当前分支，有冲突则以dev分支为准
  git rebase              							# 衍合指定分支到当前分支
  ~~~

- 远程操作

  ~~~shell
  git remote -v                   					# 查看远程版本库信息
  git remote show         							# 查看指定远程版本库信息
  git remote add    									# 添加远程版本库
  git remote remove       							# 删除指定的远程版本库
  git fetch               							# 从远程库获取代码
  git pull       										# 下载代码及快速合并
  git push       										# 上传代码及快速合并
  git push : 											# 删除远程分支或标签
  git push --tags                 					# 上传所有标签
  ~~~

- 打包

  ~~~shell
  git archive --format=zip --output ../file.zip master    # 将master分支打包成file.zip文件，保存在上一级目录
  git archive --format=zip --output ../v1.2.zip v1.2      # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中
  git archive --format=zip v1.2 > ../v1.2.zip             # 作用同上一条命令
  ~~~

- 提交本地文件到暂存区

  > code目录下有一个hello.xml文件

  ~~~shell
  git init											#创建仓库
  git add hello.xml									#将hello.xml文件添加到暂存区，git add. 选择所有文件
  git commit -m "文件信息"							 #将暂存区中的文件添加到本地仓库 -m 提交信息
  ~~~

- 忽略文件

  > 在我们提交项目时，有很多文件不想提交。可以用以下方法：

  > 在主目录下创建”.gitignore“文件，文件中有以下规则：
  >
  > 1. 忽略文件中的空行或以井号( # )开始的行将会被忽略。
  > 2. 可以使用Linux通配符。例如:星号( * )代表任意多个字符,问号( ? )代表一个字符,方括号( [abc] )代表可选字符范围,大括号( {string.sring...}. )代表可选的字符串等。
  > 3. 如果名称的最前面有一个感叹号 (!) , 表示例外规则,将不被忽略。
  > 4. 如果名称的最前面是一个路径分隔符(/ ) , 表示要忽略的文件在此目录下,而子目录中的文件不忽略。
  > 5. 如果名称的最后面是一个路径分隔符(1) ,表示要忽略的是此目录下该名称的子目录,而非文件(默认文件或目录都忽略)。

  ~~~shell
  *.txt									#忽略所有. txt结尾的文件,这样的话上传就不会被选中!
  !1ib. txt 								#但1ib. txt除外
  /temp									#仅忽略项目根目录下的TODO文件，不包括其它月录temp
  bui1d/									#忽略build/目录下的所有文件
  doc/*.txt								#会忽略doc/notes.txt但不包括doc/server/arch. txt
  ~~~

- 其他命令

  ~~~shell
  git init                                                  # 初始化本地git仓库（创建新仓库）
  git config --global user.name "xxx"                       # 配置用户名
  git config --global user.email "xxx@xxx.com"              # 配置邮件
  git config --global color.ui true                         # git status等命令自动着色
  git config --global color.status auto
  git config --global color.diff auto
  git config --global color.branch auto
  git config --global color.interactive auto
  git config --global --unset http.proxy                    # remove  proxy configuration on git
  git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库
  git status                                                # 查看当前版本状态（是否修改）
  git add xyz                                               # 添加xyz文件至index
  git add .                                                 # 增加当前子目录下所有更改过的文件至index
  git commit -m 'xxx'                                       # 提交
  git commit --amend -m 'xxx'                               # 合并上一次提交（用于反复修改）
  git commit -am 'xxx'                                      # 将add和commit合为一步
  git rm xxx                                                # 删除index中的文件
  git rm -r *                                               # 递归删除
  git	rm --cached 'xxx'									  # 将文件从暂存区删除
  git log                                                   # 显示提交日志
  git log -1                                                # 显示1行日志 -n为n行
  git log -5
  git log --stat                                            # 显示提交日志及相关变动文件
  git log -p -m
  git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容
  git show dfb02                                            # 可只用commitid的前几位
  git show HEAD                                             # 显示HEAD提交日志
  git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本
  git tag                                                   # 显示已存在的tag
  git tag -a v2.0 -m 'xxx'                                  # 增加v2.0的tag
  git show v2.0                                             # 显示v2.0的日志及详细内容
  git log v2.0                                              # 显示v2.0的日志
  git diff                                                  # 显示所有未添加至index的变更
  git diff --cached                                         # 显示所有已添加index但还未commit的变更
  git diff HEAD^                                            # 比较与上一个版本的差异
  git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异
  git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的
  git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容
  git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）
  git branch                                                # 显示本地分支
  git branch --contains 50089                               # 显示包含提交50089的分支
  git branch -a                                             # 显示所有分支
  git branch -r                                             # 显示所有原创分支
  git branch --merged                                       # 显示所有已合并到当前分支的分支
  git branch --no-merged                                    # 显示所有未合并到当前分支的分支
  git branch -m master master_copy                          # 本地分支改名
  git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出
  git checkout -b master master_copy                        # 上面的完整版
  git checkout features/performance                         # 检出已存在的features/performance分支
  git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支
  git checkout v2.0                                         # 检出版本v2.0
  git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出
  git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）
  git merge origin/master                                   # 合并远程master分支至当前分支
  git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改
  git push origin master                                    # 将当前分支push到远程master分支
  git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支
  git push --tags                                           # 把所有tag推送到远程仓库
  git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）
  git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支
  git pull origin master                                    # 获取远程分支master并merge到当前分支
  git mv README README2                                     # 重命名文件README为README2
  git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）
  git rebase
  git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）
  git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933
  git ls-files                                              # 列出git index包含的文件
  git show-branch                                           # 图示当前分支历史
  git show-branch --all                                     # 图示所有分支历史
  git whatchanged                                           # 显示提交历史对应的文件修改
  git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818
  git ls-tree HEAD                                          # 内部命令：显示某个git对象
  git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH
  git reflog                                                # 显示所有提交，包括孤立节点
  git show HEAD@{5}
  git show master@{yesterday}                               # 显示master分支昨天的状态
  git log --pretty=format:'%h %s' --graph                   # 图示提交日志
  git show HEAD~3
  git show -s --pretty=raw 2be7fcb476
  git stash                                                 # 暂存当前修改，将所有至为HEAD状态
  git stash list                                            # 查看所有暂存
  git stash show -p stash@{0}                               # 参考第一次暂存
  git stash apply stash@{0}                                 # 应用第一次暂存
  git grep "delete from"                                    # 文件中搜索文本“delete from”
  git grep -e '#define' --and -e SORT_DIRENT
  git gc
  git fsck
  git cat-file -p [文件名+ID前两位]							  #查看.git/objects下二进制文件内容
  git cat-file -t [文件名+ID前两位]							  #查看.git/objects下二进制文件对象
  ~~~

- 注意：全局配置保存在：$Home/.gitconfig                                              本地仓库配置保存在：.git/config

## 3. Git项目创建及克隆	

> 创建本地仓库方式有两种：
>
> 1. 创建全新的仓库
> 2. 克隆远程仓库

- 创建全新仓库

  ~~~shell
  git init												#在当前目录新建一个Git代码库，会生成一个.git文件
  ~~~

- 克隆远程仓库

  ~~~shell
  git clone [url]											#克隆一整个项目和他的代码历史。url为克隆地址
  ~~~

## ==4. 远程与本地合并==

~~~shell
git init                              # 初始化本地代码仓
git add .                             # 添加本地代码
git commit -m "add local source"      # 提交本地代码
git pull origin master                # 下载远程代码
git merge master                      # 合并master分支
git push -u origin master             # 上传代码
~~~

## 5 Gitee配置SSH公钥及创建远程仓库

> 使用ssh-keygen命令生成公钥

~~~shell
#进入用户目录下找到.SSH文件
mkdidr .ssh
ssh-keygen -t rsa											#-t rsa	使用rsa算法加密
~~~

[生成的公匙：](https://z3.ax1x.com/2021/11/22/oSJYPe.png)

​							[<img src="https://z3.ax1x.com/2021/11/22/oSJYPe.png" alt="oSJYPe.png" style="zoom: 33%;" />](https://imgtu.com/i/oSJYPe)

> 可以看到.ssh问价下会生成两个文件：id_rsa.pub(公匙)和id_rsa(私匙)
>
> 将公匙里的文本复制到Gitee即可
>
> 使用git clone [仓库地址]	克隆到本地磁盘

## 6. Git分支

### 6.1 Git五大分支原理：

> 现在Git仓库中有五个对象:三个blob对象( 保存着文件快照)、一个树对象(记录着目录结构和blob对象索引)以及一个提交对象( 包含着指向前述树对象的指针和所有提交信息)

> 在进行提交操作时，Git会保存一个提交对象( commit object )。知道了Git保存数据的方式，我们可以很自然的想到，该提交对象会包含-个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一一个父对象，而由多个分支合并产生的提交对象有多个父对象

> 对文件做修改后再次提交，那么这次产生的提交对象会包含-个指向上次提交对象(父对象)的指针

[Git分支图解：](https://z3.ax1x.com/2021/11/23/o9PEV0.png)

​						[<img src="https://z3.ax1x.com/2021/11/23/o9PEV0.png" alt="o9PEV0.png" style="zoom: 67%;" />](https://imgtu.com/i/o9PEV0)

### 6.2 Git新建分支

- 创建分支原理：

  > Git是怎么创建新分支的呢?它只是为你创建了一一个可以移动的新的指针。比如,创建一个testing分支， 你需要使用git branch命令，它会在当前所在的提交对象上创建一个指针， 现在就有两个指向相同提交历史的分支master和testing:

### 7. Git提交本代码

- 首先要创建仓库

  [新建仓库：](https://s1.ax1x.com/2022/04/24/L5XXRg.png)

  ​				[<img src="https://s1.ax1x.com/2022/04/24/L5XXRg.png" alt="L5XXRg.png" style="zoom: 33%;" />](https://imgtu.com/i/L5XXRg)

  [填写仓库配置信息：](https://s1.ax1x.com/2022/04/24/L5jSLn.png)

  ​		[<img src="https://s1.ax1x.com/2022/04/24/L5jSLn.png" alt="L5jSLn.png" style="zoom:50%;" />](https://imgtu.com/i/L5jSLn)

  [保存仓库地址](https://s1.ax1x.com/2022/04/24/L5jPoV.png)

  ​		[<img src="https://s1.ax1x.com/2022/04/24/L5jPoV.png" alt="L5jPoV.png" style="zoom: 50%;" />](https://imgtu.com/i/L5jPoV)

- 指令添加本地代码到远程

  ~~~shell
  git init   
  git add .
  git commit -m "提交描述"
  git remote add origin https://github.com/Acidmt/Notes.git   #（这里的 https://github.com/MyJoanna/test.git 是你的仓库地址）
  git push -u origin master  
  
  
  #更换仓库源
  git remote set-url origin URL
  ~~~

- [提交成功：](https://s1.ax1x.com/2022/04/24/L5v96H.png)

  ​             [<img src="https://s1.ax1x.com/2022/04/24/L5v96H.png" alt="L5v96H.png" style="zoom: 33%;" />](https://imgtu.com/i/L5v96H)

