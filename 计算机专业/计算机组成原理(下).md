[toc]

# 四. 指令系统

> 即便是对于同一台计算机，所支持的指令类别也是千差万别的。各种各样的指令应该如何设定是这一章重点探讨的内容。

指令的定义(机器指令)：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。而一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。

注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。如：x86架构、ARM架构。

## 1. 指令格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令格式通常要包括操作码字段和地址码字段两部分：

1. 操作码(OP)：想要CPU干什么。如：停机中断、求反求补、加减乘除。

2. 地址码(A)：指明这个操作对谁进行。如：不需要操作对象(停机指令)、需要操作对象(求反求补)、需要两个操作对象(运算)。

由于各种指令所需要的操作不一样，所以地址码的数目也有可能会出现变化。所以一条指令可能包含$0$个、$1$个、$2$个、$3$个、$4$个地址码根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令等。

- 零地址指令(OP)

  零地址指令只需要指明操作码即可。通常两种情况需要用到零地址指令：

  1. 不需要操作数，如空操作、停机、关中断等指令。

  2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。

     这种情况并不是不需要操作数，而是操作数会固定隐含在特定的位置。

     如：后缀表达式，堆栈型计算机在进行算术表达式运算的时候是基于后缀表达式实现的，在计算过程中操作数是隐含在栈中的而不是在指令中。

- 一地址指令(OP$+A_1$)

  需要指明操作码和一个操作对象。通常两种情况会用到一地址指令：

  1. 只需要单操作数，如加$1$、减$1$、取反、求补等
     指令含义：CPU首先会从$A_1$所指向的主存单元当中取出相应的数据，然后对这个数据进行对应的$OP$操作。得到运算结果后再把运算结果放回$A_1$所指向的主存单元。即$OP(A1)\rightarrow A_1$

     所以完成这条指令需要$3$次访存：取指令$\rightarrow$读$A_1\rightarrow$写$A_1$

  2. 需要两个操作数，但其中一个操作数隐含在某个寄存器(如隐含在ACC中)。
     指令含义：将ACC累加寄存器中存放的数据，还有$A_1$所指明地址当中存放的数据进行相应的$OP$操作运算。然后把运算的结果再存放入ACC累加寄存器中。即$(ACC)OP(A_1)\rightarrow ACC$

     所以完成这一条指令需要$2$次访存：取指令$\rightarrow$读$A_1$

  注意：上面$A_1$指某个主存地址，$(A_1)$表示$A_1$所指向的地址中的内容。这里的$A_1$可以类比C语言的指针，$(A_1)$相当于指针所指位置的内容。

- 二地址指令(OP$+A_1$(目的操作数)$+A_2$(源操作数))

  常用于需要两个操作数的算术运算、逻辑运算相关指令。

  指令含义：$A_1$和$A_2$这两个地址码会分别指明要运算的操作数。这两个数进行$OP$操作后，运算的记过会存回$A_1$。即$(A_1)op(A_2)\rightarrow A_1$。

  完成这一次指令需要$4$次访存：取出指令$\rightarrow$读取$A_1\rightarrow$读取$A_2\rightarrow$写$A_1$。

- 三地址指令

  常用于需要两个操作数的算术运算、逻辑运算相关指令。

  指令含义：$A_1$和$A_2$这两个地址码会分别指明要运算的操作数。这两个数进行$OP$操作后，运算的记过会存回$A_3$。即$(A_1)op(A_2)\rightarrow A_3$。

  完成这一次指令需要$4$次访存：取出指令$\rightarrow$读取$A_1\rightarrow$读取$A_2\rightarrow$写$A_3$。

- 四地址指令

  指令含义：$(A_1)op(A_2)\rightarrow A_3$，$A_4=$下一条将要执行指令的地址。

  完成这一次指令需要$4$次访存：取出指令$\rightarrow$读取$A_1\rightarrow$读取$A_2\rightarrow$写$A_3$。

  正常情况下在取指令之后指针$PC+1$，即指向下一条指令，但使用四地址指令后，$PC$的值修改为$A_4$所指的地址。

对于$n$位地址码的直接寻址范围$=2^n$，若指令总长度固定不变，则地址码数量越多，寻址能力越差。

还可以对指令进行其他分类，先来看以下概念：

> 指令字长：一条指令的总长度(可能会变)
>
> 机器字长：与CPU有关，CPU进行一次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)
>
> 存储字长：与主存有关，一个存储单元中的二进制代码位数(通常和MDR位数相同)
>
> 可能会见到半字长指令、单字长指令、双字长指令这些术语。这指的是指令长度是机器字长的多少倍。通常情况下指令字长会影响取指令所需时间。如：机器字长$=$存储字长$=16bit$，则取一条双字长指令($32bit$)需要两次访存。

所以可以对指令按照长度进行分类：

- 有的系统中所有指令的长度都相等，这称作定长指令字结构。

  对于一个定长操作系统，如果操作码是$n$位，意味着这个系统最多支持$2^n$这么多条指令。这种控制系统的译码电路设计简单，但灵活性较低。

- 而有的系统中各种指令的长度不等，这称作变长指令字结构。

  控制器译码电路设计复杂，但灵活性高。

按照操作类型分类：

- 数据传送

  LOAD作用：把存储器中的数据放到寄存器中

  STORE作用：把寄存器中的数据放到存储器中

- 算术逻辑操作

  算术：加减乘除、增$1$、减$1$、求补、浮点运算、十进制运算

  逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

- 移位操作

  算术移位、逻辑移位、循环移位(带进位和不带进位)

- 转移操作

  无条件转义(JMP)

  有条件转义：JZ(结果为$0$)、JO(结果溢出)、JC(结果有进位)

  调用和返回：CALL和RETURN

  陷阱(Trap)与陷阱指令

- 输入输出操作

  CPU寄存器和IO端口之间的数据传送(端口即IO接口中的寄存器)

## 2. 扩展操作码

定长指令字结构$+$可变长操作码$=$扩展操作码指令格式。采用这种操作码意味着对于不同地址数的指令使用不同长度的操作码。

举例：如果指令字长为$16$位，每个地址码占$4$位，对于三地址指令：指令字长的前$4$位为操作码字段$OP$，另外$12$位是三个$4$位长的地址字段$A_1,A_2,A_3$。

<img src="https://image.sybblogs.fun/img-common/202401191756731.png" alt="三地址指令" style="zoom:50%;" />

前$4$位基本操作码用于三地址指令，则可以有$2^4=16$条。但至少要将$1111$留作扩展操作码使用，即三地址指令最多有$15$条。

<img src="https://image.sybblogs.fun/img-common/202401191759416.png" alt="扩展操作码" style="zoom:50%;" />

这么做，CPU可以在取得一条$16$位指令时，如果满足开头$4$位全$1$，并且$5\sim8$位不是全$1$，就可以确定这是一条二地址指令。

同样，如果满足开头$4$位全$1$，并且$5\sim8$位也是全$1$，就可以确定这是一条一地址指令。

接着，如果前$12$位都是$1$，就可以确定这是一条零地址指令。

<img src="https://image.sybblogs.fun/img-common/202401191804127.png" alt="扩展操作码方法" style="zoom: 50%;" />

在设计扩展操作码指令格式时，必须注意以下两点：

1. 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
2. 各指令的操作码一定不能重复。

通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码。尽可能减少指令译码和分析的时间。如：对于二地址指令操作码是$8$位，三地址指令操作码是$4$位，二地址操作码前四位全$1$，所以三地址指令操作码不能出现全$1$。

例题：设指令字长固定为$16$位，试设计一套指令系统满足：

| 要求                 | 格式                          | 起始指令位$1$  | 指令位$2/$地址位 | 指令位$3/$地址位 | 指令位$4/$地址位 |
| -------------------- | ----------------------------- | -------------- | ---------------- | ---------------- | ---------------- |
| a.有$15$条三地址指令 |                               | $0000\sim1110$ | $A_1$            | $A_2$            | $A_3$            |
| b.有$12$条二地址指令 | $1111\cdots$                  | $1111$         | $0000\sim1011$   | $A_1$            | $A_2$            |
| c.有$62$条一地址指令 | $1111\quad11\cdots$           | $1111$         | $00\sim11$       | $0000\sim1101$   | $A_1$            |
| d.有$32$条零地址指令 | $1111\quad1111\quad111\cdots$ | $1111$         | $1111$           | $1110\sim1111$   | $0000\sim1111$   |

> 对于有$15$条三地址指令：其只要满足前四位不大于$1110$即可。
>
> 有$12$条二地址指令：前四位固定，并且要留八位给两个地址，所以只有$4$位可以当作指令，$0000\sim1011$可以代表$12$个不同二进制数即指令。
>
> 有$62$条一地址指令：前六位要区分指令位，所以全$1$，另外还要留$4$位做地址位，只剩$6$位可以用于做分配的指令位。$000000\sim111101$就可以表示$62$不同二进制位，即指令。
>
> 有$32$条零地址指令：前$11$位区分指令位，所以全$1$，没有地址位，所以剩下的$5$位可以用来表示指令位。$00000\sim11111$可以表示正好可以表示$32$中状态，即指令。

这样设计好后，CPU可以根据开头几位确定是哪种地址指令。如：前$11$位全$1$，就表示这是一条零地址指令。

上面设计方法可以得出一个结论：设地址长度为$n$，上一层留出$m$种状态，下一层可扩展出$m\times2^n$种状态。上面设计中地址长度是$4$位，对于第一层三地址指令设计，共有$2^4=16$种状态，留出一种状态让下一层使用。第二层设计二地址指令，由于上一层留出一种状态，所以这一层状态共有$1\times2^4=16$种，这里只用$12$种状态，留出四种状态给下一层。第三层一地址指令设计共有$4\times2^4=64$种状态，这里只用$62$种状态，留出两种状态给下一层。第四层设计零地址指令共有$2\times2^4=32$种。

<img src="https://image.sybblogs.fun/img-common/202401191909114.png" alt="扩展码设计" style="zoom:50%;" />

## 3. 指令寻址

指令寻址：下一条欲执行指令的指令地址。这个地址始终由程序计数器PC给出。并且有顺序寻址和跳跃寻址两种方式。

### 3.1 顺序寻址

CPU可以通过顺序寻址和跳跃寻址方式，确定下一条指令的存放地址。

程序计数器$PC$可以给出下一条欲被执行的指令地址。

<img src="https://image.sybblogs.fun/img-common/202401191920685.png" alt="顺序寻址" style="zoom:50%;" />

上图给出一个系统，该系统采用定长指令字结构，指令字长$=$存储字长$16Bit=2B$。且主存按字编址。此时$PC$初始值指向$0$，当指令$0$地址内操作执行完成后，$PC+1$。继续执行后面，依次按顺序执行。

<img src="https://image.sybblogs.fun/img-common/202401191930485.png" alt="PC+1" style="zoom: 50%;" />

但有的系统会采用按字节编址方式，即每条指令会占两个地址。此时$PC+2$。

当然有的系统也会采用变长的指令字结构：

<img src="https://image.sybblogs.fun/img-common/202401191931002.png" alt="变长指令字结构寻址" style="zoom:50%;" />

如上图，颜色相同的是一个指令。PC会先指向第一个指令地址$0$，由于CPU无法确定当前这条指令占多少个存储字，CPU会先读入第一个操作字内容，由于操作码包含在第一个字中，所以CPU可以根据操作码来判断出这条地址到底是几地址的指令。这样就可以确定这条指令占多少个字节。上面第一个行指令占$4$个字节，即两行，运行完之后PC会$+n$，即$PC+4$，指向$4$指令地址。

<img src="https://image.sybblogs.fun/img-common/202401191936176.png" alt="变长指令字结构寻址1" style="zoom:50%;" />

以上都是按照顺序寻址方式，这种方式$PC+n$就可以确定下条指令位置。这里$n$受定长$/$变长指令字结构、按字$/$字节编址等的影响。

### 3.2 跳跃寻址

给出一个系统，该系统采用定长指令字结构，指令字长$=$存储字长$16Bit=2B$。且主存按字编址。

<img src="https://image.sybblogs.fun/img-common/202401191920685.png" alt="顺序寻址" style="zoom:50%;" />

PC初始值指向$0$指令地址，每完成一个指令都会使$PC+1$。直到$PC$指向指令地址$3$，此时当执行这条指令时，同样$PC+1$会先执行。之后CPU知道$JMP$是一条无条件转移语句类似与C语言的goto语句。所以会把$PC$中的内容改为$7$，即指向$7$指令地址。

<img src="https://image.sybblogs.fun/img-common/202401191942353.png" alt="跳跃寻址" style="zoom:50%;" />

这种通过转移类指令，改变PC的值，即改变程序执行流的方式称为跳跃寻址。

## 4. 数据寻址

数据寻址：确认本条指令码的地址码指明的真实地址。

指令是操作码$+$地址码。数据寻址就是地址码的解析。这个解析方式有十种：隐含寻址、立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、相对寻址、基址寻址、变址寻址、堆栈寻址。由于有十种寻址所以只需要$4$位二进制标识即可。

增加$4$个比特位后新的指令由操作码$+$寻址特征$+$形式地址构成。

<img src="https://image.sybblogs.fun/img-common/202401201307474.png" alt="新的指令码" style="zoom:50%;" />

根据中间寻址特性来确认这个形式地址应该用十种方法哪一种来解析它，得到真正的真实地址，这个真实地址叫有效地址(EA)。

上面是对于一地址指令，二地址指令如下：

<img src="https://image.sybblogs.fun/img-common/202401201311567.png" alt="新的二地址指令" style="zoom:50%;" />

在接下来的介绍中，为了方便，假设指令字长$=$机器字长$=$存储字长。并且假设最终想要得到的操作数为$3$。

### 4.1 直接寻址

直接寻址：指令字中的形式地址$A$就是操作数的真实地址$EA$，即$EA=A$。

<img src="https://image.sybblogs.fun/img-common/202401201315935.png" alt="直接寻址" style="zoom:50%;" />

CPU根据指令的寻址特征知道这是直接寻址，会根据形式地址$A$直接找到对应主存位置中的数据。

这种寻址访存次数：取指令访存$1$次，执行指令访存$1$次，暂不考虑存结果共访存$2$次。

直接寻址优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。

直接寻址缺点：$A$的位数决定了该指令操作数的寻址范围。当操作数的地址发生改变时，不易修改。

### 4.2 间接寻址方式

间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即$EA=(A)$。

<img src="https://image.sybblogs.fun/img-common/202401201322362.png" alt="间接寻址" style="zoom:50%;" />

CPU根据寻址特征知道这是间接寻址，根据形式地址$A$，找到主存对应的位置$A$，而$A$中保存的就是数据所在主存中的有效地址$EA$。即形式地址$A$，指向主存中的某一位置，这个位置中的地址指向就是$EA$。

寻址访存次数：取指令访存$1$次，执行指令访存$2$次，暂不考虑存结果共访存$3$次。

同时还有两次间接寻址：

<img src="https://image.sybblogs.fun/img-common/202401201328899.png" alt="两次间接寻址" style="zoom:50%;" />

根据形式地址$A$找到主存中地址$A_1$，$A_1$前面$1$标明这个地址不是有效地址$EA$，其指向的地址是$EA$，$EA$前面的$0$表示这个地址指向的位置就是真是数据的位置。

间接寻址优势：可扩大寻址范围(有效地址$EA$的位数大于形式地址$A$的位数，所以寻址范围由主存中的有效地址$EA$决定)。并且便于编制程序(用间接寻址可以方便地完成子程序返回)。

缺点：指令在执行阶段要多次访存(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)，导致寻址效率变低。

### 4.3 寄存器寻址

寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即$EA=R_i$，其操作数在由$R_i$所指的寄存器内。

<img src="https://image.sybblogs.fun/img-common/202401201357628.png" alt="寄存器寻址" style="zoom: 50%;" />

CPU根据寻址特征知道这是寄存器寻址，所以形式地址不是指向主存中的位置，而是寄存器中的位置。CPU内部会有很多通用寄存器，根据形式地址$R_i$可以找到寄存器编号。

寻址访存次数：取指令访存$1$次，执行指令访存$0$次，暂不考虑存结果共访存$1$次。

寄存器寻址优点：指令在执行阶段不访问主存，只访问寄存器，由于CPU中寄存器不会太多，所以指令字短且执行速度快，支持向量$/$矩阵运算。

寄存器寻址缺点：寄存器价格昂贵，计算机中寄存器个数有限。

### 4.4 寄存器间接寻址

寄存器间接寻址：寄存器$R$中给出的不是一个操作数，而是操作数所在主存单元的地址，即$EA=(R_i)$。

<img src="https://image.sybblogs.fun/img-common/202401201404322.png" alt="寄存器间接寻址" style="zoom:50%;" />

CPU根据寻址特征知道这是寄存器间接寻址，根据形式地址指明的寄存器编号，而这个寄存器编号中的内容才是有效地址$EA$，其指向主存中的某一位置。

寻址访存次数：取指令访存$1$次，执行指令访存$1$次，暂不考虑存结果共访存$2$次。

寄存器间接寻址特点：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)。

### 4.5 隐含寻址

隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。

<img src="https://image.sybblogs.fun/img-common/202401201413877.png" alt="隐含寻址" style="zoom:50%;" />

有的地址显示给出的地址只是指明，其中一个操作数的位置，而另一个操作数会默认在ACC累加寄存器中，但是这个操作数并没有在指令中显示的给出，所以这是隐含寻址。

优点：有利于缩短指令字长。

缺点：需增加存储操作数或隐含地址的硬件。

### 4.6 立即寻址

立即寻址：形式地址$A$就是操作数本身，又称为立即数，一般采用补码形 式。寻址特征位$\#$表示立即寻址特征。

寻址访存次数：取指令访存$1$次，执行指令访存$0$次，暂不考虑存结果共访存$1$次。

立即寻址优点：指令执行阶段不访问主存，指令执行时间最短。

立即寻址缺点：$A$的位数限制了立即数的范围。如$A$的位数为$n$，且立即数采用补码时，可表示的数据范围为$-2^{n-1}\sim2^{n-1}-1$。

六种寻址方式总结：

<img src="https://image.sybblogs.fun/img-common/202401201424675.png" alt="六种寻址方式总结" style="zoom:50%;" />

### 4.7 偏移寻址

以某个地址作为起点，形式地址视为偏移量。偏移寻址有三种：相对寻址、基址寻址和变址寻址。

<img src="https://image.sybblogs.fun/img-common/202401201427180.png" alt="偏移寻址" style="zoom:33%;" />

上图最左边$JMP$会让程序跳转到第$7$行。中间的$JMP$指令会让程序以当前程序的起始位置$100$，往后偏移$7$位，即$107$。最右边$JMP$指令，会以当前程序执行行的位置为起始位置$103$，往后偏移$3$位到$107$。

这三种偏移方式区别在于偏移的起点不一样。

1. 基址寻址：以程序的起始存放地址作为"起点"。

2. 变址寻址：程序员自己决定从哪里作为"起点"。

3. 相对寻址：以程序计数器PC所指地址作为"起点"。

#### 基址寻址

基址寻址：将CPU中基址寄存器(BR)的内容加上指令格式中的形式地址$A$，而形成操作数的有效地址，即$EA=(BR)+A$。

有的计算机会带有基址寄存器：

<img src="https://image.sybblogs.fun/img-common/202401201437093.png" alt="基址寻址" style="zoom:50%;" />

采用这种基址寄存器，则指令中还有形式地址$A$，基址寄存器BR会指向当前程序的起始位置。最终的有效位置，只需要用基址寄存器中存放的地址加上形式地址$A$(偏移量)就可以得到最终的有效地址$EA$。即将$A$和$BR$中存放的地址送往算术逻辑单元$ALU$进行一个加法运算就可以得到$EA$

注：可对比操作系统OS课中的"重定位寄存器"就是"基址寄存器"。

而有的计算机内部不会有专门的基地址寄存器，而是使用某个通用寄存器。

<img src="https://image.sybblogs.fun/img-common/202401201444999.png" alt="基址寻址(无基址寄存器)" style="zoom:50%;" />

CPU根据寻址特征知道这是基址寻址，另外还需要花几个比特位指明基地址存放在通用寄存器哪个位置。上图指明存放在通用寄存器$R_0$位置。之后和之前一样，取出通用寄存器$R_0$地址和$A$地址送到$ALU$算术逻辑单元种进行相加得到$EA$。

其中$R_0$要根据通用寄存器个数判断占多少位。如果通用寄存器有$8$个存储空间，那么$R_0$就需要$3$位，即可。因为$2^3=8$能表示所有情况。

优点：可扩大寻址范围(基址寄存器的位数大于形式地址A的位数)；用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序便于程序"浮动"，可以从内存当中任何一个地址作为程序起始地址，方便实现多道程序并发运行。

注：基址寄存器是**面向操作系统**的，其内容由**操作系统或管理程序**确定。在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)。当采用通用寄存器作为基址寄存器时，可由用户使用汇编语言决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。

#### 变址寻址

变址寻址：有效地址$EA$等于指令字中的形式地址$A$与变址寄存器$IX$的内容相加之和，即$EA= (IX)+A$，其中$IX$可为变址寄存器(专用)，也可用通用寄存器作为变址寄存器

如果计算机中有变址寄存器$IX$：

<img src="https://image.sybblogs.fun/img-common/202401201503453.png" alt="变址寄存器IX" style="zoom:50%;" />

采用这种基址寄存器，则指令中还有形式地址$A$，变址寄存器$IX$会指向当前程序的起始位置。最终的有效位置，只需要用变址寄存器中存放的地址加上形式地址$A$(偏移量)就可以得到最终的有效地址$EA$。即将$A$和$IX$中存放的地址送往算术逻辑单元$ALU$进行一个加法运算就可以得到$EA$

可以发现变址寻址和基址寻址方式一样。他们的区别在于，变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变。另外$IX$作为偏移量，形式地址$A$不变作为基地址，和基址寻址相反。

变址寻址原理：先给出一段程序

~~~c
for(int i=0; i<10; i++){
    sum+=a[i];
}
~~~

该程序存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202401201516199.png" alt="变址寻址原理" style="zoom:50%;" />

- 首先第一条指令，取数指令，地址码前面$\#$代表这是一个立即数，可以直接运算，将这个立即数$0$放入ACC中
- 第二行指令，取数指令，通用将$0$放入$IX$中。
- 第三行指令，加法指令，这个指令采用了变址寻址。也就意味着$EA=(IX)+A$，这里的$A=7$，所以执行$(ACC)+(7+IX)\rightarrow ACC$，就是将$IX=0$加上形式地址$A=7$的结果就是有效地址，这里指向$7$，即$a[0]$。ACC中当前存放的是$0$，所以$a[0]+ACC$运算结果放入ACC中即可。对应代码`sum+=a[i]`。
- 第四行，加法操作，让变址寄存器$IX+1=1$，再放入$IX$中。对应代码`i++`。
- 第五行，比较操作，$10-(IX)$。
- 第六行，跳转操作，如果$10-(IX)>0$，则将程序跳转$2$主存地址，再次循环。对于代码`i<10`
- 跳转回第二行，$A=7,ACC=1$，则$7+(ACC)=8$，在与$ACC$中的值相加。
- 重复书上操作，一直到$10-(IX)<0$，即$IX>10$。此时循环结束。执行第六行，第六行存数操作，将$ACC$中的数放入$sum$变量中。

从上面可以体会到，$A$作为基址，而$IX$作为偏移量即代码中对应的`i`。不断改变变址寄存器$IX$的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。

变址寻址优点：在数组处理过程中，可设定$A$为数组的首地址，不断改变变址寄存器$IX$的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。

复合寻址：

可以采用基址$+$变址复合方式寻址。

如果一个程序在主存中随机存放，就需要一个基地址指向程序的起始位置。此时$EA=(IX)+((BR)+A)$。

注：实际应用中往往需要多种寻址方式复合使用(可理解为复合函数)

#### 相对寻址

相对寻址：把程序计数器$PC$的内容加上指令格式中的形式地址$A$而形成操作数的有效地址，即$EA=(PC)+A$，其中$A$是相对于$PC$所指地址的位移量，可正可负，补码表示。

<img src="https://image.sybblogs.fun/img-common/202401201551431.png" alt="相对寻址" style="zoom:50%;" />

先从主存地址$1000$地方取出指令，当取出指令后CPU会让$PC+1$，若当前指令字长为$2B$，则$PC+2$。因此取出当前指令后$PC$的值为$1002$。那么此时CPU根据寻址特征知道这是相对寻址，所以$EA$的值就是当前$PC$的值再加上形式地址$A$的值。如果$A$值是负，则从当前PC所指行往前偏移，如果是正，则往后偏移。

相对寻址原理：

<img src="https://image.sybblogs.fun/img-common/202401201602778.png" alt="相对寻址原理" style="zoom:50%;" />

当执行到$M+3$主存行地址指令时，如果还按照之前的方式跳转，会跳转到$2$主存行地址，这一行是其他代码显然错误。为了解决这个问题采用相对寻址方式，当执行$M+3$主存行指令时，$PC+1$指向$M+4$，这里修改地址码值为`-4(补码表示)`，此时$PC=M+4-4=M$，所以以后不管这段代码在哪个位置，采用相对寻址方式都会指向$M$主存行位置。

<img src="https://image.sybblogs.fun/img-common/202401201608982.png" alt="相对寻址原理1" style="zoom: 50%;" />

同时还能发现一个问题，当程序代码移动时，数组$a[0]$可能不再存放在$7$主存行位置，所以要修改$M$行地址码值，使其与$a[0]$所在主存位置对应，显然每次都要修改很麻烦。所以现实中都是采用分段方式解决：即程序段(只存放指令代码)和数据段(只存放数据)分开存放。

采用相对寻址优点：操作数的地址不是固定的，它随着$PC$值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动(一段代码在程序内部的浮动)。相对寻址广泛应用于转移指令。

注意：基址寻址中的浮动指的是整段程序在内存中的浮动。而相对寻址的浮动指的是一段代码在程序内部的浮动。

三种寻址方式总结：

<img src="https://image.sybblogs.fun/img-common/202401201614332.png" alt="三种寻址方式总结" style="zoom:50%;" />

注意：取出当前指令后，PC会指向下一条指令，相对寻址是**相对于下一条指令**的偏移

### 4.8 堆栈寻址

堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。这个堆栈指针存放在寄存器$SP$当中。

堆栈是存储器(或专用寄存器组)中一块特定的按后进先出(LIFO)原则管理的存储区，该存储区中被读$/$写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。

这个堆栈可以用两种方式实现：一种是采用专门寄存器存放专门元素。另一种方式是在主存中划出一片区域用作堆栈。

用寄存器实现堆栈原理：

<img src="https://image.sybblogs.fun/img-common/202401201646973.png" alt="堆栈寻址" style="zoom:50%;" />

这里用四个寄存器实现堆栈，系统中会用专门的寄存器$SP$来指向当前栈顶元素的位置。当前$SP\rightarrow R_0$。由于这里只有四个寄存器，所以$SP$只需要用两位就可以表示所有的值。

假设现在要用堆栈里的两个栈顶元素来完成一次加法操作。加数和被加数会先放到$ACC$和$X$中。通过$ALU$计算出结果。具体操作是，用汇编指令$POP$弹出栈顶元素，并将其放入$ACC$累加寄存器中。弹出后将$SP+1$指向弹出后栈顶的元素即$R_1$。同样用$POP$指令弹出栈顶元素放入$X$中。接着$SP+1$指向$R_2$。现在加数和被加数已经有了，之后用汇编语句$ADD$将两个数相加的结果放入$Y$中。最后通过汇编指令$PUSH$将结果$Y$压入栈顶，这个压栈具体做法是，将$SP-1$指向$R_1$。然后再将$Y$的值放入$SP$所指向的$R_1$寄存器中。

汇编指令如下：

<img src="https://image.sybblogs.fun/img-common/202401201656977.png" alt="堆栈寻址汇编语句" style="zoom:50%;" />

上面情况是栈顶在小地址方向，还有的情况是栈顶在大地址方向。栈顶大地址方向的汇编指令：

<img src="https://image.sybblogs.fun/img-common/202401201657762.png" alt="堆栈寻址汇编语句2" style="zoom:50%;" />

上面通过几个寄存器实现的堆栈称为硬堆栈。还有一种方式是软堆栈，即从主存中划出一片区域当堆栈。这种方式通过POP和PUSH对栈进行操作都会进行一次访存，而硬堆栈由于存放在寄存器中所以不用进行访存。

<img src="https://image.sybblogs.fun/img-common/202401201700632.png" alt="软堆栈" style="zoom:50%;" />

显然采用寄存器实现的硬堆栈速度更快，但成本高；而软堆栈访问速度慢，但成本更低。在实际的系统中通常采用软堆栈实现。堆栈可用于函数调用时保存当前函数的相关信息。

十种寻址方式总结：

<img src="https://image.sybblogs.fun/img-common/202401201703189.png" alt="十种寻址方式总结" style="zoom: 33%;" />

## 5. 高级语言与机器级代码之间的对应
机器语言与汇编语言都是机器级代码。考试只考x86汇编语言，如果考察其他汇编语言题中会给出详细注释。

### 5.1 x86汇编语言指令基础

指令作用：要么处理数据，要么改变程序执行流。指令的格式：操作码$+$地址码，操作码指出数据怎么处理，地址码指明了数据存放在哪。而数据可以存放在寄存器中，主存里，指令里。如果是在寄存器中，指令给出寄存器名即可。如果是在主存中，指令给出主存地址即可，同时要指明读写长度。如果在指令中就是立即寻址。

以$mov$指令为例：

|             语法格式             |                    功能                    |
| :------------------------------: | :----------------------------------------: |
| $mov$ 目的操作数$d$，源操作数$s$ | 将源操作数$s$复制到目的操作数$d$所指的位置 |

~~~shell
mov eax,ebx				 	#将寄存器ebx的值复制到寄存器eax
mov eax,5				 	#将立即数5复制到寄存器eax
mov eax,dword ptr[af996h]	#将内存地址af996h所指的32bit值复制到寄存器eax
mov byte ptr[af996h],5		#将立即数5复制到内存地址af996h所指的--字节中
~~~

> 上面中括号表示主存地址。

如何指明内存的读写长度：dword ptr：双字(32bit)；word ptr：单字(16bit)；byte ptr：字节(8bit)

x86架构的CPU，寄存器如下：寄存器$E=Extended=32bit$，所以寄存器都是以$e$开头。

<img src="https://image.sybblogs.fun/img-common/202401201817218.png" alt="x86架构寄存器" style="zoom: 33%;" />

前四个为一组用于存什么数据未知，所以称为通用寄存器。

中间两组$ESI,EDI$是变址寄存器。变址寄存器可用于线性表、字符串的处理。

最后两个寄存器$EBP,ESP$分别指明堆栈的基指针和顶指针。主要用于实现函数的调用。

前四个寄存器使用较为灵活，可以去掉前面的$E$，使用低地址的$16bit$。即$ax$代表使用$EAX$寄存器的低地址$16bit$。

<img src="https://image.sybblogs.fun/img-common/202401201825200.png" alt="寄存器低地址使用" style="zoom:50%;" />

并且可以指定使用$8bit$，如：$ah$表示$EAX$寄存器中的$8bit$。

<img src="https://image.sybblogs.fun/img-common/202401201827911.png" alt="寄存器低地址使用2" style="zoom:50%;" />

当然最常用的还是直接使用$32bit$。

在看几个常见操作：

~~~shell
mov eax,dword ptr [ebx]			#将ebx所指主存地址的32bit复制到eax寄存器中
mov dword ptr [ebx],eax			#将eax的内容复制到ebx所指主存地址的32bit
mov eax, byte ptr [ebx]			#将ebx所指的主存地址的8bit复制到eax
mov eax,[ebx]					#若未指明主存读写长度，默认32 bit
mov [af996h],eax				#将eax的内容复制到af996h所指的地址(未指明长度默认32bit)
mov eax,dword ptr [ebx+8]		#将ebx+8所指主存地址的32bit复制到eax寄存器中
mov eax, dword ptr [af996-12h]	#将af996-12所指主存地址的32bit复制到eax寄存器中
~~~

### 5.2 常用的汇编指令

x86常见的算术运算指令：

|  功能  |      汇编指令       |                             解释                             |
| :----: | :-----------------: | :----------------------------------------------------------: |
|   加   |       add d,s       |                    计算$d+s$，结果存入$d$                    |
|   减   |       sub d,s       |                    计算$d-s$，结果存入$d$                    |
|   乘   | mul d,s<br>imul d,s |  无符号数$d*s$，乘积存入$d$<br/>有符号数$d*s$，乘积存入$d$   |
|   除   |   div s<br>idiv s   | 无符号数除法edx:eax/s， 商存入eax， 余数存入edx<br/>有符号数除法edx:eax/s， 商存入eax， 余数存入edx |
| 取负数 |        neg d        |                   将$d$取负数，结果存入$d$                   |
|  自增  |        inc d        |                    将$d++$， 结果存入$d$                     |
|  自减  |        dec d        |                     将$d--$，结果存入$d$                     |

上面指令后的操作数可能来自寄存器、主存和指令这三个地方。而为了提高运行效率减少主存访问，在x86汇编指令中**两个操作数不能同时来自主存**。由于最终处理的结果要放回到$d$中，所以$d$**不可能是常量**，只可能是寄存器或者主存地址。

注意除法指令，$div\quad s$这里的$s$是除数，而被除数会被提前放在$edx$和$eax$寄存器中。而$edx:eax$指的是在进行除法运算之前，需要对被除数进行位扩展，如：$\frac{32bit}{32bit}$，此时被除数需要扩展到$64bit$，即$\frac{64bit}{32bit}$。而一个寄存器只有$32bit$，所以需要两个寄存器存放，$edx$存放高$32$位，$eax$存放低$32$位。

通常会用`<reg>`代表寄存器、`<mem>`代表内存、`<con>`代表常数。

x86常见的逻辑指令

| 功能 | 汇编指令 |                      解释                       |
| :--: | :------: | :---------------------------------------------: |
|  与  | and d,s  |         将$d$、$s$逐位相与，结果放回$d$         |
|  或  |  or d,s  |         将$d$、$s$逐位相或，结果放回$d$         |
|  非  |  not d   |           将$d$逐位取反，结果放回$d$            |
| 异或 | xor d,s  |         将$d$、$s$逐位异或，结果放回$d$         |
| 左移 | shl d,s  | 将$d$逻辑左移$s$位，结果放回$d$(通常$s$是常量)  |
| 右移 | shr d,s  | 将$d$逻辑右移$s$位，结果放回$d$ (通常$s$是常量) |

其他指令：

用于实现分支结构、循环结构的指令：cmp、test、jmp、jxxx

用于实现函数调用的指令：push、pop、call、ret

用于实现数据转移的指令：mov

### 5.3 AT&T格式的汇编指令

AT&T格式常用于Unix和Linux。intel格式常用于Windows。

AT&T常用格式：

|            功能            |                           汇编指令                           |                         解释                         |                        对应intel格式                         |
| :------------------------: | :----------------------------------------------------------: | :--------------------------------------------------: | :----------------------------------------------------------: |
| 目的操作数$d$、源操作数$s$ |                            op s,d                            |             源操作数在做，目的操作数在右             |                            op d,s                            |
|         寄存器表示         |                        mov %ebx,%eax                         |                寄存器名前必须加"$\%$"                |                         mov eax,ebx                          |
|        立即数的表示        |                        mov $985,%eax                         |                立即数之前必须加"$\$$"                |                         mov eax,985                          |
|       主存地址的表示       |                      mov %eax,(af996h)                       |                 主存地址用小括号表示                 |                       mov [af996h],eax                       |
|       读写长度的表示       | movb $\$$5,(af996h)<br>movw $\$$5,(af996h)<br/>movl $\$$5,(af996h)<br/>addl $\$$5,(af996h)<br/> | 指令后加$b,w,l$分别表示读写<br>长度byte、word、dword | mov byte ptr [af996h],5<br>mov word ptr [af996h],5<br>mov dword ptr [af996h],5<br>add byte ptr [af996h],4 |
|    主存地址偏移量的表示    |       movl -8(%ebx),%eax<br>movl 4(%ebx,%ecx,32),%eax        |                     偏移量(基址)                     |          mov eax,[ebx-8]<br>mov eax,[ebx+ecx*32+4]           |

对于最后`mov eax,[ebx+ecx*32+4]`，做一下详细解释：

<img src="https://image.sybblogs.fun/img-common/202401211508116.png" alt="偏移量复杂例子" style="zoom:50%;" />

对于上图，这是一个结构体数组。要访问数据元素$3$中的变量$1$，需要知道这个结构体数组基址，然后$基址+变址*比例因子$。这里的变址是要访问的索引号，比例因子就是每个数组大小，这里是$32bit$，最后再加上变量$0$的$4B$就是变量$1$的位置。即$ebx+3*32+4$

### 5.4 汇编选择语句

前面已经介绍基本汇编语句，这里会介绍选择语句的汇编方式。

指令存储在主存中，每次取出一条指令$PC$会自动$+1$，指向下一条指令。但是选择语句可能会改变程序的执行流。注意在x86处理器中程序计数器$PC$通常称为$IP$。

改变程序执行流需要用到无条件转义指令：JMP

| 指令名 |    语法    |         功能         |
| :----: | :--------: | :------------------: |
|  jmp   | jmp <地址> | PC无条件转移至地址处 |

这里的`<地址>`可以是常数、寄存器、主存。但最常用还是"标号"锚定：

~~~shell
mov eax,7
mov ebx,6
jmp NEXT
mov ecx, ebx
NEXT :			#用"标号”锚定位置
mov ecx, eax
~~~

当执行到`jmp NEXT`时，程序计数器$PC$会跳转到最后一行，即`NEXT`标记的位置。这里的标号不一定是`NEXT`，可以自定义名字。

JMP指令类似于C语言的goto语句，虽然能实现跳转，但无法实现`if...else..`语句。要实现选择语句需要用到条件转移指令`jxxx`。

常用的`jxxx`语句及功能：

| 语句 |    语法    |      功能      |
| :--: | :--------: | :------------: |
|  je  | je <地址>  | 若`a==b`则跳转 |
| jne  | jne <地址> | 若`a!=b`则跳转 |
|  jg  | jg <地址>  | 若`a>b`则跳转  |
| jge  | jge <地址> | 若`a>=b`则跳转 |
|  jl  | jl <地址>  | 若`a<b`则跳转  |
| jle  | jle <地址> | 若`a<=b`则跳转 |

上面指令通常要搭配CMP指令，CMP指令用于比较两个数。

|  语法   |                        功能                         |
| :-----: | :-------------------------------------------------: |
| cmp a,b | 比较$a$和$b$的值，$a,b$可能是常量、主存地址或寄存器 |

例1：

~~~shell
cmp eax,ebx		#比较寄存器eax和ebx里的值
jg NEXT			#若eax > ebx,则跳转到NEXT:
~~~

例2：将下面C语言转换为汇编语言

~~~c
if(a>b){
    c=a;
}else{
    c=b;
}
~~~

汇编语言：

~~~shell
mov eax,7		#假设变量a=7,存入eax 
mov ebx,6		#假设变量b=6,存入ebx
cmp eax,ebx		#比较变量a和b
jg NEXT		#若a>b,转移到NEXT:
mov ecx,ebx		#假设用ecx存储变量c,令c=b
jmp END			#无条件转移到END :
NEXT:
mov ecx,eax		#假设用ecx存储变量c,令c=a
END:
~~~

扩展：CMP指令的底层原理。

<img src="https://image.sybblogs.fun/img-common/202401211621598.png" alt="运算标志位" style="zoom:50%;" />

之前学习过，每次ALU运算都会产生新的标志位覆盖上次标志位：

- OF (Overflow Flag)溢出标志。溢出时为$1$，否则置$0$。
- SF (Sign Flag) 符号标志。结果为负时置$1$，否则置$0$。
- ZF (Zero Flag)零标志，运算结果为$0$时ZF位置$1$，否则置$0$
- CF (Carry Flag)进位$/$借位标志，进位$/$借位时置$1$，否则置$0$

而跳转指令JMP之前会使用CMP指令，这个指令本质是将做一次$a-b$的运算，这个运算会产生上面几个标志位。这些标志位，会存放到PSW程序状态寄存器中，intel称其为标志寄存器。

<img src="https://image.sybblogs.fun/img-common/202401211624116.png" alt="标志寄存器" style="zoom:50%;" />

`jne`这条指令在`a!=b`时发生跳转，CPU在执行这条指令时，会读取之前CMP产生的标志位$ZF$是否等于$0$，如果等于$0$满足条件进行跳转。其他指令也可以从标志位中得出跳转信息：

~~~shell
je <地址>		#若a==b则跳转,ZF==1?
jne <地址>	#若a!=b则跳转,ZF==0?
jg <地址>		#若a>b则跳转,ZF==0&&SF==OF?
jge <地址>	#若a>=b则跳转,SF==OF?
jl <地址>		#若a<b则跳转,SF!=OF?
jle <地址>	#若a<=b则跳转,SF!=OF||ZF==1?
~~~

### 5.5 循环语句的汇编实现

可以用条件转移指令实现循环。有以下C语言代码：

~~~c
int resul=0;
for(int i=1;i<=100;i++) {
    result +=i;
} //求1+2+3+. . .+100
~~~

转换为汇编语言：

~~~shell
mov eax,0		#用eax保存result,初值为0
mov edx,1		#用edx保存i, 初始值为1
cmp edx,100 	#比较i和100
jg L2			#若i>100，转跳到L2执行
L1:				#循环主体
add eax,edx 	#实现result +=i
inc edx			#inc自增指令,实现i++
cmp edx,100 	#比较i和100
jle L1			#若i<=100,转跳到L1执行
L2:				#跳出循环主体
~~~

所以用条件转移指令实现循环，需要$4$个部分构成：

1. 循环前初始化
2. 是否直接跳出循环
3. 进入循环主体
4. 是否继续循环

除了用条件转移指令实现，还可以用LOOP指令。

|   指令语法    |                     功能                      |
| :-----------: | :-------------------------------------------: |
| loop 循环体名 | 循环计数器$--$，并且若不等于$0$，跳转到循环体 |

实现：有以下一段C语言

~~~c
for(int i=500;i>0;i--){
    //...
}//循环500次
~~~

使用LOOP指令实现循环：

~~~shell
mov ecx,400			#用ecx作为循环计数器
Looptop:			#循环体
#...
#...
loop Looptop		#ecx--,若ecx!=0,则跳转到Looptop循环体
~~~

上面汇编代码可以知道LOOP指令相当于：

~~~shell
dec ecx
cmp ecx,0
jne Looptop
~~~

注意：ecx可以作为循环计数器，其寄存器不能，所以这里必须用ecx寄存器。

理论上能用loop指令实现的功能一定能用条件转移指令实现。而使用loop指令可能会使代码更清晰简洁。

补充：loop指令还有loopx指令。如loopnz,和loopz。其中loopnz是当`ecx!=0&&ZF==0`时，继续循环。而loopz是当`ecx!=0&&ZF==1`时,继续循环。

### 5.6 函数调用汇编实现

高级语言在执行函数如`main()`函数时，会先将其压入函数调用栈，这个压入的函数称为栈帧。如果`main()`函数调用其他函数时，仍会将被调用函数压入函数栈中，称为栈帧。

每个函数的栈帧中包含函数达阔内定义的局部变量和保存函数调用的信息。

<img src="https://image.sybblogs.fun/img-common/202401211708677.png" alt="高级语言函数调用栈帧" style="zoom:50%;" />

其中`caller()`和`add()`函数代码如下：

~~~c
int caller() {
    int temp1=125;
    int temp2=80;
    int sum=add(templ,temp2);
    return sum;
}

int add(int x,int y){
    return x+y;
}
~~~

对应的汇编代码如下：

~~~shell
#caller()
caller:
push ebp
mov ebp,esp
sub esp,24
mov [ebp-12],125
mov [ebp-8],80
mov eax,[ebp-8]
mov [esp+4],eax
mov eax,[ebp-12]
mov esp,eax
call add
mov[ebp-4],eax
mov eax,[ebp-4]
leave
ret
#add()
add:
push ebp
mov ebp,esp
mov eax,[ebp+12]
mov edx,[ebp+8]
add eax,edx
leave
ret
~~~

所以可以知道函数调用指令是：`call 函数名`。函数返回指令是：`ret`。

其调用执行原理本质就是CPU中程序计数器，指向改变过程。当产生函数调用时，就是让$PC$寄存器指向被调用函数的位置。同样`ret`指令也是让$PC$寄存器指向位置发生改变。在x86中通常称$PC$为$IP$。

CALL指令作用：

- 将$IP$指向的旧值压栈保存(保存在函数的栈帧顶部)
- 设置$IP$新值，无条件转移至被调用函数的第一条指令

RET指令作用：从函数的栈帧顶部找到$IP$旧值，将其出栈并恢复$IP$寄存器。

具体执行是：call指令执行时，首先会将$IP$寄存器指向的值压入栈中保存，之后再将$IP$指向被调用起始位置。当被调用函数执行完后，ret指令会从栈顶位置取出刚刚$IP$指向的旧地址，将这个值写回$IP$寄存器。这一就完成函数调用。

#### 栈帧中数据的访问

之前看到的函数调用栈实际在内存中是倒过来存放的。

<img src="https://image.sybblogs.fun/img-common/202401211727518.png" alt="函数调用栈倒置" style="zoom:50%;" />

这是因为在内存中，栈底对应的是内存的高地址，栈顶对应的是低地址。

<img src="https://image.sybblogs.fun/img-common/202401211729728.png" alt="函数调用栈子啊内存中位置" style="zoom: 33%;" />

之前学过x86中的寄存器，其中EBP和ESP寄存器分别用于存储堆栈基指针和堆栈顶指针。并且在一个CPU内部只有一个EBP和ESP。

访问栈帧中的数据需要用到push和pop指令。push、pop指令实现入栈、出栈操作。x86默认以$4$字节为单位。指令格式如下:

| 指令语法 |             功能              |             注意事项              |
| :------: | :---------------------------: | :-------------------------------: |
|  push a  | 先让ESP减$4$，再将$a$压入栈中 | $a$可以是立即数、寄存器或主存地址 |
|  pop b   | 栈顶元素写入$b$，再让ESP加$4$ |     $b$可以是寄存器、主存地址     |

例子：

~~~shell
push eax		#将寄存器eax的值压栈
push 985		#将立即数985压栈
push [ebp+8]	#将主存地址[ebp+8]里的数据压栈
pop eax			#栈顶元素出栈,写入寄存器
pop [ebp+8]		#栈顶元素出栈,写入主存地址[ebp+8]
~~~

假设当前eax寄存器中的值是$211$。内存结构如下(黄色部分是一个函数esp指向栈顶，ebp指向栈底)：

<img src="https://image.sybblogs.fun/img-common/202401211741934.png" alt="push和pop指令原理" style="zoom:50%;" />

`push eax`会先让esp值$-4$，即向下移动四个字节，让后将eax中的值放入esp指向的位置，即栈顶。

<img src="https://image.sybblogs.fun/img-common/202401211744424.png" alt="push和pop指令原理1" style="zoom:50%;" />

`push 985`同样先让esp值$-4$，即向下移动四个字节，让后将立即数$985$值放入esp指向的位置，即栈顶。

<img src="https://image.sybblogs.fun/img-common/202401211745767.png" alt="push和pop指令原理2" style="zoom:50%;" />

`push [ebp+8]`，会先让$ebp+8,esp-4$，然后将此处的值$666$放入栈顶。

<img src="https://image.sybblogs.fun/img-common/202401211827063.png" alt="push和pop指令原理3" style="zoom:50%;" />

`pop eax`会让$esp$所指位置的值放入eax中，再让$esp+4$。

<img src="https://image.sybblogs.fun/img-common/202401211829009.png" alt="push和pop指令原理4" style="zoom:50%;" />

之后的指令执行原理同上。

通过上面例子可以发现push和pop只能对栈顶元素进行操作，这样访问就有限制，还有更灵活的方法mov指令。

可以使用加法指令和减法指令来对esp和edp两个指针进行移动。

例子：

~~~shell
sub esp,12			#栈顶指针-12
mov[ esp+8],eax		#将eax的值复制到主存[esp+8]
mov [esp+4],958		#将985复制到主存[esp+4]
mov eax,[ebp+8] 	#将主存[ebp+8]的值复制到eax
mov [esp],eax		#将eax的值复制到主存[esp]
add esp,8			#栈顶指针+8
~~~

其内存中的结构如下：

<img src="https://image.sybblogs.fun/img-common/202401211833546.png" alt="mov指令" style="zoom: 50%;" />

`sub esp,12`这条指令会让esp指针向下移动三位。

<img src="https://image.sybblogs.fun/img-common/202401211835106.png" alt="mov指令1" style="zoom:50%;" />

之后执行原理类似。

因此可以用mov指令，结合esp、ebp指针访问栈帧数据可以用减法$/$加法指令，即sub$/$add修改栈顶指针esp的值。

#### 切换栈帧

当发生函数调用时，需要修改ebp和esp指向，让其指向新的函数顶部和底部。这个切换过程原理如下：

- 当执行`call add`时，会将旧的$IP$压入栈中，并将$IP$跳转至被调用函数开头位置。

  <img src="https://image.sybblogs.fun/img-common/202401211854274.png" alt="切换栈帧" style="zoom: 50%;" />

- 被调用函数开头都会有两个指令

  ~~~shell
  push ebp 
  mov ebp,esp
  ~~~

  第一条指令会把栈底基地址压入栈顶，第二条指令会将ebp指向esp当前位置

  <img src="https://image.sybblogs.fun/img-common/202401211857933.png" alt="切换栈帧1" style="zoom:50%;" />

  这么做当一层函数执行结束要返回之前，总能在当前函数的栈底找到上一个函数基地址。这样既可以恢复ebp寄存器的值。

  以上两条指令可以精简为`enter`。

- 之后被调用函数执行对应操作，最函数执行完毕准备`ret`返回指令之前，所有函数都会进行两步操作

  ~~~shell
  mov esp,ebp		#让esp指向当前栈帧的底部
  pop ebp			#将esp所指元素出栈，写入寄存器ebp
  ~~~

  第一个指令会让ebp指向esp位置，即指向栈底。第二个指令会让esp所指的栈顶元素出栈放入ebp寄存器中，同时esp$+4$指向$IP$旧地址值的位置。也就是让ebp指针重新指向上一个函数栈底。

  <img src="https://image.sybblogs.fun/img-common/202401211909526.png" alt="切换栈帧2" style="zoom: 50%;" />

  上面两条指令等价于`leave`指令。

- 最后ret指令，由于上一步将esp指向$IP$旧地址，所以ret会将esp中的值写入$IP$寄存器当中。也就是让程序执行流恢复到调用函数之后的一行。

  <img src="https://image.sybblogs.fun/img-common/202401211912036.png" alt="切换栈帧3" style="zoom:50%;" />

总结：

<img src="https://image.sybblogs.fun/img-common/202401211913197.png" alt="函数切换栈帧总结" style="zoom:33%;" />

每个被调用函数在执行前都会有`enter`部分，最后都会有`leave`部分。

#### 栈帧中包含的内容

当前有一段代码

~~~c
int caller() {
    int temp1=125;
    int temp2=80;
    int sum=add(templ,temp2);
    return sum;
}

int add(int x,int y){
    return x+y;
}
~~~

假设当前运行的是`caller()`函数，根据之前内容，可以知道栈帧中通常包含以下内容：

- 栈帧底部一定是上一层函数栈帧的基址，即edp旧址。

- 栈帧最顶部一定是返回地址(当前函数的栈帧除外)，也就是$IP$寄存器旧址

- 通常将局部变量集中存储在栈帧底部区域。C语言中越靠前定义的局部变量越靠近栈顶。

  所以只需要将**$edp-4$就可以找到第一个局部变量**，$edp-8$就是第二个局部变量等。

- 通常将调用参数集中存储在栈帧顶部区域

  如果当前运行的是`add`函数，此时`edp`指向`add`函数栈底位置。此时**将$edp+8,edp+4$就可以得到$x$和$y$参数的值**。

所以一个函数栈内容分布如下：

<img src="https://image.sybblogs.fun/img-common/202401211929403.png" alt="函数栈帧" style="zoom:50%;" />

可以看到中间有空闲未使用区域。这是正常现象因为当使用gcc编译器时，编译器会将每个栈帧大小设置为$16B$的整数倍(当前函数的栈帧除外)，因此栈帧内可能出现空闲未使用的区域。

栈帧内容总结：

<img src="https://image.sybblogs.fun/img-common/202401211932114.png" alt="栈帧内容总结" style="zoom: 33%;" />

#### 函数参数与返回值的传递

通过上面学习可以知道函数参数通过$edp$向上移动可以获取。

有以下一段汇编代码

~~~shell
#caller()
caller:
push ebp
mov ebp,esp
sub esp,24
mov [ebp-12],125
mov [ebp-8],80
mov eax,[ebp-8]
mov [esp+4],eax
mov eax,[ebp-12]
mov esp,eax
call add
mov [ebp-4],eax
mov eax,[ebp-4]
leave
ret
~~~

执行完这段汇编程序后，函数栈如下：

<img src="https://image.sybblogs.fun/img-common/202401211947931.png" alt="汇编实战" style="zoom:50%;" />

之后会执行`call add`指令，add函数汇编指令如下：

~~~shell
#add()
add:
push ebp
mov ebp,esp
mov eax,[ebp+12]
mov edx,[ebp+8]
add eax,edx
leave
ret
~~~

执行完`mov ebp,esp`指令后栈帧如下：

<img src="https://image.sybblogs.fun/img-common/202401211948560.png" alt="汇编实战2" style="zoom:50%;" />

之后`mov eax,[ebp+12]`和`mov edx,[ebp+8]`，分别可以访问到$y,x$的值。并将这两个值放入$eax,edx$。`add eax,edx`会将这两个变量相加，相加后的结果再放回$eax$中。

<img src="https://image.sybblogs.fun/img-common/202401211951533.png" alt="汇编实战3" style="zoom: 50%;" />

最后执行`leave`指令切换上一层函数栈帧，再执行`ret`指令让程序回到函数调用后的一行继续执行。

可以看到add函数将返回值写到eax寄存器中。所以caller函数中的`mov [ebp-4],eax`就是取返回值的操作。即对应C语言中的`sum=add(temp1,temp2)`操作。之后仍会把`sum`放入eax寄存器，让上一层函数取返回值，即`mov eax [ebp-4]`。由于C语言的返回值只有一个，所以通常会把返回值写入eax中。这样上一层函数直接去eax中取出返回值即可。

至此对函数调用机器级语言进行总结：

<img src="https://image.sybblogs.fun/img-common/202401212000513.png" alt="汇编实战总结" style="zoom:50%;" />

最后还有一个问题，当调用者某些值已经存在$eax$寄存器中，那么调用发生时，被调用者也有可能用到$eax$寄存器，从而会覆盖其中的值。解决方法是在函数调用之前对寄存器$eax$中的值进行压栈保存即可。等函数返回后再将这些值从栈中恢复到寄存器即可。所以函数栈中还可能有一层是保存部分寄存器的值。

<img src="https://image.sybblogs.fun/img-common/202401212003886.png" alt="函数调用栈中寄存器的值" style="zoom: 33%;" />
