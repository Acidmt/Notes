[^2-2-2.1]:参考佩亚诺余项运算

[toc]

# 一. 基本概念

> ==数据结构三要素：逻辑结构、数据的运算、物理结构(存储结构)==

1. 提取操作对象，找出操作对象之间的关系并用数学的语言描述就是数据结构。

   操作对象指：每位学生的信息(学号、姓名、性别.....)

   操作的算法指：查询、插入、修改、删除等。

2. 数据结构可分为：线性数据结构（数组，队列，线性表等）、非线性数据结构（集合，树，图等）。

   线性数据结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。如：学生管理系统，是一对一关系

   非线性数据结构：一个结点可能油多个直接前趋和直接后继。如：目录结构(树)、最短路径(图)，是一对多关系或多对多关系。

   [最短路径：](https://image.sybblogs.fun/img-common/202304052128205.png)

   ![导航节点](https://image.sybblogs.fun/img-common/202304052128205.png)

## 1. 概念及定义

### 数据(Data)

> 数据是能输入计算机且能被计算机处理的各种符号的集合。

数据特点：

1. 信息的载体

2. 是对客观事物符号化的表示

3. 能够被计算机识别存储和加工

数据包括：

1. 数值型的数据：整数、实数等。

2. 非数值型的数据：文字、图像、图形、声音等。

### 数据元素

> 数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。而一个数据元素可由多个数据项组成，数据项是构成数据元素不可分割最小单位。

也可称为元素，或称为记录、结点或顶点。如上面最短路径图，其中的每个点我们称之为结点。

- 数据项

  > 数据项是构成元素的不可分割的最小单位。

  [数据项：](https://image.sybblogs.fun/img-common/202304052131322.png)

  <img src="https://image.sybblogs.fun/img-common/202304052131322.png" alt="数据项" style="zoom:43%;" />

  上面每行可称为数据元素，而每列可以称之为数据元素中的**数据项**。

- 三者关系

  数据$>$数据元素$>$数据项

  例子：学生表$>$个人记录$>$学号、姓名....

### 数据对象

> 数据对象是性质相同的数据元素的集合，是数据的一个子集。

如：学籍表可以看作是一个数据对象，由若干条学生信息构成的子集。

- 数据元素和数据对象关系

  数据元素：组成数据的基本单位。其与数据的关系是：数据元素是集合的个体。

  数据对象：性质相同的数据元素的集合。其与数据的关系是：集合的子集。

[数据对象图例：](https://image.sybblogs.fun/img-common/202304162111379.png)

<img src="https://image.sybblogs.fun/img-common/202304162111379.png" alt="数据对象图例" style="zoom:33%;" />

### 数据结构

> 意义：数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构( Structure )
>
> 数据结构是指相互之间存在一种或多种特定关系的数据元素集合。或者说，数据结构是带结构的数据元素的集合。

- 数据结构包含内容：

  1. 数据元素之间的逻辑关系，也称为**逻辑结构**。
  2. 数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的**物理结构**或数据的**存储结构**。
  3. 数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。

- 数据结构的两个层次

  1. 逻辑结构：

     描述数据元素之间的逻辑关系

     与数据存储无关，独立于计算机

     是从具体问题抽象出来的数学模型

  2. 物理结构(存储结构)：

     数据元素及其关系在计算机存储器中的结构(存储方式)

     是数据结构在计算机中的表示

  3. 逻辑结构和存储结构的关系：

     存储结构是逻辑关系的映像与元素本身的映像。

     逻辑结构是数据结构的抽象，存储结构是数据结构的实现。

     两者综合起来建立了数据元素之间的结构关系。

## 2. 四种逻辑结构

> 逻辑结构和数据的运算是定义一种数据结构前提。

集合结构(大纲不考)：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

[集合结构例子：](https://image.sybblogs.fun/img-common/202304161957873.png)

<img src="https://image.sybblogs.fun/img-common/202304161957873.png" alt="集合结构例子" style="zoom:33%;" />

线性结构：结构中的数据元素之间存在着一对一的线性关系，除了除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。

基本运算：①查找第$i$个数据元素。②在第$i$个位置插入新的数据元素。③删除第$i$个位置数据元素.....

[线性结构例子：](https://image.sybblogs.fun/img-common/202304161959324.png)

<img src="https://image.sybblogs.fun/img-common/202304161959324.png" alt="线性结构例子" style="zoom:33%;" />

树形结构：结构中的数据元素之间存在着一对多的层次关系。

[树形结构例子：](https://image.sybblogs.fun/img-common/202304162001827.png)

<img src="https://image.sybblogs.fun/img-common/202304162001827.png" alt="树形结构例子" style="zoom:33%;" />

图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。

[图结构例子：](https://image.sybblogs.fun/img-common/202304162002143.png)

<img src="https://image.sybblogs.fun/img-common/202304162002143.png" alt="图结构例子" style="zoom:33%;" />

[逻辑结构分类：](https://image.sybblogs.fun/img-common/202304052216835.png)

<img src="https://image.sybblogs.fun/img-common/202304052216835.png" alt="逻辑结构分类" style="zoom: 50%;" />

## 3. 四种基本存储结构

> 当我们定义完一种数据结构后，需要用计算机来实现这种数据结构，此时用到基本存储结构。

### 顺序存储结构

含义：

1. 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
2. C语言中用数组来实现顺序存储结构

[顺序存储结构示例：](https://image.sybblogs.fun/img-common/202304052224091.png)

<img src="https://image.sybblogs.fun/img-common/202304052224091.png" alt="顺序存储结构" style="zoom:43%;" />

### 链式存储结构

含义：

1. 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针表示。
2. C语言中用指针来实现链式存储结构。

[链式存储结构：](https://image.sybblogs.fun/img-common/202304052231942.png)

<img src="https://image.sybblogs.fun/img-common/202304052231942.png" alt="链式存储结构" style="zoom:43%;" />

如：上图$bat$对应指针(地址)是$165$，后面$130$是下一个元素地址，即$cat$。没有即为$NULL$

### 索引存储结构

含义：

1. 在存储结点信息的同时，还建立附加的索引表。
2. 通俗讲索引就是目录，一般形式是：关键字、地址。
3. 关键字是能唯一标识一个结点的数据项。
4. 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引。

[索引存储结构：](https://image.sybblogs.fun/img-common/202304162013420.png)

<img src="https://image.sybblogs.fun/img-common/202304162013420.png" alt="索引存储结构2" style="zoom:33%;" />

### 散列存储结构

根据结点的关键字直接计算出该结点的存储地址。如：哈希表。

## 4. 数据类型、抽象数据类型

### 4.1 数据类型

> 数据类型是一个值的取值范围和定义在此范围上的一组操作(加减、取模等)的总称。

1. 原子类型：其值不可再分的数据类型。如$int$类型(可进行加、减、乘、除、取模等运算)，$bool$类型(可进行与、或、非等操作)
2. 结构类型：其值可以再分解为若干成分(分量)的数据类型。如定义一个可操作横坐标和纵坐标的函数。

### 4.2 抽象数据类型(ADT)

> 抽象数据类型是抽象数据组织及与之相关的操作。如：逻辑结构、数据运算、物理结构(存储结构)，这个过程。

# 二. 算法

## 1. 算法基本概念

> 算法就是如何高效地处理这些数据，以解决实际问题。
>
> 其定义是对特定问题求解步骤地一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

算法特点：

1. 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。

3. 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入。 一个算法有零个或多个输入， 这些输入取自于某个特定的对象的集合。
   输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

以上特点只要有一个不满足，就不能称之为算法。

一个好的算法所具备特质：

1. 正确性。算法能够正确解决求解问题。
2. 可读性。算法应具有良好的可读性，以帮助人们理解。==考试时候要写注释==。
3. 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 高效率和低存储。即算法时间复杂度低，空间复杂度低。

[算法基本概念总结：](https://image.sybblogs.fun/img-common/202304162133530.png)

<img src="https://image.sybblogs.fun/img-common/202304162133530.png" alt="算法基本概念总结" style="zoom: 33%;" />

## 2. ==算法效率度量==

算法复杂度度量可以从两个方面：①时间复杂度、②空间复杂度

### 2.1 时间复杂度

> 用事前预估算法时间开销$T(n)$与问题规模$n$的关系($T$表示"time")。

方法：

- 时间复杂度加法规则：

  我们可以通过对每一行有效代码进行时间记录，从而估计出代码所需的执行时间。如下：

  ~~~c++
  void loveYou(int n) { //n 为问题规模
      ①int i=1;//爱你的程度
      ②while(i<=n){
      ③    i++ ;
          //每次+1
      ④    printf("I Love You %d\n",i);
      }
      ⑤printf("I Love You More Than %d\n",n) ;
  }
  int main( ){
      loveYou(3000) ;
  }
  ~~~

  以上代码模拟打印3000遍I Love You。运行结果如下：

  ~~~c++
  ....
  I Love You 2994
  I Love You 2995
  I Love You 2996
  I Love You 2997
  I Love You 2998
  ....
  I Love You 3001
  I Love You More Than 3000
  ~~~

  我么可以估计一下语句执行时间：①⑤各执行一次，②执行3001次，③④执行3000次，所以变量$n$为3000时，所需执行时间为：

  $T(3000)=1+1+3001+2\times3000$。所以其时间开销$T$与问题规模$n$关系式子为：$T(n)=3n+3$。

  虽然我们通过如此简单方式得出这段程序所需执行时间，但是广义化之后该方法并不适用：如果代码是几万行的这种方法显然不适用。

  根据我们所学数学知识，我们想得到一个估计大小时，一个表达式中更低阶部分我们往往可以省略。所以上面可以写为$T(n)=3n$。假设有以下算法时间复杂度：
  $$
  \begin{equation*}
  	\begin{aligned}
  &T_1(n)=3n^2+3n+3000\xrightarrow{忽略低阶后}=3n^2\\
  \\
  &T_2(n)=n^3+n^2+9999\xrightarrow{忽略低阶后}=n^3
  	\end{aligned}
  \end{equation*}
  $$
  我们一般用$O$表示"同阶"(同等数量级。即，当$n\to\infty$时，二者极限之比为常数，来代替最高阶前面系数)，来规范时间复杂度的写法。所以上面规范写法如下：
  $$
  \begin{equation*}
  	\begin{aligned}
  &3n^2=O(n^2)\\
  \\
  &n^3=O(n^3)
  	\end{aligned}
  \end{equation*}
  $$
  结论：一个程序的算法复杂度可以只考虑阶数高的部分。以上是时间复杂度计算的加法规则，同样我们可以推出以下的规则：

- 乘法规则

  $T(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$

  即多项相乘，都保留。如：$T(n)=O(n^3)\times O(n^2)=O(n^5)$[^2-2-2.1]

- 混合运算规则

  $T(n)=O(f(n))+O(g(n))=max\{O(f(n))+O(g(n))\}$

  混合运算需要保留最大那个项。为了方便理解我们可以保留其中变化趋势最大函数，函数变化趋势如下：

  [复杂度变化趋势：](https://image.sybblogs.fun/img-common/202304171954955.png)

  <img src="https://image.sybblogs.fun/img-common/202304171954955.png" alt="复杂度变化趋势" style="zoom:43%;" />

  例子：$T(n)=n^3+n^2\log_2n=$$O(n^3)+O(n^2\log_2n)=$$O(n^3)$。

通过以上规则我们还要注意以下几点：

1. 顺序执行的代码只会影响常数项，所以可以忽略不记。
2. 循环执行代码中，我们只需要挑一个循环体基本操作，分析他的执行次数即可。
3. 如果有多层嵌套循环，我们只需要关注最深层代码循环次数即可。

例1：分析以下代码时间复杂度

~~~c++
//算法3- 指数递增型爱 你
void loveYou(int n) { //n 为问题规模
    int i=1;//爱你的程度
    while(i<=n){
        i=i*2; //每次翻倍
        printf("I Love You %d\n",i);        
    }
    printf("I Love You More Than %d\n",n);
}
~~~

> 答案：$T(n)=O(\log_2n)$
>
> 解析：我们直接看循环体，循环体中，赋值语句$i$每次翻倍，假设循环了$x$次，则循环结束时刚好满足$2^x>n$，所以$x=\log_2n+1$
>
> 则，时间复杂度$T(n)=O(\log_2n)$

例2：分析以下代码时间复杂度

~~~c++
void loveYou(int flag[]， int n) { //n 为问题规模
    printf("I Am Iron Man\n") ;
    for(int i=0; i<n; i++){ //从第一个元素开始查找
        if(flag[i]==n){ //找到元素n
            printf("I Love You %d\n"，n) ;
            break; //找 到后立即跳出循环
        }
    }
}
//其中flag数组是1~n个数，输入一个数n找出n在数组中的位置
int main(){
    int flag[n]={1...n};
    loveYou(flag,n); 
    return 0;
}
~~~

> 答案：最好情况：元素n在第一个位置，即最好时间复杂度$T(n)=O(1)$
> 最坏情况：元素n在最后一个位置，最坏时间复杂度$T(n)=O(n)$
> 平均情况：假设元素n在任意一个位置的概率相同为$\frac{1}{n}$，平均时间复杂度$T(n)=O(n)$
>
> 平均情况解析：循环次数$x=(1+2+3+...+n)\frac{1}{n}=(\frac{n(1+n)}{2})\frac{1}{n}=\frac{1+n}{2}$，即$T(n)=O(x)=O(n)$

注意：我们在评价一个算法时候一般只看最坏情况和平均情况，而最好情况一般参考意义不大。

[时间复杂度总结：](https://image.sybblogs.fun/img-common/202304172233517.png)

<img src="https://image.sybblogs.fun/img-common/202304172233517.png" alt="时间复杂度总结" style="zoom: 33%;" />

### 2.2 空间复杂度

空间复杂度需要时间复杂度中运算知识。空间复杂度我们用$S(n)$表示。

例1：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n];
    //声明一个长度为n的数组
    int i;
    //.....此处省略很多代码
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数所需要参数$n为int类型$占四个字节，下面的$i也是int$类型所以也是四字节，数组长度是$n$且为int类型，所以是$4n$，那么这个程序所需要空间为：$4n+8$。规范写法为$S(n)=O(n)$

结论：常数项同样不考虑，注意数组大小等。

例2：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n][n]; //声明 n*n的二维数组
    int otheg[n];
    //声明一个长度为n的数乡
    int i;
    //.... .此处省略很多代码
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：二维int类型n长度数组占大小为：$4n^2$，下面一维数组是$4n$，所以$S(n)=O(n^2)+O(n)+O(1)=O(n^2)$

例3：计算以下程序空间复杂度

~~~c++
void loveYou(int n) { //n 为问题规模
    int a,b,c; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数递归$n$次，每次变量大小占$16$，所以应该为$S(n)=16n=O(n)$

结论：递归问题空间复杂$=$递归调用深度。

例4：我们对例3进行改进，讲声明变量改为数组

~~~c++
void loveYou(int n) { //n 为问题规模
    int flag[n]; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：函数递归调用$n$次，每次数组长度为$n$，所以空间复杂度为：$1+2+3+...n=\frac{n(1+n)}{2}=\frac{1}{2}n^2+\frac{1}{2}n$，即答案。	 

[空间复杂度总结：](https://image.sybblogs.fun/img-common/202304172316612.png)

<img src="https://image.sybblogs.fun/img-common/202304172316612.png" alt="空间复杂度总结" style="zoom:43%;" />

# 三. 线性表

## 1. 线性表定义

定义：线性表是具有**相同数据类型**的$n (n≥0)$ 个数据元素的**有限序列**，其中$n$为表长，当$n=0$时线性表是一个空表。若用$L$命名线性表，则其一般表示为：
$$
\begin{equation*}
	\begin{aligned}
&L=(a_1,a_2...a_i,a_{i+1}...a_n)
	\end{aligned}
\end{equation*}
$$
几个概念：

1. $a_i$是线性表中的"第$i$个"元素线性表中的位序
2. $a_1$是表头元素；$a_n$是表尾元素。
3. 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。

## 2. 线性表的基本操作

InitList(&L)：初始化表。构造一个空的线性表$L$，分配内存空间。
DestroyList(&L)：销毁操作。销毁线性表，并释放线性表$L$所占用的内存空间。

ListInsert(&L，i，e)：插入操作。在表$L$中的第$i$个位置上插入指定元素$e$。
ListDelete(&L，i，&e)：删除操作。删除表$L$中第$i$个位置的元素，并用$e$返回删除元素的值。

LocateElem(L，e)：按值查找操作。在表$L$中查找具有给定关键字值的元素。
GetElem(L，i)：按位查找操作。获取表$L$中第$i$个位置的元素的值。

其他常用操作:
Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。
PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。
Empty(L)：判空操作。若L为空表，则返回true，否则返回false。

以上括号内的是参数。

总结：

1. 对数据的操作：创建，销毁、增删改查

2. $C$语言函数的定义：<返回值类型>函数名(<参数1类型>参数1，<参数2类型>参数2.....)

3. 函数名和参数的形式、命名都可改变。对于命名一般用驼峰命名法：

   方法名、参数名、成员变量、局部变量需要使用小驼峰命名法

   类名需要使用大驼峰命名法

4. 什么时候要传入引用"&"：对参数的修改结果需要"带回来"。解释如下：

   ~~~c++
   #include<stdio.h>
   void test(int & x) {
       x=1024;
       printf( "test函数内部x=%d\n",x);
   }
   int main() {
       int X=1;
       printf("调用test前x=%d\n",x) ;
       test(X) ;
       printf( "调用test后x=%d\n",x) ;
   }
   ~~~

   运行结果：

   调用test前x=1
   test函数内部x=1024
   调用test后x= 1024

   > 这里test函数中的$x$是引用类型，所以不用返回值就可以修改主函数中的$x$值。

[线性表知识点总结：](https://image.sybblogs.fun/img-common/202304222018400.png)

<img src="https://image.sybblogs.fun/img-common/202304222018400.png" alt="线性表知识点总结" style="zoom: 50%;" />

## 3. 顺序表

顺序表是线性表的一种。其定义是：用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置，上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。

顺序表优缺点：

- 优点:可随机存取，存储密度高
- 缺点:要求大片连续空间，改变容量不方便

我们可以用$C$语言提供的$sizeof$关键字来判断一个类型或者数据的大小。

[顺序存储：](https://image.sybblogs.fun/img-common/202304222108332.png" alt="顺序存储" style="zoom:33%;" />)

<img src="https://image.sybblogs.fun/img-common/202304222108332.png" alt="顺序存储" style="zoom:33%;" />

### 3.1 顺序表的静态分配

~~~c++
#define MaxSize 10			//定义最大长度
typedef struct{
    ElemType data[MaxSize];	//用静态的“数组”存放数据元素
    int length;				//顺序表的当前长度
}SqList;					//顺序表的类型定义(静态分配方式)
~~~

> 给各个数据元素分配连续的存储空间，大小为$MaxSize* sizeof(ElemType)$。即数组大小$\times$数据类型。
>
> 注意：$C$语言要初始化数据。否则会出现"脏数据"情况。

静态分配存在一定局限性：无法提前预知数组大小。

### 3.2 顺序表的动态分配

$C$语言中动态申请和释放内存空间函数：

- ==malloc(动态申请空间)==：SeqList.data = (ElemType *) malloc (sizeof(ElemType) * InitSize);

  > malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针。

- 
  free(删除申请空间)：free(SeqList.data)

~~~c++
#define InitSize 10	//顺序表的初始长度
typedef struct{
    ElemType *data;	//指示动态分配数组的指针
    int MaxSize;	//顺序表的最大容量
    int length;		//顺序表的当前长度
} SeqList;			//顺序表的类型定义(动态分配方式)
~~~

动态分配案例：

~~~c++
#include <bits/stdc++.h>
using namespace std;
struct stu{
	int *arr;
	int len;
};
void initArr(stu &l){						//初始化arr指针，并未其分配初始空间
	int i=0,j=0;
	l.arr=(int *)malloc(10*sizeof(int));
	l.len=0;
	while(cin>>i){							//输入数组值
		l.arr[j]=i;
		l.len++;
		j++;
	}
}

void insertArr(stu &l,int cout){			//扩大arr指针空间
	int *p=l.arr;
	l.arr=(int *)malloc(cout*sizeof(int));
	for(int i=0;i<l.len;i++){
		l.arr[i]=p[i];
		printf("指针值：%d\n",p[i]);
	}
	free(p);
}
int main(){
	stu l;
	initArr(l);
	insertArr(l,3);
	for(int i=0;i<l.len;i++){
		cout<<l.arr[i]<<endl;				//输出扩大后的数组arr
	}
} 
~~~

顺序表的特点:

1. 随机访问，即可以在$O(1)$时间内找到第$i$个元素。
2. 存储密度高，每个节点存储数据元累
3. 拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)
4. 插入、删除操作不方便，需要移动大量元素

### 3.3 顺序表的插入

~~~c++
#define MaxSize 10				//定义最大长度
typedef struct{
    int data[MaxSize]; 			//用静态的"数组"存放数据
    int length;					//顺序表的当前长度
}SqList;						//顺序表的类型定义
bool ListInsert(SqList &L,int i,int e){
    if(i<1||i>L.length+1) 		//判断i的范围是否有效
        return false;
    if(L.length>=MaxSize)		//当前存储空间已满，不能插入
        return false;
    for(int j=L.length;j>=i;j--)//将第1个元素 及之后的元素后移
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;				//在位置i处放入e 
    L.length++;					//长度加1
    return true ;
}
int main( ) {
    SqList L;					//声明一个顺序表
    InitList(L);				//初始化顺序表
    //...此处省略一些代码，插入几个元素
    ListInsert(L,3,3);
    return 0;
}
~~~

> 以上就是对顺序表进行元素插入操作。

我们可以对以上ListInsert()方法进行时间复杂度分析：

1. 最好情况：新元素插入到表尾，不需要移动元素。

   $i=n+1$，循环$0$次，最好时间复杂度$=O(1)$

2. 最坏情况：新元素插入到表头，需要将原有的$n$个元素全部向后移动

   $i=1$，循环$n$次；最坏时间复杂度$=O(n)$

3. 平均情况：假设新元素插入到任何一个位置的概率相同，即$i=1,2,3...,length+1$的概率都是$p=\frac{1}{n+1}$

   当$i=1$时，循环$n$次；$i=2$时，循环$n-1$次；$i=3$时，循环$n-2$次$...i=n+1$时，循环$0$次。

   所以平均循环次数$=np+(n-1)p+(n-2)p+...+p=\frac{n(n+1)}{2}\frac{1}{n+1}=\frac{n}{2}$

   由此可得时间复杂度为$O(n)$

### 3.4 顺序表的删除

~~~c++
#define MaxSize 10				//定义最大长度
typedef struct{
    int data[MaxSize]; 			//用静态的"数组"存放数据
    int length;					//顺序表的当前长度
}SqList;	
bool ListDelete(SqList &L,int i,int &e){
    if(i<1||i>L.length)			//判断i的范围是否有效
        return false;
    e=L.data[i-1];				//将被删除的元素赋值给e
    for(int j=i;j<L.length;j++) //将第i个位 置后的元素前移
        L.data[j-1]=L.data[j];
    L.length--;					//线性表长度减1
    return true ;
}
int main() {
    SqList L;					//声明一个顺序表
    InitList(L);				//初始化顺序表
    //.. .此处省略一些代码，插入几个元素
    int e; 						//用变量e把删除的元素”带回来”
    if (ListDelete(L,3,e))
        printf("已删除第3个元素,删除元素值为=%d\n",e);
    else
        printf("位序i不合法，删除失败\n");
    return 0;
}
~~~

运行结果：已删除第3个元素,删除元素值为$=$3；

我们可以对以上ListDelete()方法进行时间复杂度分析：

1. 最好情况：删除表尾元素，不需要移动其他元素

   $i=n$，循环$0$次，最好时间复杂度$=O(1)$

2. 最坏情况：删除表头元素，需要将后续的$n-1$个元素全都向前移动

   $i=1$，循环$n-1$次；最坏时间复杂度$=O(n)$；

3. 平均情况：假设删除任何一个元素的概率相同，即$i= 1,2,3, ... length$的概率都是$p=\frac{1}{n}$

   $i=1$，循环$n-1$次，$i=2$，循环$n-2$次$...i=n$时，循环$0$次

   平均循环次数为$=(n-1)p+(n-2)p+...+p=\frac{n(n-1)}{2}\frac{1}{n}=\frac{n-1}{2}$

   由此可得时间复杂度为$O(n)$

[顺序表基本操作总结：](https://image.sybblogs.fun/img-common/202304231803306.png)

<img src="https://image.sybblogs.fun/img-common/202304231803306.png" alt="顺序表基本操作" style="zoom: 33%;" />

### 3.5 顺序表的查找

- 按位查找

  获取表L中第i个位置的元素的值。静态分配方式：

  ~~~c++
  #define MaxSize 10
  //定义最大长度
  typedef struct{
      ElemType data [MaxSize];//用静态的“数组”存放数据元素
      int length;				//顺序表的当前长度
  }SqList;					//顺序表的类型定义(静态分配方式)
  ElemType GetElem(SqList L,int i){
     return L.data[i-1]; 
  }
  ~~~

  动态分配方式：

  ~~~c++
  #define InitSize 10			//顺序表的初始长度
  typedef struct{
      ElemType *data;			//指示动态分配数组的指针
      int MaxSize;			//顺序表的最大容量
      int length;				//顺序表的当前长度
  } SeqList;					//顺序表的类型定义(动态分配方式)
  ElemType GetElem(SqList L,int i){
     return L.data[i-1]; 
  }
  ~~~

  由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第$i$个元素。具有"随机存取"特性。

- 按值查找

  注意：不能直接判断两个结构体是否相等。如果要判断我们需要对结构体一个一个比较。

  基本数据类型如：int、 char、 double、float等可以直接用运算符"=="比较。但$C++$可以

  ~~~c++
  #define InitSize 10					//顺序表的初始长度
  typedef struct{
      ElemType *data;					//指示动态分配数组的指针
      int MaxSize;					//顺序表的最大容量
      int length;						//顺序表的当前长度
  } SeqList;							//顺序表的类型定义(动态分配方式)
  //在顺序表L中查找第一一个元素值等于e的元素，并返回其位序
  int LocateElem(SeqList L,ElemType e){
      for(int i=0;i<L. length; i++)
          if(L.data[i]==e)
              return i+1; 			// 数组下标为i的元素值等于e，返回其位序i+1
      return 0;						//退出循环，说明查找失败
  }
  ~~~

  该算法的时间复杂度：

  1. 最好情况：目标元素在表头，循环$1$次；最好时间复杂度$=O(1)$

  2. 最坏情况：目标元素在表尾，循环$n$次，最坏时间复杂度$=O(n)$

  3. 平均情况：假设目标元素出现在任何一个位置的概率相同， 都是$\frac{1}{n}$

     目标元素在第$1$位，循环$1$次；在第$2$位，循环$2$次.....在第$n$位，循环$n$次

     平均循环次数：$=1·\frac{1}{n}+2·\frac{1}{n}+...+n·\frac{1}{n}=\frac{n(n+1)}{2}\frac{1}{n}=\frac{n+1}{n}$

     即时间复杂度为$=O(n)$

[顺序表按位查找和按值查找总结：](https://image.sybblogs.fun/img-common/202304242008573.png)

<img src="https://image.sybblogs.fun/img-common/202304242008573.png" alt="顺序表按位查找和按值查找" style="zoom:43%;" />

## 4. 单链表

链表不同于顺序表的顺序存储方式，用的是链式存储。

单链表的每个结点除了存放数据元素，同时还需要包含指向下一个结点的指针。由于每个结点只包含一个指针所以叫单链表。

单链表优缺点：

- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可随机存取，要耗费一定空间存放指针，无法逆向检索。

单链表定义如下：

~~~c++
struct LNode{
    ElemType data;
    struct LNode *next;
}
~~~

> 上面的"LNode"称之为结点，data称为数据域，*next称为指针域。

带头节点的单链表：

~~~c++
typedef struct LNode{
    int data;				//定义单链表结点类型
    struct LNode *next;		//每个节点存放一个数据元素
}LNode,*LinkList;			//指针指向下一个节点

//初始化一个空的单链表
bool InitList(LinkList &L) {
    L = (LNode *)malloc(sizeof(LNode));	//分配一个头结点
    if (L==NULL)						//内存不足，分配失败
        return false;
    L->next = NULL;						//头结点之后暂时还没有节点
    return true;
}
void test(){
    LinkList L;				//声明一个指向单链表的指针
    //初始化一个空表
    InitList(L);
    //......后续代码......
}
~~~

> 上面前四行代码是将"struct LNode"命名为"LNode"，并且用"LinkList"表示一个指向"struct LNode"的指针。

不带头结点单链表

~~~C++
typedef struct LNode{
    int data;				//定义单链表结点类型
    struct LNode *next;		//每个节点存放一个数据元素
}LNode,*LinkList;			//指针指向下一个节点

//初始化一个空的单链表
bool InitList(LinkList &L) {
    L = NULL; //空表，暂时还没有任何结点
    return true;
}
void test(){
    LinkList L;				//声明一个指向单链表的指针
    //初始化一个空表
    InitList(L);
    //......后续代码......
}
~~~

### 4.1 单链表建立

#### 4.1.1 尾插法

先初始化一个带头结点的单列表，之后每次取个数据元素插入表尾部。是比较常用的方法。

- 先初始化链表：

  ~~~C++
  typedef struct LNode{
      int data;				//定义单链表结点类型
      struct LNode *next;		//每个节点存放一个数据元素
  }lNode,*linkList;			//指针指向下一个节点
  
  //初始化链表 
  bool initList(linkList &l){
  	l=(lNode*)malloc(sizeof(lNode));	//链表开辟一个头节点
  	if(l==NULL)
  		return false;
  	l->next=NULL;						//头结点指针域指向空
  	return true;
  }
  ~~~

- 创建链表：

  ~~~C++
  //尾插法创建链表 
  bool insertTail(linkList &l){
  	lNode *pHead,*pTial;				//指针pHead和pTial分别表示链表头部和尾部
  	pTial=l;							//将尾指针指向l链表
  	int i=0;
  	while(i!=999999){		
  		cin>>i;
  		if(i!=999999){
  			pHead=(lNode*)malloc(sizeof(lNode));	
  			pHead->data=i;				//创建结点pHead其数据与为输入的i值
  			pTial->next=pHead;			//将尾部结点的指针域指向头部结点
  			pTial=pHead;				//接着将尾部结点指向创建的头部结点
  		}
  	}
  	pTial->next=NULL;					//将最后一个指针域设置为空
  	return 1;
  }
  ~~~

- 主函数：

  ~~~C++
  int main(){
  	linkList link;
  	initList(link);					//链表初始化 
  	insertTail(link);				//尾插法创建链表 
  } 
  ~~~

运行结果：

> 输入：1，2，399

[尾插法图像示例：](https://image.sybblogs.fun/img-common/202305171720079.gif)

<img src="https://image.sybblogs.fun/img-common/202305171720079.gif" alt="f47832ac0b274b19b1fb2e5ba8d5fcb9" style="zoom: 25%;" />

#### 4.1.2 头插法建立链表

头插法将每个数据插入在链表头部。头插法可以用于==链表的逆置==。

- 同样先初始化链表：

  ~~~C++
  typedef struct LNode{
      int data;				//定义单链表结点类型
      struct LNode *next;		//每个节点存放一个数据元素
  }lNode,*linkList;			//指针指向下一个节点
  
  //初始化链表 
  bool initList(linkList &l){
  	l=(lNode*)malloc(sizeof(lNode));	//链表开辟一个头节点
  	if(l==NULL)
  		return false;
  	l->next=NULL;						//头结点指针域指向空
  	return true;
  }
  ~~~

- 创建链表：

  ~~~C++
  bool insertHead(linkList &l){
  	int i=0;
  	lNode *p;
  	while(i!=999999){		
  		cin>>i;
  		if(i!=999999){
  			p=(lNode*)malloc(sizeof(lNode));
  			p->data=i;
  			p->next=l->next;
  			l->next=p;
  		}		
  	}
  	return 1;
  }
  ~~~

- 主函数

  ~~~C++
  int main(){
  	linkList link;
  	initList(link);					//链表初始化 
  	insertHead(link);				//尾插法创建链表 
  } 
  ~~~

运行效果和尾插法一样。

[头插法图像示例：](https://image.sybblogs.fun/img-common/202305171718497.gif)

<img src="https://image.sybblogs.fun/img-common/202305171718497.gif" alt="7ae0a7bd64d74b5d9a149f7849e38f93" style="zoom:33%;" />

### 4.2 单链表的插入

核心思路是将插入位置前一个结点的指针域指向新建立的结点，再将新节点的指针与指向后一个结点(前一个结点指针域中的值为后一个结点)。

代码如下：

~~~C++
//按序号插入
bool insertVaule(linkList &l,int local,int e){	//local表示要插入位置，e表示插入的值
	lNode *p,*head=l;							
	int i;
	p=(lNode*)malloc(sizeof(lNode));
	if(p==NULL||local<1) return 0;
	p->data=e;									//建立新节点p
	while(head->next!=NULL&&i<local-1){			//找到要插入位置的上一个结点
		head=head->next;
		i++;
	}
	p->next=head->next;							//将新节点p的指针域指向后一个结点
	head->next=p;								//前一个结点指针域指向新节点p
	return 1;
} 
//前插操作:将s结点插入到p结点之前
bool InsertPriorNode (LNode *p,LNode *s){
    if (p==NULL||S==NULL) return false;
    s->next=p->next;				//s指针与连接到p结点的后继
    p->next=s;						//s连到p之后
    ElemType temp=p->data; 			//交换数据域部分
    p->data=s->data;
    S->data=temp;
    return true;
}
~~~

主函数：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
	insertVaule(link,3,66); 		//按号插入 
	printlist(link);				//链表遍历 	
}  
~~~

[指定结点前插操作：](https://image.sybblogs.fun/img-common/202305181901601.png)

<img src="https://image.sybblogs.fun/img-common/202305181901601.png" alt="指定结点前插操作" style="zoom:43%;" />

> 输入：1，2，3，4，5
>
> 运行结果：1，2，3，66，4，5

### 4.3 单链表的删除

通过按照输入序号删除对应结点，其原理和上面的插入类似。

~~~C++
//按序号删除
bool deletaList(linkList &l,int number){
    int i=0;
    lNode *p=l,*tail;				//tail指针存放的要删除的结点
    if(number<=0){
        return 0;
    }
    while(p!=NULL&&i<number-1){		//找到删除结点的前一个结点
        p=p->next;
        i++;
    }
    tail=p->next;					//将tail指向要删除结点地址
    p->next=tail->next;				//将前一个结点指针域指向被删除结点后一个结点
    free(tail);						//释放要删除结点
    return 1;
} 
//删除指定结点p
bool DeleteNode (LNode *p){
    if (p==NULL) return false;
    LNode *q=p->next;				//令q指向*p的后继结点
    p->data=p->next->data; 			//和后继结点交换数据域
    p->next=q->next;				//将*q结点从链中“断开”
    free(q);						//释放后继结点的存储空间
    return true;
}
~~~

主函数代码：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
	deletaList(link,3);				//按序号删除
	printlist(link);				//链表遍历 	
}  
~~~

关于删除指定节点p，其本质就是将p的后继结点复制给p结点，再释放后继结点，并将p结点重新指向下一个结点。这种方法有个局限性，就是我们在删除最后一个结点时，由于后一个结点为null所以程序会出错，我们就只能使用传统办法循环一个个找了。

> 输入：1，2，3，4，5
>
> 运行结果：1，2，4，5

### 4.4 链表的查找

最常用的查找是按值查找和按序号查找

~~~C++
//按值查找
bool findVaule(linkList &l,int d){	//d代表要查找的值
	lNode *p=l;
	while(p!=NULL){
		if(p->data==d){				//如果找到要查找的值d返回1
			return 1;
		}
		p=p->next;
	}
	return 0;
	
} 

//按号查找
int findNumber(linkList &l,int num){//表示返回第num个结点的值
	int i=0;
	if(num<=0){
		return 0;
	}
	lNode *p=l;
	while(p!=NULL&&i<num){			//找到这个结点，并返回结点值域中的值
		p=p->next;
		i++;
	}
	return p->data;
} 
//对单链表进行打印 
void printlist(linkList &l){
	while(l->next!=NULL){
		cout<<l->next->data<<endl;
		l=l->next;
	}
}
~~~

主函数：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
    int resultVaule,resultNumber;
	resultVaule=findVaule(link,2);	//按值查找 
	cout<<resultVaule<<endl;
	resultNumber=findNumber(link,3);//按序号查找 
	cout<<resultNumber<<endl;
	printlist(link);				//链表遍历 	
}  
~~~

### 4.5 习题：链表的逆置

逆置方法有很多种，可以通过遍历链表元素，用头插法将遍历元素值插入新链表。

~~~C++
#include <bits/stdc++.h>
#include<string>
using namespace std;
typedef struct lNode{
	int data;
	lNode *next;
}lNode,*linkList;

//初始化
bool initLink(linkList &l){
	l=(lNode*)malloc(sizeof(lNode));
	if(l==NULL) return 0;
	l->next=NULL;
	return true;
} 

//尾插法
bool insertTail(linkList &l){
	int i=0;
	lNode *head,*tial=l;
	while(i!=999999){
		cin>>i;
		if(i!=999999){
			head=(lNode*)malloc(sizeof(lNode));
			head->data=i;
			tial->next=head;
			tial=head;
		}
	}
	tial->next=NULL;
	return 1;
}
 
 //头插法实现逆序
lNode* reverseLink(linkList &l){
	lNode *p,*r;
	initLink(r);
	while(l->next!=NULL){				//遍历链表取值
		p=(lNode*)malloc(sizeof(lNode));
		p->data=l->next->data;			//头插法赋值给新链表
		p->next=r->next;
		r->next=p;
		l=l->next;						
	}
	return r;
} 
 
 //打印链表
 void printLink(linkList &l){
 	while(l->next!=NULL){
 		cout<<l->next->data<<endl;
 		l=l->next;
	 }
 } 
 
int main(){
	lNode *link,*result;
	initLink(link);						//初始化链表 
	insertTail(link);					//尾插法创建列表
	result=reverseLink(link);			//用头插法实现逆序
	printLink(result);
}
~~~

> 输入值：1，23，4，5
>
> 运行结果：5，4，23，1

## 5. 双链表

由于单链表只能指向下一个指针，而双链表同时指向前驱节点和后继结点。

### 5.1 双链表的初始化

~~~C++
typedef struct DNode{						//定义双链表结点类型
    ElemType data;							//数据域
    struct DNode *prior,*next;				//前驱和后继指针
}DNode, *DLinklist;

//初始化双链表
bool InitDLinkList(DLinklist &L){
    L = (DNode *) malloc(sizeof (DNode)); 	//分配一个头结点
    if (L==NULL) return false;				//内存不足， 分配失败
    L->prior = NULL;						//头结点的prior永远指向NULL
    L->next = NULL;							//头结点之后暂时还没有节点
    return true;
}
void testDL inkList() {						//初始化双链表
    DLinklist L;
    InitDLinkList(L);
    //后续代码...
}
~~~

同样的这里的`DNode`和`DLinklist`等价，只是为了区分链表`(DLinklist)`和结点`(DNode)`

### 5.2 双链表的插入

~~~C++
//在p结点之后插入s结点.
bool InsertNextDNode(DNode *p，DNode *s){
    if (p==NULL||s==NULL) return false;		//非法参数
    s->next=p->next;
    if (p->next != NULL) 
        p->next->prior=s; 					//如果p结点有后继结点
    s->prior=p;
    p->next=s;
    return true;
}
~~~

[双链表的插入：](https://image.sybblogs.fun/img-common/202305221637350.png)

<img src="https://image.sybblogs.fun/img-common/202305221637350.png" alt="双链表的插入" style="zoom: 50%;" />

[双链表最后一个节点插入：](https://image.sybblogs.fun/img-common/202305221638889.png)

<img src="https://image.sybblogs.fun/img-common/202305221638889.png" alt="双链表的最后一个节点插入" style="zoom:50%;" />

### 5.3 双链表的删除

同样和之前但链表删除方法一致。

~~~C++
//删除p结点的后继结点q
bool DeleteNextDNode(DNode *p){
    if ( p==NULL) return false;
    DNode *q = p->next; 			//找到p的后继结点q
    if (q==NULL) return false; 		//p没有后继
    p->next=q->next;
    if (q->next !=NULL)				//q结点不是最后一个结点
        q->next->prior=p;
    free(q);						//释放结点空间
    return true; 
}

//双链表的销毁
void DestoryL ist(DLinklist &L){	//循环释放各个数据结点
    while (L->next != NULL)
        DeleteNextDNode(L);			//删除每个结点的后一个结点
    free(L);						//释放头结点
    L=NULL;							//头指针指向NULL   							
}
~~~

[双链表的总结：](https://image.sybblogs.fun/img-common/202305221701942.png)

<img src="https://image.sybblogs.fun/img-common/202305221701942.png" alt="双链表的总结" style="zoom:50%;" />

## 6. 循环链表

循环链表就是在单链表(双链表)的基础上讲最后一个结点指向头节点。

特点是：从一个结点出发可以找到其他任何一个结点。常用于对表头和表尾操作频率高的情况下。

### 6.1 循环单链表的初始化

[循环单链表结构：](https://image.sybblogs.fun/img-common/202305221703001.png)

<img src="https://image.sybblogs.fun/img-common/202305221703001.png" alt="循环链表" style="zoom:50%;" />

~~~C++
typedef struct LNode{						//定义单链表结点类型
    ElemType data;							//每个节点存放一个数据元素
    struct LNode *next;						//指针指向下一个节点
}LNode, *LinkList;
//初始化一个循环单链表
bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode)); 	//分配一个头结点
    if (L==NULL) return false;				//内存不足,分配失败
    L->next = L;							//头结点next指向头结点本身
    return true; 
}
~~~

其他操作基本与前面一致。注意判断最后一个结点时，应该判断是否指向头节点。

### 6.2 循环双链表的初始化

循环链表：表头结点的prior指向表尾结点；表尾结点的next指向头结点。

循环双链表不需要考虑表头表尾的界限操作。

[循环双链表结构：](https://image.sybblogs.fun/img-common/202305221713236.png)

<img src="https://image.sybblogs.fun/img-common/202305221713236.png" alt="循环双链表" style="zoom:50%;" />

~~~C++
typedef struct DNode{						//定义双链表结点类型
    ElemType data;							//数据域
    struct DNode *prior,*next;				//前驱和后继指针
}DNode, *DLinklist;

//初始化空的循环双链表
bool InitDL inkList(DLinklist &L){
    L = (DNode *) malloc(sizeof(DNode)); 		//分配一个头结点
    if (L==NULL) return false;					//内存不足,分配失败
    L->prior = L;								//头结点的prior指向头结点
    L->next = L;								//头结点的next指向头结点
    return true;
}
~~~

其他操作

~~~C++
//在p结点之后插入s结点
bool InsertNextDNode(DNode *p,DNode *s){
    s->next=p->next; 							//将结点*s插入到结点*p之后
    p->next->prior=s;
    S->prior=p;
    p->next=s;
}

//删除p的后继结点q
p->next=q->next;
q->next>prior=p;
free(q);
~~~

[循环链表总结：](https://image.sybblogs.fun/img-common/202305221739830.png)

<img src="https://image.sybblogs.fun/img-common/202305221739830.png" alt="循环链表总结" style="zoom:50%;" />

## 7. 静态链表

与单链表不同的是静态链表是分配一整片连续的内存空间，各个结点集中安置。

静态链表每个数据元素4B，每个游标4B ( 每个结点共8B)。设起始地址为addr，e1的存放地址为addr + 8*2。2是接下来要寻找的数组下标。

适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景(如操作系统的文件分配表FAT)。

[静态链表结构：](https://image.sybblogs.fun/img-common/202305221746658.png)

<img src="https://image.sybblogs.fun/img-common/202305221746658.png" alt="静态链表" style="zoom:50%;" />

### 7.1 静态链表的初始化

~~~C++
#include<stdio.h>
#define maxsize 30
 
typedef char elemtype;
typedef struct{
	int cur;
	elemtype data;
}slink,slinklist[maxsize];

void initspace_sl(slink *space){//将数据各分量链接成一个备用链表，space[0]代表头指针
	int i;
	for(i=0;i<maxsize-1;i++){
		space[i].cur=i+1;		//下标为i结点的后继为下标是i+1的结点
	}
	space[maxsize-1].cur=0;		//0表示空指针
} 
~~~

[初始化静态链表：](https://image.sybblogs.fun/img-common/202305221803193.png)

<img src="https://image.sybblogs.fun/img-common/202305221803193.png" alt="初始化静态链表" style="zoom: 50%;" />

## 8. 顺序表和链表的比较

两种表的适用场景：

1. 表长难以预估、经常要增加$/$删除元素用链表(订餐系统)。
2. 表长可预估、查询(搜索)操作较多用顺序表(课堂点名)。

逻辑结构：顺序表和链表都属于线性结构。

存储结构：

- 顺序表优点：拥有随机存取的特点，存储密度高。缺点：大片连续空间分配不方便，改变容量不方便。
- 链表优点：离散的小空间分配方便，改变容量方便。缺点：不可随机存储，存储密度低。

基本操作比较：

- 两种表的创建：

  - 顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量;若分配空间过大，则浪费内存资源。

    静态分配：容量不可更改。

    动态分配：容量可以更改，但需要移动大量元素，时间代价高。

  - 链表：只需分配一个头结点(也可以不要头结点，只声明一个头指针)，之后方便拓展

- 两种表的销毁：

  - 链表：依次删除各个结点(free)

  - 顺序表：需要讲$length=0$。静态分配方式，系统会自动回收。动态分配：需要手动销毁(free)。

    注意：malloc和free函数必须成对出现。

- 两种表的增加和删除

  - 顺序表：插入$/$删除元素要将后续元素都后移$/$前移。虽然在时间复杂度上和链表一致，但数据元素大，移动时间成本就高。

  - 链表：插入$/$删除元素只需修改指针即可。查找元素时间低。

- 两种表的查找

  - 顺序表：按位查找时间复杂度为$O(1)$。按值查找时间复杂度$O(n)$，若表内元素有序可以通过算法，可在$O(\log_2n)$时间内找到。
  - 链表：按位查找和按值查找时间复杂度都为$O(1)$

在遇到一个开放式问题探讨时：从逻辑结构，存储结构和基本操作这三方面回答。

# 四. 栈

栈和线性表的结构很相似，但栈只允许在一端进行插入或删除操作的线性表。栈和我们生活种摞起来的盘子类似。

[摞起来的盘子：](https://image.sybblogs.fun/img-common/202305231625768.png)

<img src="https://image.sybblogs.fun/img-common/202305231625768.png" alt="盘子" style="zoom:43%;" />

[栈结构和常见术语：](https://image.sybblogs.fun/img-common/202305231627448.png)

<img src="https://image.sybblogs.fun/img-common/202305231627448.png" alt="栈结构和术语" style="zoom:43%;" />

进栈顺序：$a_1\longrightarrow a_2\longrightarrow a_3\longrightarrow a_4\longrightarrow a_5$

出战顺序：$a_5\longrightarrow a_4\longrightarrow a_3\longrightarrow a_2\longrightarrow a_1$

栈特点：后进(push)先出(pop)(LIFO)

栈的基本操作：创建、销毁、增加、删除、查询、判空。

## 1. 栈的顺序存储实现

### 1.1 栈的定义

和线性表类似，我们先要用结构体初始化栈。

~~~C++
#define MaxSize 10			//定义栈中元素的最大个数
typedef struct{
    ElemType data [MaxSize];//静态数组存放栈中元素
    int top;				//栈顶指针,每次入栈值+1,永远指向栈顶
} SqStack;

//初始化栈
void InitStack(SqStack &S){
    S.top=-1;				//初始化栈顶指针   
}

//判断栈空
bool StackEmpty(SqStack S){
    if(S. top==-1)
        return true;		//栈空
    else      
        return false;	 	//不空
}
~~~

### 1.2 栈的增加

~~~C++
//新元素入栈
bool Push(SqStack &s, ElemType x){
    if(s.top==MaxSize-1)
        return false;		//栈满，报错
    s.top = s.top+1;		//指针先加1       
    s.data[s.top]=x;		//新元素入栈    
    //上面两句等价于：s.data[++s.top]=x;
    return true;
}
~~~

### 1.3 出栈操作

~~~C++
//出栈操作
bool Pop(SqStack &S, ELemType &x){
    if(S.top==-1) 			//栈空,报错       
        return false;
    x=S.data[S.top]; 		//栈顶元素先出栈   
    S.top=S.top-1; 			//指针再减l
    //等价于：x=S.data[s.top--];
    return true;
}
~~~

### 1.4 共享栈

通过上面代码实现我们可以发现栈的一个明显缺点是栈的大小不可变，可以通过链式栈或者分配大空间来解决这个问题。但分配大片空间会导致空间冗余，这时候可以用共享栈解决。

共享栈就是两个栈共享一片空间。

共享栈实现：

~~~C++
#define MaxSize 10
//定义栈中元素的最大个数
typedef struct{
    ElemType_ data [MaxSize];	//静态数组存放栈中元素
    int top0;					//0号栈栈顶指针	
    int top1;					//1号栈栈顶指针
} ShStack;

//初始化栈
void InitStack(ShStack &S){
    S.top0=-1;					//初始化栈顶指针    
    S.top1=MaxSize;
}
~~~

[共享栈结构：](https://image.sybblogs.fun/img-common/202305231703776.png)

<img src="https://image.sybblogs.fun/img-common/202305231703776.png" alt="共享栈" style="zoom:43%;" />

共享栈两个top指针一个从下网上存储，一个从上往下存储。判断栈满的条件是：`top0 + 1 == top1`

## 2. 链栈

定义：用链式存储结构实现的栈

实现：实际上我们用头插法建立的单链表就是一个链栈。

### 2.1 链栈初始化

~~~C++
typedef struct Linknode{
    ElemType data;				//数据域
    struct L inknode *next;		//指针域
} *LiStack;						//栈类型定义

//初始化 
bool initStack(LiStack &l){
	l=(LiStack)malloc(sizeof(LiStack));//带头节点
	if(l==NULL) return false;
	l->next=NULL;
	return true;
}
~~~

### 2.2 链栈的入栈

用头插法入栈

~~~C++
bool pushStack(LiStack &l,int e){
    if(l==NULL) return false;
    LiStack p;
    p=(LiStack)malloc(sizeof(LiStack));
    p->data=i;							//头插法
    p->next=l->next;
    l->next=p;
    return true;
}  
~~~

### 2.3 链栈的出栈

链栈的出栈操作，栈顶指针是第一个指针（头指针的下一个），所以将其往后挪一位就好了。

~~~C++
//出栈
bool Pop(LiStack &l){
    LiStack p;
    if(l->next==NULL){
        return false;
    }else{
        p=l->next;			//p指向第一个结点(头结点后继结点)
		l->next=p->next;	//往后挪一位
        free(p);
        return true;
    }
}
~~~

### 2.4 链栈打印

最后其它操作和单链表一致。

~~~C++
void printStack(LiStack &l){
	while(l->next!=NULL){
		cout<<l->next->data<<endl;
		l=l->next;
	}
} 
~~~

## 3. 栈的应用—括号匹配

括号匹配就是相邻括号成对出现。如：$[],\{\},()$.

具体思路是用栈实现括号匹配：

1. 依次扫描所有字符，遇到左括号入栈，遇到右括号存入数组(也可以不用数组，当输入右括号直接和栈中括号匹配)
2. 查看是否匹配。匹配失败情况:
   ①左括号单身②右括号单身③左右括号不匹配

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 20
using namespace std;

static int couts=0;				//全局静态变量，用于记录数组中的右括号数 
typedef struct Linknode{
    char data;				
    struct Linknode *next;		
} *LiStack;						

//初始化
bool initLiStack(LiStack &l){
	l=(LiStack)malloc(sizeof(LiStack));
	if(l==NULL) return false;
	l->next=NULL;
	return true;
} 

//入栈
bool pushStack(LiStack &l,char s){
	LiStack p;
	p=(LiStack)malloc(sizeof(LiStack));
	if(p==NULL) return false;
	p->data=s;
	p->next=l->next;
	l->next=p;
	return true;
}

//出栈 
char popStack(LiStack &l){					
	LiStack p;
	char s;
	if(l->next==NULL) {
		cout<<"栈空"<<endl;
		return 'E';	
	}
	s=l->next->data;
	p=l->next;
	l->next=p->next;
	free(p);
	return s;	
}

//区分左右括号
void bracketLeftRight(LiStack &l,char *p,char str){	//p表述指针数组，str用户输入值 
 	if(str=='('||str=='{'||str=='['){				//如果是左括号，放入栈中 
 		pushStack(l,str);
	 }else if(str==')'||str=='}'||str==']'){		//如果是右括号，放入数组中，全局变量couts+1 
	 	p[couts]=str;
	 	couts+=1;
	 }else{
	 	cout<<"输入值不合法"<<endl;
	 } 
 }
 
 //判断括号是否对应
 bool  bracketCheck(LiStack &l,char *p){
 	char bracket;
 	for(int j=0;j<couts;j++){
 		bracket=popStack(l);
 		if(bracket=='E') return false; 				//栈空，配对失败 
 		if(p[j]==')'&&bracket!='(') return false; 	//三种括号匹配 
 		if(p[j]==']'&&bracket!='[') return false;
 		if(p[j]=='}'&&bracket!='{') return false;
	 }
 }

int main(){
	LiStack l;	
	char str,c[MaxSize]={0},*p=c;					//str:接受输入值，c[]存放右括号,p数组指针传递 
	initLiStack(l);									//初始化 
	while(str!='!'){								//输入'!'结束输入 
		cin>>str;
		if(str!='!'){
			bracketLeftRight(l,p,str);				//每输入一个值判断左右括号 
		}
	}
	if(bracketCheck(l,p)>0){
		cout<<"括号全部匹配"<<endl; 					//括号全部匹配 
	}else{
		cout<<"括号不匹配"<<endl; 					//括号不匹配 
	} 
} 
~~~

[括号匹配思路：](https://image.sybblogs.fun/img-common/202305262025840.png)

<img src="https://image.sybblogs.fun/img-common/202305262025840.png" alt="栈练习--括号匹配" style="zoom:33%;" />

## 4. ==栈的应用—表达式求值==

表达式通常由三部分组成：①操作数②运算符③界限符(加减乘除符号等)

常见表达式有以下几种：

1. 中缀表达式：$a+b$、$a\backslash b$、$a+b-c$、$a+b-c*d$

   特点：运算符在两个数中间

2. 后缀表达式(逆波兰表达式)：$ab+$、$ab\backslash$、$ab+c-$、$ab+cd*-$

   特点：运算符在两个操作数后面

3. 前缀表达式(波兰表达式)：$+ab$、$\backslash ab$、$-+abc$、$-+ab*cd$

   特点：运算符在操作数前面

$\Large 例:将中缀表达式((15÷(7-(1+1)))\times3)-(2+(1+1))转为后缀表达式$
$$
\begin{equation*}
	\begin{aligned}
Ⅰ.&先分析运算符生效顺序,如下图:
	\end{aligned}
\end{equation*}
$$
<img src="https://image.sybblogs.fun/img-common/202306081849449.png" alt="运算符生效顺序" style="zoom:33%;" />
$$
\begin{equation*}
	\begin{aligned}
Ⅱ.&从左到右依次扫描入栈:有操作符栈和操作数栈\\
\\
&
	\end{aligned}
\end{equation*}
$$

# 五. 队列

队列是只允许在队尾一端插入(入队)，在队头一端删除(出队)的数据结构。

特点：先进入先出(FIFO)。

栈的基本操作：创建、销毁、增加、删除、查询、判空。

## 1. 队列的顺序实现

### 1.1 队列初始化

~~~C++
typedef struct Linknode{
    int data[MaxSize];			//数据域
    int front,rear;				//队头指针和队尾指针 
    int size;					//记录队列大小
} sqQueue;						//队列 

//初始化
bool initQueue(sqQueue &s){
	s.front=0;
	s.rear=0;
	s.size=0;
} 
~~~

### 1.2 入列

~~~C++
//入列 
bool insertQueue(sqQueue &s,int e){
	if(s.size==MaxSize-1) return false;	//判断队列是否已满
	s.data[s.rear]=e;					//值赋给尾指针所指向的位置
	s.rear=(s.rear+1)%MaxSize;			//尾指针+1取余变为循环队列
	s.size+=1;							//队列元素个数+1
	return true;
} 
~~~

上面第五行取余操作，可以将对列变为循环队列。

[循环队列结构图：](https://image.sybblogs.fun/img-common/202305251735432.png)

<img src="https://image.sybblogs.fun/img-common/202305251735432.png" alt="循环队列" style="zoom:33%;" />

### 1.3 出列

~~~C++
//出列 
bool popQueue(sqQueue &s,int &e){
	if(s.size==0) return false;		//判断队列是否为空
	e=s.data[s.front];				//将头指针指向值赋值给e
	s.front=(s.front+1)%MaxSize;	//头指针往后移一位，取余变为循环队列
	s.size-=1;						//队列元素个数-1
	return true;
} 
~~~

和上面入列一样，这一队列变为循环队列，存储数据和读取数据更为方便。

### 1.4 队列元素个数

~~~C++
//元素个数
void printQueue(sqQueue s){
    cout<<(s.rear-s.front+MaxSize)%MaxSize<<endl;
} 
~~~

执行上面代码会实现当前队列中的元素个数。同时队列`s.size`中保存的也是元素个数。即
`(s.rear-s.front+MaxSize)%MaxSize<<endl~s.size`

### 1.5 其他情况

上面的都是队头队尾指针初始化时，指向同一位置，但有时候会碰见队尾指针在队尾情况

[队尾指针在队尾情况：](https://image.sybblogs.fun/img-common/202305251750011.png)

<img src="https://image.sybblogs.fun/img-common/202305251750011.png" alt="队尾指针在队尾" style="zoom: 50%;" />

此时入队操作有所改变，我们要先让尾指针向后移一位，再进行插入。

~~~C++
//入列 
bool insertQueue(sqQueue &s,int e){
    s.rear=(s.rear+1)%MaxSize;			//尾指针+1取余变为循环队列
	s.data[s.rear]=e;					//值赋给尾指针所指向的位置	
	return true;
} 
~~~

而初始化方式也有所不同，让尾指针指向队尾元素，当第一次入队时通过取余操作，往后移动到第一位。

~~~C++
//初始化
bool initQueue(sqQueue &s){
	s.front=0;
	s.rear=MaxSize-1;				//尾指针指向尾部
} 
~~~

判空操作和判满操作也不同：

~~~C++
//判空
(s.rear+1)%MaxSize==s.front;
~~~

判满操作同上，除了`size`判满操作，我们也可以通过设置辅助遍历`tag`来记录上次是入队操作，还是出队操作。由于只有入队操作会让队满，而只有出队操作会让队空，所以当入队时设置`tag=1`，当出队时设置`tag=0`。

~~~C++
//通过tag方式判断队列已满
if((s.rear+1)%MaxSize==s.front&&s.tag==1)
~~~

## 2. 链式队列

### 2.1 链式队列的初始化

~~~C++
typedef struct Linknode{		//结点	
    int data;					
    struct Linknode *next;		
}linknode;						

typedef struct linkQueue{		//链式队列			
	linknode* front;			//头指针 
	linknode* rear;				//尾指针	 
}linkQueue;

//初始化
bool initQueue(linkQueue &q){
	//带头节点方式： 
	q.rear=(linknode* )malloc(sizeof(linknode));
	q.front=q.rear;
	q.front->next=NULL;
	//不带头结点方式:
	//q.front=NULL;
	//q.rear=NULL; 
} 
~~~

初始化创造两个结构体，第一个是结点，第二个存储链队列地址。

[带头结点初始化：](https://image.sybblogs.fun/img-common/202305251939775.png)

<img src="https://image.sybblogs.fun/img-common/202305251939775.png" alt="带头结点初始化方式" style="zoom: 50%;" />

[不带头结点初始化：](https://image.sybblogs.fun/img-common/202305251940579.png)

<img src="https://image.sybblogs.fun/img-common/202305251940579.png" alt="不带头结点初始化方式" style="zoom:50%;" />

### 2.2 链式队列的入队

~~~C++
//入队操作
bool insertQueue(linkQueue &q,int e){
	linknode *s=(linknode *)malloc(sizeof(linknode));
	s->data=e;
	s->next=NULL;
	//带头结点方式：
	//q.rear->next=s;				//新结点插入到rear之后
	//q.rear=s;						//修改表尾指针
	//不带头结点方式：
	if(q.front==NULL){				//条件成立，证明队列为NULL 
		q.front=s;					//头指着指向s 
		q.rear=s;					//尾指针指向s 
	} else{
		q.rear->next=s;				//否则不为空，尾指针域指向s 
		q.rear=s;					//尾指针指向s 
	}
} 
~~~

[带头结点入队：](https://image.sybblogs.fun/img-common/202305251941418.png)

<img src="https://image.sybblogs.fun/img-common/202305251941418.png" alt="带头结点入队" style="zoom:50%;" />

[不带头结点入队：](https://image.sybblogs.fun/img-common/202305251946648.png)

<img src="https://image.sybblogs.fun/img-common/202305251946648.png" alt="不带头结点入队" style="zoom:50%;" />

### 2.3 链式队列出队操作

- 带头结点出队

  ~~~C++
  //出队操作(带头结点)
  bool DeQueue(linkQueue &q, int &e){
  	if(q.front==q.rear) return false;	//空队
  	linknode *p=q.front->next;
  	e=p->data;							//用变量e返回队头元素
  	q.front->next=p->next; 				//修改头结点的 next 指针
  	if(q.rear==p)						//此次是最后一个结点出队
  		q.rear=q.front;					//修改rear 指针
  	free(p);							//释放结点空间
  	return true;
  }
  ~~~

  [带头结点出队操作：](https://image.sybblogs.fun/img-common/202305252000397.png)

  <img src="https://image.sybblogs.fun/img-common/202305252000397.png" alt="带头结点出队" style="zoom:50%;" />

  [带头最后一个结点出队：](https://image.sybblogs.fun/img-common/202305252001310.png)

  <img src="https://image.sybblogs.fun/img-common/202305252001310.png" alt="带头最后一个结点出队" style="zoom:50%;" />

  最后一个结点出队，实际上就是将队列再次变为空队列

- 不带头结点出队

  ~~~C++
  //不带头结点出队
  bool DeQueue(linkQueue &q, int &e){
      if(q.front==NULL ) return false;		//空队
      linknode *p=q.front;					//p指向此次出队的结点
      e=p->data;								//用变量x返回队头元素
      q.front=p->next;						//修改front 指针
      if(q.rear==p){							//此次是最后一个结点出队
          q.front = NULL;						//front指向NULL
          q.rear = NULL;						//rear指向NULL
      }
      free(p);								//释放结点空间
      return true;
  }
  ~~~

  [不头结点出队：](https://image.sybblogs.fun/img-common/202305252005348.png)

  <img src="https://image.sybblogs.fun/img-common/202305252005348.png" alt="不头结点出队" style="zoom:50%;" />

## 3. 双端队列

[双端队列定义：](https://image.sybblogs.fun/img-common/202305261553330.png)

<img src="https://image.sybblogs.fun/img-common/202305261553330.png" alt="双端队列定义" style="zoom: 33%;" />

具体又可以细分为：输入受限的双端队列、输出受限的双端队列

[输入受限的双端队列和输出受限的双端队列：](https://image.sybblogs.fun/img-common/202305261555897.png)

<img src="https://image.sybblogs.fun/img-common/202305261555897.png" alt="输出或输出受限的双端队列" style="zoom:33%;" />

考点：和栈一样会考某组数据出栈顺序是否合法。可以用卡特兰数计算出一组数据有多少种合法出战组合。
$$
\begin{equation*}
	\begin{aligned}
&卡特兰数:\frac{1}{n+1}C^{n}_{2n}\\
\\
&如:输入数列为:1,2,3,4\\
\\
&合法输出组合为:\frac{1}{4+1}C^4_8=14
	\end{aligned}
\end{equation*}
$$
