[^2-2-2.1]:参考佩亚诺余项运算

[^7-2-1]:$[]$表示向上取整

[toc]

# 一. 基本概念

> ==数据结构三要素：逻辑结构、数据的运算、物理结构(存储结构)==

1. 提取操作对象，找出操作对象之间的关系并用数学的语言描述就是数据结构。

   操作对象指：每位学生的信息(学号、姓名、性别.....)

   操作的算法指：查询、插入、修改、删除等。

2. 数据结构可分为：线性数据结构（数组，队列，线性表等）、非线性数据结构（集合，树，图等）。

   线性数据结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。如：学生管理系统，是一对一关系

   非线性数据结构：一个结点可能油多个直接前趋和直接后继。如：目录结构(树)、最短路径(图)，是一对多关系或多对多关系。

   [最短路径：](https://image.sybblogs.fun/img-common/202304052128205.png)

   ![导航节点](https://image.sybblogs.fun/img-common/202304052128205.png)

## 1. 概念及定义

### 数据(Data)

> 数据是能输入计算机且能被计算机处理的各种符号的集合。

数据特点：

1. 信息的载体

2. 是对客观事物符号化的表示

3. 能够被计算机识别存储和加工

数据包括：

1. 数值型的数据：整数、实数等。

2. 非数值型的数据：文字、图像、图形、声音等。

### 数据元素

> 数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。而一个数据元素可由多个数据项组成，数据项是构成数据元素不可分割最小单位。

也可称为元素，或称为记录、结点或顶点。如上面最短路径图，其中的每个点我们称之为结点。

- 数据项

  > 数据项是构成元素的不可分割的最小单位。

  [数据项：](https://image.sybblogs.fun/img-common/202304052131322.png)

  <img src="https://image.sybblogs.fun/img-common/202304052131322.png" alt="数据项" style="zoom:43%;" />

  上面每行可称为数据元素，而每列可以称之为数据元素中的**数据项**。

- 三者关系

  数据$>$数据元素$>$数据项

  例子：学生表$>$个人记录$>$学号、姓名....

### 数据对象

> 数据对象是性质相同的数据元素的集合，是数据的一个子集。

如：学籍表可以看作是一个数据对象，由若干条学生信息构成的子集。

- 数据元素和数据对象关系

  数据元素：组成数据的基本单位。其与数据的关系是：数据元素是集合的个体。

  数据对象：性质相同的数据元素的集合。其与数据的关系是：集合的子集。

[数据对象图例：](https://image.sybblogs.fun/img-common/202304162111379.png)

<img src="https://image.sybblogs.fun/img-common/202304162111379.png" alt="数据对象图例" style="zoom:33%;" />

### 数据结构

> 意义：数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构( Structure )
>
> 数据结构是指相互之间存在一种或多种特定关系的数据元素集合。或者说，数据结构是带结构的数据元素的集合。

- 数据结构包含内容：

  1. 数据元素之间的逻辑关系，也称为**逻辑结构**。
  2. 数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的**物理结构**或数据的**存储结构**。
  3. 数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。

- 数据结构的两个层次

  1. 逻辑结构：

     描述数据元素之间的逻辑关系

     与数据存储无关，独立于计算机

     是从具体问题抽象出来的数学模型

  2. 物理结构(存储结构)：

     数据元素及其关系在计算机存储器中的结构(存储方式)

     是数据结构在计算机中的表示

  3. 逻辑结构和存储结构的关系：

     存储结构是逻辑关系的映像与元素本身的映像。

     逻辑结构是数据结构的抽象，存储结构是数据结构的实现。

     两者综合起来建立了数据元素之间的结构关系。

## 2. 四种逻辑结构

> 逻辑结构和数据的运算是定义一种数据结构前提。

集合结构(大纲不考)：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

[集合结构例子：](https://image.sybblogs.fun/img-common/202304161957873.png)

<img src="https://image.sybblogs.fun/img-common/202304161957873.png" alt="集合结构例子" style="zoom:33%;" />

线性结构：结构中的数据元素之间存在着一对一的线性关系，除了除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。

基本运算：①查找第$i$个数据元素。②在第$i$个位置插入新的数据元素。③删除第$i$个位置数据元素.....

[线性结构例子：](https://image.sybblogs.fun/img-common/202304161959324.png)

<img src="https://image.sybblogs.fun/img-common/202304161959324.png" alt="线性结构例子" style="zoom:33%;" />

树形结构：结构中的数据元素之间存在着一对多的层次关系。

[树形结构例子：](https://image.sybblogs.fun/img-common/202304162001827.png)

<img src="https://image.sybblogs.fun/img-common/202304162001827.png" alt="树形结构例子" style="zoom:33%;" />

图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。

[图结构例子：](https://image.sybblogs.fun/img-common/202304162002143.png)

<img src="https://image.sybblogs.fun/img-common/202304162002143.png" alt="图结构例子" style="zoom:33%;" />

[逻辑结构分类：](https://image.sybblogs.fun/img-common/202304052216835.png)

<img src="https://image.sybblogs.fun/img-common/202304052216835.png" alt="逻辑结构分类" style="zoom: 50%;" />

## 3. 四种基本存储结构

> 当我们定义完一种数据结构后，需要用计算机来实现这种数据结构，此时用到基本存储结构。

### 顺序存储结构

含义：

1. 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
2. C语言中用数组来实现顺序存储结构

[顺序存储结构示例：](https://image.sybblogs.fun/img-common/202304052224091.png)

<img src="https://image.sybblogs.fun/img-common/202304052224091.png" alt="顺序存储结构" style="zoom:43%;" />

### 链式存储结构

含义：

1. 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针表示。
2. C语言中用指针来实现链式存储结构。

[链式存储结构：](https://image.sybblogs.fun/img-common/202304052231942.png)

<img src="https://image.sybblogs.fun/img-common/202304052231942.png" alt="链式存储结构" style="zoom:43%;" />

如：上图$bat$对应指针(地址)是$165$，后面$130$是下一个元素地址，即$cat$。没有即为$NULL$

### 索引存储结构

含义：

1. 在存储结点信息的同时，还建立附加的索引表。
2. 通俗讲索引就是目录，一般形式是：关键字、地址。
3. 关键字是能唯一标识一个结点的数据项。
4. 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引。

[索引存储结构：](https://image.sybblogs.fun/img-common/202304162013420.png)

<img src="https://image.sybblogs.fun/img-common/202304162013420.png" alt="索引存储结构2" style="zoom:33%;" />

### 散列存储结构

根据结点的关键字直接计算出该结点的存储地址。如：哈希表。

## 4. 数据类型、抽象数据类型

### 4.1 数据类型

> 数据类型是一个值的取值范围和定义在此范围上的一组操作(加减、取模等)的总称。

1. 原子类型：其值不可再分的数据类型。如$int$类型(可进行加、减、乘、除、取模等运算)，$bool$类型(可进行与、或、非等操作)
2. 结构类型：其值可以再分解为若干成分(分量)的数据类型。如定义一个可操作横坐标和纵坐标的函数。

### 4.2 抽象数据类型(ADT)

> 抽象数据类型是抽象数据组织及与之相关的操作。如：逻辑结构、数据运算、物理结构(存储结构)，这个过程。

# 二. 算法

## 1. 算法基本概念

> 算法就是如何高效地处理这些数据，以解决实际问题。
>
> 其定义是对特定问题求解步骤地一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

算法特点：

1. 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。

3. 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入。 一个算法有零个或多个输入， 这些输入取自于某个特定的对象的集合。
   输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

以上特点只要有一个不满足，就不能称之为算法。

一个好的算法所具备特质：

1. 正确性。算法能够正确解决求解问题。
2. 可读性。算法应具有良好的可读性，以帮助人们理解。==考试时候要写注释==。
3. 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 高效率和低存储。即算法时间复杂度低，空间复杂度低。

[算法基本概念总结：](https://image.sybblogs.fun/img-common/202304162133530.png)

<img src="https://image.sybblogs.fun/img-common/202304162133530.png" alt="算法基本概念总结" style="zoom: 33%;" />

## 2. ==算法效率度量==

算法复杂度度量可以从两个方面：①时间复杂度、②空间复杂度

### 2.1 时间复杂度

> 用事前预估算法时间开销$T(n)$与问题规模$n$的关系($T$表示"time")。

方法：

- 时间复杂度加法规则：

  我们可以通过对每一行有效代码进行时间记录，从而估计出代码所需的执行时间。如下：

  ~~~c++
  void loveYou(int n) { //n 为问题规模
      ①int i=1;//爱你的程度
      ②while(i<=n){
      ③    i++ ;
          //每次+1
      ④    printf("I Love You %d\n",i);
      }
      ⑤printf("I Love You More Than %d\n",n) ;
  }
  int main( ){
      loveYou(3000) ;
  }
  ~~~

  以上代码模拟打印3000遍I Love You。运行结果如下：

  ~~~c++
  ....
  I Love You 2994
  I Love You 2995
  I Love You 2996
  I Love You 2997
  I Love You 2998
  ....
  I Love You 3001
  I Love You More Than 3000
  ~~~

  我么可以估计一下语句执行时间：①⑤各执行一次，②执行3001次，③④执行3000次，所以变量$n$为3000时，所需执行时间为：

  $T(3000)=1+1+3001+2\times3000$。所以其时间开销$T$与问题规模$n$关系式子为：$T(n)=3n+3$。

  虽然我们通过如此简单方式得出这段程序所需执行时间，但是广义化之后该方法并不适用：如果代码是几万行的这种方法显然不适用。

  根据我们所学数学知识，我们想得到一个估计大小时，一个表达式中更低阶部分我们往往可以省略。所以上面可以写为$T(n)=3n$。假设有以下算法时间复杂度：
  $$
  \begin{equation*}
  	\begin{aligned}
  &T_1(n)=3n^2+3n+3000\xrightarrow{忽略低阶后}=3n^2\\
  \\
  &T_2(n)=n^3+n^2+9999\xrightarrow{忽略低阶后}=n^3
  	\end{aligned}
  \end{equation*}
  $$
  我们一般用$O$表示"同阶"(同等数量级。即，当$n\to\infty$时，二者极限之比为常数，来代替最高阶前面系数)，来规范时间复杂度的写法。所以上面规范写法如下：
  $$
  \begin{equation*}
  	\begin{aligned}
  &3n^2=O(n^2)\\
  \\
  &n^3=O(n^3)
  	\end{aligned}
  \end{equation*}
  $$
  结论：一个程序的算法复杂度可以只考虑阶数高的部分。以上是时间复杂度计算的加法规则，同样我们可以推出以下的规则：

- 乘法规则

  $T(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$

  即多项相乘，都保留。如：$T(n)=O(n^3)\times O(n^2)=O(n^5)$[^2-2-2.1]

- 混合运算规则

  $T(n)=O(f(n))+O(g(n))=max\{O(f(n))+O(g(n))\}$

  混合运算需要保留最大那个项。为了方便理解我们可以保留其中变化趋势最大函数，函数变化趋势如下：

  [复杂度变化趋势：](https://image.sybblogs.fun/img-common/202304171954955.png)

  <img src="https://image.sybblogs.fun/img-common/202304171954955.png" alt="复杂度变化趋势" style="zoom:43%;" />

  例子：$T(n)=n^3+n^2\log_2n=$$O(n^3)+O(n^2\log_2n)=$$O(n^3)$。

通过以上规则我们还要注意以下几点：

1. 顺序执行的代码只会影响常数项，所以可以忽略不记。
2. 循环执行代码中，我们只需要挑一个循环体基本操作，分析他的执行次数即可。
3. 如果有多层嵌套循环，我们只需要关注最深层代码循环次数即可。

例1：分析以下代码时间复杂度

~~~c++
//算法3- 指数递增型爱 你
void loveYou(int n) { //n 为问题规模
    int i=1;//爱你的程度
    while(i<=n){
        i=i*2; //每次翻倍
        printf("I Love You %d\n",i);        
    }
    printf("I Love You More Than %d\n",n);
}
~~~

> 答案：$T(n)=O(\log_2n)$
>
> 解析：我们直接看循环体，循环体中，赋值语句$i$每次翻倍，假设循环了$x$次，则循环结束时刚好满足$2^x>n$，所以$x=\log_2n+1$
>
> 则，时间复杂度$T(n)=O(\log_2n)$

例2：分析以下代码时间复杂度

~~~c++
void loveYou(int flag[]， int n) { //n 为问题规模
    printf("I Am Iron Man\n") ;
    for(int i=0; i<n; i++){ //从第一个元素开始查找
        if(flag[i]==n){ //找到元素n
            printf("I Love You %d\n"，n) ;
            break; //找 到后立即跳出循环
        }
    }
}
//其中flag数组是1~n个数，输入一个数n找出n在数组中的位置
int main(){
    int flag[n]={1...n};
    loveYou(flag,n); 
    return 0;
}
~~~

> 答案：最好情况：元素n在第一个位置，即最好时间复杂度$T(n)=O(1)$
> 最坏情况：元素n在最后一个位置，最坏时间复杂度$T(n)=O(n)$
> 平均情况：假设元素n在任意一个位置的概率相同为$\frac{1}{n}$，平均时间复杂度$T(n)=O(n)$
>
> 平均情况解析：循环次数$x=(1+2+3+...+n)\frac{1}{n}=(\frac{n(1+n)}{2})\frac{1}{n}=\frac{1+n}{2}$，即$T(n)=O(x)=O(n)$

注意：我们在评价一个算法时候一般只看最坏情况和平均情况，而最好情况一般参考意义不大。

[时间复杂度总结：](https://image.sybblogs.fun/img-common/202304172233517.png)

<img src="https://image.sybblogs.fun/img-common/202304172233517.png" alt="时间复杂度总结" style="zoom: 33%;" />

### 2.2 空间复杂度

空间复杂度需要时间复杂度中运算知识。空间复杂度我们用$S(n)$表示。

例1：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n];
    //声明一个长度为n的数组
    int i;
    //.....此处省略很多代码
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数所需要参数$n为int类型$占四个字节，下面的$i也是int$类型所以也是四字节，数组长度是$n$且为int类型，所以是$4n$，那么这个程序所需要空间为：$4n+8$。规范写法为$S(n)=O(n)$

结论：常数项同样不考虑，注意数组大小等。

例2：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n][n]; //声明 n*n的二维数组
    int otheg[n];
    //声明一个长度为n的数乡
    int i;
    //.... .此处省略很多代码
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：二维int类型n长度数组占大小为：$4n^2$，下面一维数组是$4n$，所以$S(n)=O(n^2)+O(n)+O(1)=O(n^2)$

例3：计算以下程序空间复杂度

~~~c++
void loveYou(int n) { //n 为问题规模
    int a,b,c; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数递归$n$次，每次变量大小占$16$，所以应该为$S(n)=16n=O(n)$

结论：递归问题空间复杂$=$递归调用深度。

例4：我们对例3进行改进，讲声明变量改为数组

~~~c++
void loveYou(int n) { //n 为问题规模
    int flag[n]; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：函数递归调用$n$次，每次数组长度为$n$，所以空间复杂度为：$1+2+3+...n=\frac{n(1+n)}{2}=\frac{1}{2}n^2+\frac{1}{2}n$，即答案。	 

[空间复杂度总结：](https://image.sybblogs.fun/img-common/202304172316612.png)

<img src="https://image.sybblogs.fun/img-common/202304172316612.png" alt="空间复杂度总结" style="zoom:43%;" />

# 三. 线性表

## 1. 线性表定义

定义：线性表是具有**相同数据类型**的$n (n≥0)$ 个数据元素的**有限序列**，其中$n$为表长，当$n=0$时线性表是一个空表。若用$L$命名线性表，则其一般表示为：
$$
\begin{equation*}
	\begin{aligned}
&L=(a_1,a_2...a_i,a_{i+1}...a_n)
	\end{aligned}
\end{equation*}
$$
几个概念：

1. $a_i$是线性表中的"第$i$个"元素线性表中的位序
2. $a_1$是表头元素；$a_n$是表尾元素。
3. 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。

## 2. 线性表的基本操作

InitList(&L)：初始化表。构造一个空的线性表$L$，分配内存空间。
DestroyList(&L)：销毁操作。销毁线性表，并释放线性表$L$所占用的内存空间。

ListInsert(&L，i，e)：插入操作。在表$L$中的第$i$个位置上插入指定元素$e$。
ListDelete(&L，i，&e)：删除操作。删除表$L$中第$i$个位置的元素，并用$e$返回删除元素的值。

LocateElem(L，e)：按值查找操作。在表$L$中查找具有给定关键字值的元素。
GetElem(L，i)：按位查找操作。获取表$L$中第$i$个位置的元素的值。

其他常用操作:
Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。
PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。
Empty(L)：判空操作。若L为空表，则返回true，否则返回false。

以上括号内的是参数。

总结：

1. 对数据的操作：创建，销毁、增删改查

2. $C$语言函数的定义：<返回值类型>函数名(<参数1类型>参数1，<参数2类型>参数2.....)

3. 函数名和参数的形式、命名都可改变。对于命名一般用驼峰命名法：

   方法名、参数名、成员变量、局部变量需要使用小驼峰命名法

   类名需要使用大驼峰命名法

4. 什么时候要传入引用"&"：对参数的修改结果需要"带回来"。解释如下：

   ~~~c++
   #include<stdio.h>
   void test(int & x) {
       x=1024;
       printf( "test函数内部x=%d\n",x);
   }
   int main() {
       int X=1;
       printf("调用test前x=%d\n",x) ;
       test(X) ;
       printf( "调用test后x=%d\n",x) ;
   }
   ~~~

   运行结果：

   调用test前x=1
   test函数内部x=1024
   调用test后x= 1024

   > 这里test函数中的$x$是引用类型，所以不用返回值就可以修改主函数中的$x$值。

[线性表知识点总结：](https://image.sybblogs.fun/img-common/202304222018400.png)

<img src="https://image.sybblogs.fun/img-common/202304222018400.png" alt="线性表知识点总结" style="zoom: 50%;" />

## 3. 顺序表

顺序表是线性表的一种。其定义是：用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置，上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。

顺序表优缺点：

- 优点:可随机存取，存储密度高
- 缺点:要求大片连续空间，改变容量不方便

我们可以用$C$语言提供的$sizeof$关键字来判断一个类型或者数据的大小。

[顺序存储：](https://image.sybblogs.fun/img-common/202304222108332.png" alt="顺序存储" style="zoom:33%;" />)

<img src="https://image.sybblogs.fun/img-common/202304222108332.png" alt="顺序存储" style="zoom:33%;" />

### 3.1 顺序表的静态分配

~~~c++
#define MaxSize 10			//定义最大长度
typedef struct{
    ElemType data[MaxSize];	//用静态的“数组”存放数据元素
    int length;				//顺序表的当前长度
}SqList;					//顺序表的类型定义(静态分配方式)
~~~

> 给各个数据元素分配连续的存储空间，大小为$MaxSize* sizeof(ElemType)$。即数组大小$\times$数据类型。
>
> 注意：$C$语言要初始化数据。否则会出现"脏数据"情况。

静态分配存在一定局限性：无法提前预知数组大小。

### 3.2 顺序表的动态分配

$C$语言中动态申请和释放内存空间函数：

- ==malloc(动态申请空间)==：SeqList.data = (ElemType *) malloc (sizeof(ElemType) * InitSize);

  > malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针。

- 
  free(删除申请空间)：free(SeqList.data)

~~~c++
#define InitSize 10	//顺序表的初始长度
typedef struct{
    ElemType *data;	//指示动态分配数组的指针
    int MaxSize;	//顺序表的最大容量
    int length;		//顺序表的当前长度
} SeqList;			//顺序表的类型定义(动态分配方式)
~~~

动态分配案例：

~~~c++
#include <bits/stdc++.h>
using namespace std;
struct stu{
	int *arr;
	int len;
};
void initArr(stu &l){						//初始化arr指针，并未其分配初始空间
	int i=0,j=0;
	l.arr=(int *)malloc(10*sizeof(int));
	l.len=0;
	while(cin>>i){							//输入数组值
		l.arr[j]=i;
		l.len++;
		j++;
	}
}

void insertArr(stu &l,int cout){			//扩大arr指针空间
	int *p=l.arr;
	l.arr=(int *)malloc(cout*sizeof(int));
	for(int i=0;i<l.len;i++){
		l.arr[i]=p[i];
		printf("指针值：%d\n",p[i]);
	}
	free(p);
}
int main(){
	stu l;
	initArr(l);
	insertArr(l,3);
	for(int i=0;i<l.len;i++){
		cout<<l.arr[i]<<endl;				//输出扩大后的数组arr
	}
} 
~~~

顺序表的特点:

1. 随机访问，即可以在$O(1)$时间内找到第$i$个元素。
2. 存储密度高，每个节点存储数据元累
3. 拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)
4. 插入、删除操作不方便，需要移动大量元素

### 3.3 顺序表的插入

~~~c++
#define MaxSize 10				//定义最大长度
typedef struct{
    int data[MaxSize]; 			//用静态的"数组"存放数据
    int length;					//顺序表的当前长度
}SqList;						//顺序表的类型定义
bool ListInsert(SqList &L,int i,int e){
    if(i<1||i>L.length+1) 		//判断i的范围是否有效
        return false;
    if(L.length>=MaxSize)		//当前存储空间已满，不能插入
        return false;
    for(int j=L.length;j>=i;j--)//将第1个元素 及之后的元素后移
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;				//在位置i处放入e 
    L.length++;					//长度加1
    return true ;
}
int main( ) {
    SqList L;					//声明一个顺序表
    InitList(L);				//初始化顺序表
    //...此处省略一些代码，插入几个元素
    ListInsert(L,3,3);
    return 0;
}
~~~

> 以上就是对顺序表进行元素插入操作。

我们可以对以上ListInsert()方法进行时间复杂度分析：

1. 最好情况：新元素插入到表尾，不需要移动元素。

   $i=n+1$，循环$0$次，最好时间复杂度$=O(1)$

2. 最坏情况：新元素插入到表头，需要将原有的$n$个元素全部向后移动

   $i=1$，循环$n$次；最坏时间复杂度$=O(n)$

3. 平均情况：假设新元素插入到任何一个位置的概率相同，即$i=1,2,3...,length+1$的概率都是$p=\frac{1}{n+1}$

   当$i=1$时，循环$n$次；$i=2$时，循环$n-1$次；$i=3$时，循环$n-2$次$...i=n+1$时，循环$0$次。

   所以平均循环次数$=np+(n-1)p+(n-2)p+...+p=\frac{n(n+1)}{2}\frac{1}{n+1}=\frac{n}{2}$

   由此可得时间复杂度为$O(n)$

### 3.4 顺序表的删除

~~~c++
#define MaxSize 10				//定义最大长度
typedef struct{
    int data[MaxSize]; 			//用静态的"数组"存放数据
    int length;					//顺序表的当前长度
}SqList;	
bool ListDelete(SqList &L,int i,int &e){
    if(i<1||i>L.length)			//判断i的范围是否有效
        return false;
    e=L.data[i-1];				//将被删除的元素赋值给e
    for(int j=i;j<L.length;j++) //将第i个位 置后的元素前移
        L.data[j-1]=L.data[j];
    L.length--;					//线性表长度减1
    return true ;
}
int main() {
    SqList L;					//声明一个顺序表
    InitList(L);				//初始化顺序表
    //.. .此处省略一些代码，插入几个元素
    int e; 						//用变量e把删除的元素”带回来”
    if (ListDelete(L,3,e))
        printf("已删除第3个元素,删除元素值为=%d\n",e);
    else
        printf("位序i不合法，删除失败\n");
    return 0;
}
~~~

运行结果：已删除第3个元素,删除元素值为$=$3；

我们可以对以上ListDelete()方法进行时间复杂度分析：

1. 最好情况：删除表尾元素，不需要移动其他元素

   $i=n$，循环$0$次，最好时间复杂度$=O(1)$

2. 最坏情况：删除表头元素，需要将后续的$n-1$个元素全都向前移动

   $i=1$，循环$n-1$次；最坏时间复杂度$=O(n)$；

3. 平均情况：假设删除任何一个元素的概率相同，即$i= 1,2,3, ... length$的概率都是$p=\frac{1}{n}$

   $i=1$，循环$n-1$次，$i=2$，循环$n-2$次$...i=n$时，循环$0$次

   平均循环次数为$=(n-1)p+(n-2)p+...+p=\frac{n(n-1)}{2}\frac{1}{n}=\frac{n-1}{2}$

   由此可得时间复杂度为$O(n)$

[顺序表基本操作总结：](https://image.sybblogs.fun/img-common/202304231803306.png)

<img src="https://image.sybblogs.fun/img-common/202304231803306.png" alt="顺序表基本操作" style="zoom: 33%;" />

### 3.5 顺序表的查找

- 按位查找

  获取表L中第i个位置的元素的值。静态分配方式：

  ~~~c++
  #define MaxSize 10
  //定义最大长度
  typedef struct{
      ElemType data [MaxSize];//用静态的“数组”存放数据元素
      int length;				//顺序表的当前长度
  }SqList;					//顺序表的类型定义(静态分配方式)
  ElemType GetElem(SqList L,int i){
     return L.data[i-1]; 
  }
  ~~~

  动态分配方式：

  ~~~c++
  #define InitSize 10			//顺序表的初始长度
  typedef struct{
      ElemType *data;			//指示动态分配数组的指针
      int MaxSize;			//顺序表的最大容量
      int length;				//顺序表的当前长度
  } SeqList;					//顺序表的类型定义(动态分配方式)
  ElemType GetElem(SqList L,int i){
     return L.data[i-1]; 
  }
  ~~~

  由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第$i$个元素。具有"随机存取"特性。

- 按值查找

  注意：不能直接判断两个结构体是否相等。如果要判断我们需要对结构体一个一个比较。

  基本数据类型如：int、 char、 double、float等可以直接用运算符"=="比较。但$C++$可以

  ~~~c++
  #define InitSize 10					//顺序表的初始长度
  typedef struct{
      ElemType *data;					//指示动态分配数组的指针
      int MaxSize;					//顺序表的最大容量
      int length;						//顺序表的当前长度
  } SeqList;							//顺序表的类型定义(动态分配方式)
  //在顺序表L中查找第一一个元素值等于e的元素，并返回其位序
  int LocateElem(SeqList L,ElemType e){
      for(int i=0;i<L. length; i++)
          if(L.data[i]==e)
              return i+1; 			// 数组下标为i的元素值等于e，返回其位序i+1
      return 0;						//退出循环，说明查找失败
  }
  ~~~

  该算法的时间复杂度：

  1. 最好情况：目标元素在表头，循环$1$次；最好时间复杂度$=O(1)$

  2. 最坏情况：目标元素在表尾，循环$n$次，最坏时间复杂度$=O(n)$

  3. 平均情况：假设目标元素出现在任何一个位置的概率相同， 都是$\frac{1}{n}$

     目标元素在第$1$位，循环$1$次；在第$2$位，循环$2$次.....在第$n$位，循环$n$次

     平均循环次数：$=1·\frac{1}{n}+2·\frac{1}{n}+...+n·\frac{1}{n}=\frac{n(n+1)}{2}\frac{1}{n}=\frac{n+1}{n}$

     即时间复杂度为$=O(n)$

[顺序表按位查找和按值查找总结：](https://image.sybblogs.fun/img-common/202304242008573.png)

<img src="https://image.sybblogs.fun/img-common/202304242008573.png" alt="顺序表按位查找和按值查找" style="zoom:43%;" />

## 4. 单链表

链表不同于顺序表的顺序存储方式，用的是链式存储。

单链表的每个结点除了存放数据元素，同时还需要包含指向下一个结点的指针。由于每个结点只包含一个指针所以叫单链表。

单链表优缺点：

- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可随机存取，要耗费一定空间存放指针，无法逆向检索。

单链表定义如下：

~~~c++
struct LNode{
    ElemType data;
    struct LNode *next;
}
~~~

> 上面的"LNode"称之为结点，data称为数据域，*next称为指针域。

带头节点的单链表：

~~~c++
typedef struct LNode{
    int data;				//定义单链表结点类型
    struct LNode *next;		//每个节点存放一个数据元素
}LNode,*LinkList;			//指针指向下一个节点

//初始化一个空的单链表
bool InitList(LinkList &L) {
    L = (LNode *)malloc(sizeof(LNode));	//分配一个头结点
    if (L==NULL)						//内存不足，分配失败
        return false;
    L->next = NULL;						//头结点之后暂时还没有节点
    return true;
}
void test(){
    LinkList L;				//声明一个指向单链表的指针
    //初始化一个空表
    InitList(L);
    //......后续代码......
}
~~~

> 上面前四行代码是将"struct LNode"命名为"LNode"，并且用"LinkList"表示一个指向"struct LNode"的指针。

不带头结点单链表

~~~C++
typedef struct LNode{
    int data;				//定义单链表结点类型
    struct LNode *next;		//每个节点存放一个数据元素
}LNode,*LinkList;			//指针指向下一个节点

//初始化一个空的单链表
bool InitList(LinkList &L) {
    L = NULL; //空表，暂时还没有任何结点
    return true;
}
void test(){
    LinkList L;				//声明一个指向单链表的指针
    //初始化一个空表
    InitList(L);
    //......后续代码......
}
~~~

### 4.1 单链表建立

#### 4.1.1 尾插法

先初始化一个带头结点的单列表，之后每次取个数据元素插入表尾部。是比较常用的方法。

- 先初始化链表：

  ~~~C++
  typedef struct LNode{
      int data;				//定义单链表结点类型
      struct LNode *next;		//每个节点存放一个数据元素
  }lNode,*linkList;			//指针指向下一个节点
  
  //初始化链表 
  bool initList(linkList &l){
  	l=(lNode*)malloc(sizeof(lNode));	//链表开辟一个头节点
  	if(l==NULL)
  		return false;
  	l->next=NULL;						//头结点指针域指向空
  	return true;
  }
  ~~~

- 创建链表：

  ~~~C++
  //尾插法创建链表 
  bool insertTail(linkList &l){
  	lNode *pHead,*pTial;				//指针pHead和pTial分别表示链表头部和尾部
  	pTial=l;							//将尾指针指向l链表
  	int i=0;
  	while(i!=999999){		
  		cin>>i;
  		if(i!=999999){
  			pHead=(lNode*)malloc(sizeof(lNode));	
  			pHead->data=i;				//创建结点pHead其数据与为输入的i值
  			pTial->next=pHead;			//将尾部结点的指针域指向头部结点
  			pTial=pHead;				//接着将尾部结点指向创建的头部结点
  		}
  	}
  	pTial->next=NULL;					//将最后一个指针域设置为空
  	return 1;
  }
  ~~~

- 主函数：

  ~~~C++
  int main(){
  	linkList link;
  	initList(link);					//链表初始化 
  	insertTail(link);				//尾插法创建链表 
  } 
  ~~~

运行结果：

> 输入：1，2，399

[尾插法图像示例：](https://image.sybblogs.fun/img-common/202305171720079.gif)

<img src="https://image.sybblogs.fun/img-common/202305171720079.gif" alt="f47832ac0b274b19b1fb2e5ba8d5fcb9" style="zoom: 25%;" />

#### 4.1.2 头插法建立链表

头插法将每个数据插入在链表头部。头插法可以用于==链表的逆置==。

- 同样先初始化链表：

  ~~~C++
  typedef struct LNode{
      int data;				//定义单链表结点类型
      struct LNode *next;		//每个节点存放一个数据元素
  }lNode,*linkList;			//指针指向下一个节点
  
  //初始化链表 
  bool initList(linkList &l){
  	l=(lNode*)malloc(sizeof(lNode));	//链表开辟一个头节点
  	if(l==NULL)
  		return false;
  	l->next=NULL;						//头结点指针域指向空
  	return true;
  }
  ~~~

- 创建链表：

  ~~~C++
  bool insertHead(linkList &l){
  	int i=0;
  	lNode *p;
  	while(i!=999999){		
  		cin>>i;
  		if(i!=999999){
  			p=(lNode*)malloc(sizeof(lNode));
  			p->data=i;
  			p->next=l->next;
  			l->next=p;
  		}		
  	}
  	return 1;
  }
  ~~~

- 主函数

  ~~~C++
  int main(){
  	linkList link;
  	initList(link);					//链表初始化 
  	insertHead(link);				//尾插法创建链表 
  } 
  ~~~

运行效果和尾插法一样。

[头插法图像示例：](https://image.sybblogs.fun/img-common/202305171718497.gif)

<img src="https://image.sybblogs.fun/img-common/202305171718497.gif" alt="7ae0a7bd64d74b5d9a149f7849e38f93" style="zoom:33%;" />

### 4.2 单链表的插入

核心思路是将插入位置前一个结点的指针域指向新建立的结点，再将新节点的指针与指向后一个结点(前一个结点指针域中的值为后一个结点)。

代码如下：

~~~C++
//按序号插入
bool insertVaule(linkList &l,int local,int e){	//local表示要插入位置，e表示插入的值
	lNode *p,*head=l;							
	int i;
	p=(lNode*)malloc(sizeof(lNode));
	if(p==NULL||local<1) return 0;
	p->data=e;									//建立新节点p
	while(head->next!=NULL&&i<local-1){			//找到要插入位置的上一个结点
		head=head->next;
		i++;
	}
	p->next=head->next;							//将新节点p的指针域指向后一个结点
	head->next=p;								//前一个结点指针域指向新节点p
	return 1;
} 
//前插操作:将s结点插入到p结点之前
bool InsertPriorNode (LNode *p,LNode *s){
    if (p==NULL||S==NULL) return false;
    s->next=p->next;				//s指针与连接到p结点的后继
    p->next=s;						//s连到p之后
    ElemType temp=p->data; 			//交换数据域部分
    p->data=s->data;
    S->data=temp;
    return true;
}
~~~

主函数：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
	insertVaule(link,3,66); 		//按号插入 
	printlist(link);				//链表遍历 	
}  
~~~

[指定结点前插操作：](https://image.sybblogs.fun/img-common/202305181901601.png)

<img src="https://image.sybblogs.fun/img-common/202305181901601.png" alt="指定结点前插操作" style="zoom:43%;" />

> 输入：1，2，3，4，5
>
> 运行结果：1，2，3，66，4，5

### 4.3 单链表的删除

通过按照输入序号删除对应结点，其原理和上面的插入类似。

~~~C++
//按序号删除
bool deletaList(linkList &l,int number){
    int i=0;
    lNode *p=l,*tail;				//tail指针存放的要删除的结点
    if(number<=0){
        return 0;
    }
    while(p!=NULL&&i<number-1){		//找到删除结点的前一个结点
        p=p->next;
        i++;
    }
    tail=p->next;					//将tail指向要删除结点地址
    p->next=tail->next;				//将前一个结点指针域指向被删除结点后一个结点
    free(tail);						//释放要删除结点
    return 1;
} 
//删除指定结点p
bool DeleteNode (LNode *p){
    if (p==NULL) return false;
    LNode *q=p->next;				//令q指向*p的后继结点
    p->data=p->next->data; 			//和后继结点交换数据域
    p->next=q->next;				//将*q结点从链中“断开”
    free(q);						//释放后继结点的存储空间
    return true;
}
~~~

主函数代码：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
	deletaList(link,3);				//按序号删除
	printlist(link);				//链表遍历 	
}  
~~~

关于删除指定节点p，其本质就是将p的后继结点复制给p结点，再释放后继结点，并将p结点重新指向下一个结点。这种方法有个局限性，就是我们在删除最后一个结点时，由于后一个结点为null所以程序会出错，我们就只能使用传统办法循环一个个找了。

> 输入：1，2，3，4，5
>
> 运行结果：1，2，4，5

### 4.4 链表的查找

最常用的查找是按值查找和按序号查找

~~~C++
//按值查找
bool findVaule(linkList &l,int d){	//d代表要查找的值
	lNode *p=l;
	while(p!=NULL){
		if(p->data==d){				//如果找到要查找的值d返回1
			return 1;
		}
		p=p->next;
	}
	return 0;
	
} 

//按号查找
int findNumber(linkList &l,int num){//表示返回第num个结点的值
	int i=0;
	if(num<=0){
		return 0;
	}
	lNode *p=l;
	while(p!=NULL&&i<num){			//找到这个结点，并返回结点值域中的值
		p=p->next;
		i++;
	}
	return p->data;
} 
//对单链表进行打印 
void printlist(linkList &l){
	while(l->next!=NULL){
		cout<<l->next->data<<endl;
		l=l->next;
	}
}
~~~

主函数：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
    int resultVaule,resultNumber;
	resultVaule=findVaule(link,2);	//按值查找 
	cout<<resultVaule<<endl;
	resultNumber=findNumber(link,3);//按序号查找 
	cout<<resultNumber<<endl;
	printlist(link);				//链表遍历 	
}  
~~~

### 4.5 习题：链表的逆置

逆置方法有很多种：

方法一：可以通过遍历链表元素，用头插法将遍历元素值插入新链表。

~~~C++
#include <bits/stdc++.h>
#include<string>
using namespace std;
typedef struct lNode{
	int data;
	lNode *next;
}lNode,*linkList;

//初始化
bool initLink(linkList &l){
	l=(lNode*)malloc(sizeof(lNode));
	if(l==NULL) return 0;
	l->next=NULL;
	return true;
} 

//尾插法
bool insertTail(linkList &l){
	int i=0;
	lNode *head,*tial=l;
	while(i!=999999){
		cin>>i;
		if(i!=999999){
			head=(lNode*)malloc(sizeof(lNode));
			head->data=i;
			tial->next=head;
			tial=head;
		}
	}
	tial->next=NULL;
	return 1;
}
 
 //头插法实现逆序
lNode* reverseLink(linkList &l){
	lNode *p,*r;
	initLink(r);
	while(l->next!=NULL){				//遍历链表取值
		p=(lNode*)malloc(sizeof(lNode));
		p->data=l->next->data;			//头插法赋值给新链表
		p->next=r->next;
		r->next=p;
		l=l->next;						
	}
	return r;
} 
 
 //打印链表
 void printLink(linkList &l){
 	while(l->next!=NULL){
 		cout<<l->next->data<<endl;
 		l=l->next;
	 }
 } 
 
int main(){
	lNode *link,*result;
	initLink(link);						//初始化链表 
	insertTail(link);					//尾插法创建列表
	result=reverseLink(link);			//用头插法实现逆序
	printLink(result);
}
~~~

> 输入值：1，23，4，5
>
> 运行结果：5，4，23，1

==方法二==：

方法是先让新结点`p=l->next`，

再让头节点指针`l->next=NULL`断开链表。

用结点`lNodeNext=p`来记录结点`p`，`p=p->next`指向下一轮待逆置的结点。

最后让`lNodeNext`用头插法插在`l`链表内即可

<img src="https://image.sybblogs.fun/img-common/202310140009673.png" alt="链表逆置" style="zoom: 25%;" />

<img src="https://image.sybblogs.fun/img-common/202310140010866.png" alt="链表逆置2" style="zoom:25%;" />

~~~C++
//链表的逆置
void changeList(linkList &l){ 
	lNode *lTem=l,*p=l->next,*qNextLNode;
	lTem->next=NULL;
	while(p!=NULL){
		qNextLNode=p;
		p=p->next; 
		qNextLNode->next=lTem->next;
		lTem->next=qNextLNode;
	}

} 

int main(){
	linkList link6;
	initList(link6);
	//链表的逆置
	cout<<"请输入一组链表进行逆置:"<<endl;
	createList(link6);
	cout<<"逆置后的链表为:"<<endl;
	changeList(link6);
	myPrint(link6);
}
~~~

> 输入值：1，23，4，5
>
> 运行结果：5，4，23，1

## 5. 双链表

由于单链表只能指向下一个指针，而双链表同时指向前驱节点和后继结点。

### 5.1 双链表的初始化

~~~C++
typedef struct DNode{						//定义双链表结点类型
    ElemType data;							//数据域
    struct DNode *prior,*next;				//前驱和后继指针
}DNode, *DLinklist;

//初始化双链表
bool InitDLinkList(DLinklist &L){
    L = (DNode *) malloc(sizeof (DNode)); 	//分配一个头结点
    if (L==NULL) return false;				//内存不足， 分配失败
    L->prior = NULL;						//头结点的prior永远指向NULL
    L->next = NULL;							//头结点之后暂时还没有节点
    return true;
}
void testDL inkList() {						//初始化双链表
    DLinklist L;
    InitDLinkList(L);
    //后续代码...
}
~~~

同样的这里的`DNode`和`DLinklist`等价，只是为了区分链表`(DLinklist)`和结点`(DNode)`

### 5.2 双链表的插入

~~~C++
//在p结点之后插入s结点.
bool InsertNextDNode(DNode *p，DNode *s){
    if (p==NULL||s==NULL) return false;		//非法参数
    s->next=p->next;
    if (p->next != NULL) 
        p->next->prior=s; 					//如果p结点有后继结点
    s->prior=p;
    p->next=s;
    return true;
}
~~~

[双链表的插入：](https://image.sybblogs.fun/img-common/202305221637350.png)

<img src="https://image.sybblogs.fun/img-common/202305221637350.png" alt="双链表的插入" style="zoom: 50%;" />

[双链表最后一个节点插入：](https://image.sybblogs.fun/img-common/202305221638889.png)

<img src="https://image.sybblogs.fun/img-common/202305221638889.png" alt="双链表的最后一个节点插入" style="zoom:50%;" />

### 5.3 双链表的删除

同样和之前但链表删除方法一致。

~~~C++
//删除p结点的后继结点q
bool DeleteNextDNode(DNode *p){
    if ( p==NULL) return false;
    DNode *q = p->next; 			//找到p的后继结点q
    if (q==NULL) return false; 		//p没有后继
    p->next=q->next;
    if (q->next !=NULL)				//q结点不是最后一个结点
        q->next->prior=p;
    free(q);						//释放结点空间
    return true; 
}

//双链表的销毁
void DestoryL ist(DLinklist &L){	//循环释放各个数据结点
    while (L->next != NULL)
        DeleteNextDNode(L);			//删除每个结点的后一个结点
    free(L);						//释放头结点
    L=NULL;							//头指针指向NULL   							
}
~~~

[双链表的总结：](https://image.sybblogs.fun/img-common/202305221701942.png)

<img src="https://image.sybblogs.fun/img-common/202305221701942.png" alt="双链表的总结" style="zoom:50%;" />

## 6. 循环链表

循环链表就是在单链表(双链表)的基础上讲最后一个结点指向头节点。

特点是：从一个结点出发可以找到其他任何一个结点。常用于对表头和表尾操作频率高的情况下。

### 6.1 循环单链表的初始化

[循环单链表结构：](https://image.sybblogs.fun/img-common/202305221703001.png)

<img src="https://image.sybblogs.fun/img-common/202305221703001.png" alt="循环链表" style="zoom:50%;" />

~~~C++
typedef struct LNode{						//定义单链表结点类型
    ElemType data;							//每个节点存放一个数据元素
    struct LNode *next;						//指针指向下一个节点
}LNode, *LinkList;
//初始化一个循环单链表
bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode)); 	//分配一个头结点
    if (L==NULL) return false;				//内存不足,分配失败
    L->next = L;							//头结点next指向头结点本身
    return true; 
}
~~~

其他操作基本与前面一致。注意判断最后一个结点时，应该判断是否指向头节点。

### 6.2 循环双链表的初始化

循环链表：表头结点的prior指向表尾结点；表尾结点的next指向头结点。

循环双链表不需要考虑表头表尾的界限操作。

[循环双链表结构：](https://image.sybblogs.fun/img-common/202305221713236.png)

<img src="https://image.sybblogs.fun/img-common/202305221713236.png" alt="循环双链表" style="zoom:50%;" />

~~~C++
typedef struct DNode{						//定义双链表结点类型
    ElemType data;							//数据域
    struct DNode *prior,*next;				//前驱和后继指针
}DNode, *DLinklist;

//初始化空的循环双链表
bool InitDL inkList(DLinklist &L){
    L = (DNode *) malloc(sizeof(DNode)); 		//分配一个头结点
    if (L==NULL) return false;					//内存不足,分配失败
    L->prior = L;								//头结点的prior指向头结点
    L->next = L;								//头结点的next指向头结点
    return true;
}
~~~

其他操作

~~~C++
//在p结点之后插入s结点
bool InsertNextDNode(DNode *p,DNode *s){
    s->next=p->next; 							//将结点*s插入到结点*p之后
    p->next->prior=s;
    S->prior=p;
    p->next=s;
}

//删除p的后继结点q
p->next=q->next;
q->next>prior=p;
free(q);
~~~

[循环链表总结：](https://image.sybblogs.fun/img-common/202305221739830.png)

<img src="https://image.sybblogs.fun/img-common/202305221739830.png" alt="循环链表总结" style="zoom:50%;" />

## 7. 静态链表

与单链表不同的是静态链表是分配一整片连续的内存空间，各个结点集中安置。

静态链表每个数据元素4B，每个游标4B ( 每个结点共8B)。设起始地址为addr，e1的存放地址为addr + 8*2。2是接下来要寻找的数组下标。

适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景(如操作系统的文件分配表FAT)。

[静态链表结构：](https://image.sybblogs.fun/img-common/202305221746658.png)

<img src="https://image.sybblogs.fun/img-common/202305221746658.png" alt="静态链表" style="zoom:50%;" />

### 7.1 静态链表的初始化

~~~C++
#include<stdio.h>
#define maxsize 30
 
typedef char elemtype;
typedef struct{
	int cur;
	elemtype data;
}slink,slinklist[maxsize];

void initspace_sl(slink *space){//将数据各分量链接成一个备用链表，space[0]代表头指针
	int i;
	for(i=0;i<maxsize-1;i++){
		space[i].cur=i+1;		//下标为i结点的后继为下标是i+1的结点
	}
	space[maxsize-1].cur=0;		//0表示空指针
} 
~~~

[初始化静态链表：](https://image.sybblogs.fun/img-common/202305221803193.png)

<img src="https://image.sybblogs.fun/img-common/202305221803193.png" alt="初始化静态链表" style="zoom: 50%;" />

## 8. 顺序表和链表的比较

两种表的适用场景：

1. 表长难以预估、经常要增加$/$删除元素用链表(订餐系统)。
2. 表长可预估、查询(搜索)操作较多用顺序表(课堂点名)。

逻辑结构：顺序表和链表都属于线性结构。

存储结构：

- 顺序表优点：拥有随机存取的特点，存储密度高。缺点：大片连续空间分配不方便，改变容量不方便。
- 链表优点：离散的小空间分配方便，改变容量方便。缺点：不可随机存储，存储密度低。

基本操作比较：

- 两种表的创建：

  - 顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量;若分配空间过大，则浪费内存资源。

    静态分配：容量不可更改。

    动态分配：容量可以更改，但需要移动大量元素，时间代价高。

  - 链表：只需分配一个头结点(也可以不要头结点，只声明一个头指针)，之后方便拓展

- 两种表的销毁：

  - 链表：依次删除各个结点(free)

  - 顺序表：需要讲$length=0$。静态分配方式，系统会自动回收。动态分配：需要手动销毁(free)。

    注意：malloc和free函数必须成对出现。

- 两种表的增加和删除

  - 顺序表：插入$/$删除元素要将后续元素都后移$/$前移。虽然在时间复杂度上和链表一致，但数据元素大，移动时间成本就高。

  - 链表：插入$/$删除元素只需修改指针即可。查找元素时间低。

- 两种表的查找

  - 顺序表：按位查找时间复杂度为$O(1)$。按值查找时间复杂度$O(n)$，若表内元素有序可以通过算法，可在$O(\log_2n)$时间内找到。
  - 链表：按位查找和按值查找时间复杂度都为$O(1)$

在遇到一个开放式问题探讨时：从逻辑结构，存储结构和基本操作这三方面回答。

# 四. 栈

栈和线性表的结构很相似，但栈只允许在一端进行插入或删除操作的线性表。栈和我们生活种摞起来的盘子类似。

[摞起来的盘子：](https://image.sybblogs.fun/img-common/202305231625768.png)

<img src="https://image.sybblogs.fun/img-common/202305231625768.png" alt="盘子" style="zoom:43%;" />

[栈结构和常见术语：](https://image.sybblogs.fun/img-common/202305231627448.png)

<img src="https://image.sybblogs.fun/img-common/202305231627448.png" alt="栈结构和术语" style="zoom:43%;" />

进栈顺序：$a_1\longrightarrow a_2\longrightarrow a_3\longrightarrow a_4\longrightarrow a_5$

出战顺序：$a_5\longrightarrow a_4\longrightarrow a_3\longrightarrow a_2\longrightarrow a_1$

栈特点：后进(push)先出(pop)(LIFO)

栈的基本操作：创建、销毁、增加、删除、查询、判空。

## 1. 栈的顺序存储实现

### 1.1 栈的定义

和线性表类似，我们先要用结构体初始化栈。

~~~C++
#define MaxSize 10			//定义栈中元素的最大个数
typedef struct{
    ElemType data [MaxSize];//静态数组存放栈中元素
    int top;				//栈顶指针,每次入栈值+1,永远指向栈顶
} SqStack;

//初始化栈
void InitStack(SqStack &S){
    S.top=-1;				//初始化栈顶指针   
}

//判断栈空
bool StackEmpty(SqStack S){
    if(S. top==-1)
        return true;		//栈空
    else      
        return false;	 	//不空
}
~~~

### 1.2 栈的增加

~~~C++
//新元素入栈
bool Push(SqStack &s, ElemType x){
    if(s.top==MaxSize-1)
        return false;		//栈满，报错
    s.top = s.top+1;		//指针先加1       
    s.data[s.top]=x;		//新元素入栈    
    //上面两句等价于：s.data[++s.top]=x;
    return true;
}
~~~

### 1.3 出栈操作

~~~C++
//出栈操作
bool Pop(SqStack &S, ELemType &x){
    if(S.top==-1) 			//栈空,报错       
        return false;
    x=S.data[S.top]; 		//栈顶元素先出栈   
    S.top=S.top-1; 			//指针再减l
    //等价于：x=S.data[s.top--];
    return true;
}
~~~

### 1.4 共享栈

通过上面代码实现我们可以发现栈的一个明显缺点是栈的大小不可变，可以通过链式栈或者分配大空间来解决这个问题。但分配大片空间会导致空间冗余，这时候可以用共享栈解决。

共享栈就是两个栈共享一片空间。

共享栈实现：

~~~C++
#define MaxSize 10
//定义栈中元素的最大个数
typedef struct{
    ElemType_ data [MaxSize];	//静态数组存放栈中元素
    int top0;					//0号栈栈顶指针	
    int top1;					//1号栈栈顶指针
} ShStack;

//初始化栈
void InitStack(ShStack &S){
    S.top0=-1;					//初始化栈顶指针    
    S.top1=MaxSize;
}
~~~

[共享栈结构：](https://image.sybblogs.fun/img-common/202305231703776.png)

<img src="https://image.sybblogs.fun/img-common/202305231703776.png" alt="共享栈" style="zoom:43%;" />

共享栈两个top指针一个从下网上存储，一个从上往下存储。判断栈满的条件是：`top0 + 1 == top1`

## 2. 链栈

定义：用链式存储结构实现的栈

实现：实际上我们用头插法建立的单链表就是一个链栈。

### 2.1 链栈初始化

~~~C++
typedef struct Linknode{
    ElemType data;				//数据域
    struct L inknode *next;		//指针域
} *LiStack;						//栈类型定义

//初始化 
bool initStack(LiStack &l){
	l=(LiStack)malloc(sizeof(LiStack));//带头节点
	if(l==NULL) return false;
	l->next=NULL;
	return true;
}
~~~

### 2.2 链栈的入栈

用头插法入栈

~~~C++
bool pushStack(LiStack &l,int e){
    if(l==NULL) return false;
    LiStack p;
    p=(LiStack)malloc(sizeof(LiStack));
    p->data=i;							//头插法
    p->next=l->next;
    l->next=p;
    return true;
}  
~~~

### 2.3 链栈的出栈

链栈的出栈操作，栈顶指针是第一个指针（头指针的下一个），所以将其往后挪一位就好了。

~~~C++
//出栈
bool Pop(LiStack &l){
    LiStack p;
    if(l->next==NULL){
        return false;
    }else{
        p=l->next;			//p指向第一个结点(头结点后继结点)
		l->next=p->next;	//往后挪一位
        free(p);
        return true;
    }
}
~~~

### 2.4 链栈打印

最后其它操作和单链表一致。

~~~C++
void printStack(LiStack &l){
	while(l->next!=NULL){
		cout<<l->next->data<<endl;
		l=l->next;
	}
} 
~~~

## 3. 栈的应用—括号匹配

括号匹配就是相邻括号成对出现。如：$[],\{\},()$.

具体思路是用栈实现括号匹配：

1. 依次扫描所有字符，遇到左括号入栈，遇到右括号存入数组(也可以不用数组，当输入右括号直接和栈中括号匹配)
2. 查看是否匹配。匹配失败情况:
   ①左括号单身②右括号单身③左右括号不匹配

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 20
using namespace std;

static int couts=0;				//全局静态变量，用于记录数组中的右括号数 
typedef struct Linknode{
    char data;				
    struct Linknode *next;		
} *LiStack;						

//初始化
bool initLiStack(LiStack &l){
	l=(LiStack)malloc(sizeof(LiStack));
	if(l==NULL) return false;
	l->next=NULL;
	return true;
} 

//入栈
bool pushStack(LiStack &l,char s){
	LiStack p;
	p=(LiStack)malloc(sizeof(LiStack));
	if(p==NULL) return false;
	p->data=s;
	p->next=l->next;
	l->next=p;
	return true;
}

//出栈 
char popStack(LiStack &l){					
	LiStack p;
	char s;
	if(l->next==NULL) {
		cout<<"栈空"<<endl;
		return 'E';	
	}
	s=l->next->data;
	p=l->next;
	l->next=p->next;
	free(p);
	return s;	
}

//区分左右括号
void bracketLeftRight(LiStack &l,char *p,char str){	//p表述指针数组，str用户输入值 
 	if(str=='('||str=='{'||str=='['){				//如果是左括号，放入栈中 
 		pushStack(l,str);
	 }else if(str==')'||str=='}'||str==']'){		//如果是右括号，放入数组中，全局变量couts+1 
	 	p[couts]=str;
	 	couts+=1;
	 }else{
	 	cout<<"输入值不合法"<<endl;
	 } 
 }
 
 //判断括号是否对应
 bool  bracketCheck(LiStack &l,char *p){
 	char bracket;
 	for(int j=0;j<couts;j++){
 		bracket=popStack(l);
 		if(bracket=='E') return false; 				//栈空，配对失败 
 		if(p[j]==')'&&bracket!='(') return false; 	//三种括号匹配 
 		if(p[j]==']'&&bracket!='[') return false;
 		if(p[j]=='}'&&bracket!='{') return false;
	 }
 }

int main(){
	LiStack l;	
	char str,c[MaxSize]={0},*p=c;					//str:接受输入值，c[]存放右括号,p数组指针传递 
	initLiStack(l);									//初始化 
	while(str!='!'){								//输入'!'结束输入 
		cin>>str;
		if(str!='!'){
			bracketLeftRight(l,p,str);				//每输入一个值判断左右括号 
		}
	}
	if(bracketCheck(l,p)>0){
		cout<<"括号全部匹配"<<endl; 					//括号全部匹配 
	}else{
		cout<<"括号不匹配"<<endl; 					//括号不匹配 
	} 
} 
~~~

[括号匹配思路：](https://image.sybblogs.fun/img-common/202305262025840.png)

<img src="https://image.sybblogs.fun/img-common/202305262025840.png" alt="栈练习--括号匹配" style="zoom:33%;" />

## 4. ==栈的应用—表达式求值==

表达式通常由三部分组成：①操作数②运算符③界限符(括号等)

常见表达式有以下几种：

1. 中缀表达式：$a+b$、$a\backslash b$、$a+b-c$、$a+b-c*d$

   特点：运算符在两个数中间

2. 后缀表达式(逆波兰表达式)：$ab+$、$ab\backslash$、$ab+c-$、$ab+cd*-$

   特点：运算符在两个操作数后面

3. 前缀表达式(波兰表达式)：$+ab$、$\backslash ab$、$-+abc$、$-+ab*cd$

   特点：运算符在操作数前面

### 4.1 中缀表达式转后缀方法

遵循==左优先==原则。

①确定运算顺序

②选择下一个运算符，按照$[左操作数$ $右操作数$ $运算符]$的方式组合成一个新的操作数

③如果还有运算符没被处理，继续②

如$中缀表达式((15÷(7-(1+1)))\times3)-(2+(1+1))$转换为后缀步骤：

1. $1$ $1$ $+$
2. $7$ $1$ $1$ $+$ $-$
3. $15$ $7$ $1$ $1$ $+$ $-$ $÷$
4. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$
5. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $1$ $1$ $+$
6. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $2$ $1$ $1$ $+$ $+$
7. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $2$ $1$ $1$ $+$ $+$ $-$

### 4.2 后缀表达式计算

通过上面我们将中缀表达式转为后缀表达式$15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $2$ $1$ $1$ $+$ $+$ $-$

计算后缀表达式也不难：从**左往右扫描**，每遇到**一个运算符**，就让运算符前面最近的两个操作数执行对应运算
合体为一个操作数。注意：两个操作数的左右顺序。

步骤：

1. 第一个运算符是$+$，先算$1+1$
2. 第二个运算符是$-$，$7-2$
3. 第三个运算符是$÷$，$15÷5$
4. 第四个运算符是$\times$，$3\times3=9$
5. 第五个运算符是$+$，$1+1$
6. 第六个运算符是$+$，$2+2=4$
7. 最后一个运算符是$-$，$9-4$得最后结果

[后缀表达式计算图示：](https://image.sybblogs.fun/img-common/202306151824409.png)

<img src="https://image.sybblogs.fun/img-common/202306151824409.png" alt="后缀表达式计算" style="zoom:33%;" />

### 4.3 代码实现

代码实现需要遵循以下几点：

①遇到操作数直接入栈

②遇到界限符'$($'，直接入栈，遇到'$)$'，依次弹出栈内的运算符，直到栈顶元素为'$($'。

③运算符运算弹出规则，应该是：==操作符栈顶运算符大于或等于当前输入运算符==则弹出栈顶操作符。数字栈依次弹出两个数字$num1,num2$，运算是$num2+-...num1$

$\Large 例:计算中缀表达式((15÷(7-(1+1)))\times3)-(2+(1+1))$

Ⅰ.先分析运算符生效顺序，如下图:

<img src="https://image.sybblogs.fun/img-common/202306081849449.png" alt="运算符生效顺序" style="zoom:33%;" />

Ⅱ. 从左到右依次扫描入栈:操作符栈(charStack),操作数栈(numStack)

Ⅲ. 定义操作符优先级：$+/-$为$A$，$\times/÷$为$B$，$($为$C$.

Ⅳ. 进行扫描运算：

> ①输入'$($'，由于操作符栈为$NULL$，直接入栈。
>
> ②输入'$($'，操作符栈不为$NULL$，且优先级等于操作栈顶的元素'('，但由于括号不参与运算，所以直接入栈。
>
> ③输入$15$，数字直接入栈。
>
> ④输入'$÷$'，由于'÷'优先级低于操作符栈顶元素'('，直接入栈。
>
> ⑤输入'$($'，括号直接入栈。
>
> ⑥输入$7$，数字直接入栈。
>
> ⑦输入'$-$'，'$-$'y优先级低于操作符栈顶元素'$($'，入栈。
>
> ⑧输入'$($'，直接入栈
>
> ⑨输入$1$，入栈
>
> ⑩输入'$+$'，'$+$'优先级低于操作符栈顶元素'$($'，入栈
>
> ⑪输入$1$，入栈。此时栈中元素情况如下：

[操作符栈和操作数栈：](https://image.sybblogs.fun/img-common/202306131739136.png)

<img src="https://image.sybblogs.fun/img-common/202306131739136.png" alt="运算栈" style="zoom:33%;" />

> ⑫输入'$)$'，栈顶操作符一次出栈直到为NULL或者为'$($'。此时弹出操作符栈顶元素'$+$'，弹出操作数栈前两个元素$1,1$。之后运算$1+1$得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131741661.png" alt="运算栈2" style="zoom:33%;" />

> ⑬输入')'，再次重复上面，弹出操作符栈顶元素'$-$'，弹出操作数栈两个元素$2,7$，运算$7-2$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131742019.png" alt="运算栈3" style="zoom:33%;" />

> ⑭输入'$)$'，重复上面过程，弹出操作符栈顶元素'$÷$'，弹出操作数栈两个元素$5,15$，运算$15÷5$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131743466.png" alt="运算栈4" style="zoom:33%;" />

> ⑮输入'$\times$'，此时操作符栈顶元素为'$($'，优先级低于栈顶元素，直接入栈。
>
> ⑯输入'$3$'，直接入栈

<img src="https://image.sybblogs.fun/img-common/202306131744115.png" alt="运算栈5" style="zoom:33%;" />

> ⑰输入'$)$'，弹出操作符栈顶元素'$\times$'，弹出操作数栈两个元素$3,3$，运算$3\times3$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131745892.png" alt="运算栈6" style="zoom:33%;" />

> ⑱输入'$-$'，此时操作栈为NULL，直接入栈
>
> ⑲输入'$($'，入栈
>
> ⑳输入$2$，入栈
>
> ㉑输入'$+$'，优先级小于操作栈顶元素'$($'，入栈
>
> ㉒输入'$($'，直接入栈
>
> ㉓输入$1$，入栈
>
> ㉔输入'$+$'，优先级低于操作栈栈顶元素'$($'，入栈
>
> ㉕输入$1$，入栈

<img src="https://image.sybblogs.fun/img-common/202306131747104.png" alt="运算栈7" style="zoom:33%;" />

> ㉖输入'$)$'，弹出操作符栈顶元素'$+$'，弹出操作数栈两个元素$1,1$，运算$1+1$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131748232.png" alt="运算栈8" style="zoom:33%;" />

> ㉗输入'$)$'，弹出操作符栈顶元素'$+$'，弹出操作数栈两个元素$2,2$，运算$2+2$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131749733.png" alt="运算栈9" style="zoom:33%;" />

> ㉘弹出操作栈顶元素'$-$'，弹出操作数栈两个元素进行最后运算，得到结果为$5$

详细代码

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 20
using namespace std;

char arrGrad(char s){
	switch(s){
		case '+':
			return 'A';
		case '-':
			return 'A';
		case '*':
			return 'B';
		case '/':
			return 'B';
		default :
			return 'C'; 
	}
}

//存放运算符 
typedef struct linkC{
    char data;
	char grad;				
    struct linkC *next;		
} *linkChar;

//存放运算数 
typedef struct linkN{
    int data;				
    struct linkN *next;		
} *linkNum;	 

bool initCharNum(linkChar &c,linkNum &n,char (&s)[MaxSize]){
	memset(s,'\0',sizeof(s));
	c=(linkChar)malloc(sizeof(linkChar));
	n=(linkNum)malloc(sizeof(linkNum));
	if(c==NULL||n==NULL) return false;
	c->next=NULL;
	n->next=NULL;
	return true;
}

//操作符入栈 
bool pushChar(linkChar &c,char s){
	linkChar p;
	p=(linkChar)malloc(sizeof(linkChar));
	if(p==NULL) return false;
	if(s=='+'|s=='-'){
		p->data=s;
		p->grad=arrGrad(s);
		p->next=c->next;
		c->next=p;
		return true;
	}else if(s=='*'|s=='/'){
		p->data=s;
		p->grad=arrGrad(s);
		p->next=c->next;
		c->next=p;
		return true;
	}else if(s=='('){
		p->data=s;
		p->grad=arrGrad(s);
		p->next=c->next;
		c->next=p;
		return true;
	}else{
		return false;
	}	
}

//操作数入栈 
bool pushNum(linkNum &n,int e){
	linkNum p;
	p=(linkNum)malloc(sizeof(linkNum));
	if(p==NULL) return false;
	p->data=e;
	p->next=n->next;
	n->next=p;
	
	return true;
}

//操作符出栈
char popChar(linkChar &c){
	char s;
	linkChar p;
	if(c->next==NULL) return 'E';
	s=c->next->data;
	p=c->next;
	c->next=p->next;
	free(p);
	return s;
}

//操作数出栈
int popNum(linkNum &n){
	int i;
	linkNum p;
	if(n->next==NULL) return 0;
	i=n->next->data;
	p=n->next;
	n->next=p->next;
	free(p);
	return i;
}

//获取操作符栈顶元素
char selectChar(linkChar &c,int e){
	if(e) return c->next->data;
	return c->next->grad;
}

//运算
void ope(linkChar &c,linkNum &n){
	char popchar=popChar(c);
	int num1=popNum(n);
	int num2=popNum(n);
	cout<<num2<<popchar<<num1<<endl;
	switch(popchar){
		case '+':
			pushNum(n,num2+num1);
			break;
		case '-':
			pushNum(n,num2-num1);
			break;
		case '*':
			pushNum(n,num2*num1);
			break;
		case '/':
			pushNum(n,num2/num1);
			break;
	}
} 

void printStack(linkChar &c,linkNum &n){
	while(c->next!=NULL){
		cout<<"data:"<<c->next->data<<"grad::"<<c->next->grad<<endl;
		c=c->next;
	}
	while(n->next!=NULL){
		cout<<"result:"<<n->next->data<<endl;
		n=n->next;
	}
}

//字符转数字 
int opeNum(char (&s)[MaxSize]){
	int couts,sum=0;
	for(int i=0;i<strlen(s);i++){
		couts=s[i]-'0';
		for(int j=i;j<strlen(s)-1;j++){
			couts=couts*10;
		}
		sum+=couts;
	}
	memset(s,'\0',sizeof(s));
	return sum;
}
int con=0;

//区分操作数和操作符
bool isCharNum(linkChar &c,linkNum &n,char s,char (&chrs)[MaxSize]){
	int i;
	if(s>='0'&&s<='9'){													//数字直接存入操作数栈 
		chrs[con++]=s;
		return true;
	}else if(s=='+'||s=='-'||s=='*'||s=='/'||s=='('||s=='!'){			//判断是否是操作符 
		if(strlen(chrs)>0) {
			i=opeNum(chrs);
			pushNum(n,i);
			con=0;
		}
		if(c->next==NULL){												//操作符栈为空，直接入栈 
			pushChar(c,s);
			return true;
		}
		if(selectChar(c,0)>=arrGrad(s)&&selectChar(c,1)!='('){			//不为空且栈顶操作符优先级大于等于当前所输入操作符元素,并且不是"("
			while(c->next!=NULL&&c->next->grad>=arrGrad(s)&&c->next->data!='('){			//取出操作符进行运算操作 
				ope(c,n);
			} 
		} 
		pushChar(c,s);													//将当前输入操作符压入栈顶 
		return true;
	}else if(s==')'){	
		if(strlen(chrs)>0||s=='!') {
			i=opeNum(chrs);
			pushNum(n,i);
			con=0;
		}															//如果当前输入是")",弹出所有操作符进行运算,直到碰到"(" 
		while(selectChar(c,1)!='('){
			ope(c,n);
		}
		popChar(c);														//弹出栈顶的"(" 
		return true;
	}else{
		return false;
	}
} 

int main(){
	char chr,chrs[MaxSize];
	linkChar c;
	linkNum n;
	initCharNum(c,n,chrs);
	while(chr!='!'){
		cin>>chr;
		isCharNum(c,n,chr,chrs);
	}
	ope(c,n);
	printStack(c,n);
} 
~~~

## 5. 栈在递归中的应用

先给出一段代码，看一下函数调用背后过程

~~~C++
void main(){
    int a,b,c;
    func1(a,b);
    c=a+b;
    ...
}
void func1(int a,int b){
    int x;
    func2(x);
    x=x+10086;
    ...
}
void func2(int x){
    int m,n;
    ...
}
~~~

主函数用执行第一句代码后会在栈中存放$a,b,c$的地址

[栈递归中应用：](https://image.sybblogs.fun/img-common/202306172002005.png)

<img src="https://image.sybblogs.fun/img-common/202306172002005.png" alt="栈递归中应用" style="zoom: 50%;" />

接着执行func1函数所对应代码，当执行func1时，会将后面应该执行代码，这里是表达式`c=a+b`地址同样压入栈中，图示如下(表达式地址用$\#1$代替)

<img src="https://image.sybblogs.fun/img-common/202306172005240.png" alt="栈递归中应用2" style="zoom: 50%;" />

同样func2执行过程同上一步，表达式`x=x+10086`地址假设为$\#2$

<img src="https://image.sybblogs.fun/img-common/202306172009314.png" alt="栈递归中应用3" style="zoom:45%;" />

执行完func2函数后，之后弹栈，根据栈顶地址，执行$\#2$对应代码(func1)。接着再弹栈执行$\#1$对应代码，即主函数中`c=a+b`。

以上就是递归基本原理。适合用递归算法解决是：可以把原始问题转换为属性相同，但规模较小的问题。

实现递归两个重要条件：递归表达式，递归边界条件。

[阶乘问题：]()

<img src="https://image.sybblogs.fun/img-common/202306172022900.png" alt="阶乘问题" style="zoom:50%;" />

上面代码当执行到第10层时，$n=1$返回$1$，弹栈；执行第9层代码此时$n=1$，表达式就是`2*1`；之后以此类推。

上面也可以看出递归缺点就是非常占用栈空间，所以太多层递归可能会导致栈溢出。

# 五. 队列

队列是只允许在队尾一端插入(入队)，在队头一端删除(出队)的数据结构。

特点：先进入先出(FIFO)。

栈的基本操作：创建、销毁、增加、删除、查询、判空。

## 1. 队列的顺序实现

### 1.1 队列初始化

~~~C++
typedef struct Linknode{
    int data[MaxSize];			//数据域
    int front,rear;				//队头指针和队尾指针 
    int size;					//记录队列大小
} sqQueue;						//队列 

//初始化
bool initQueue(sqQueue &s){
	s.front=0;
	s.rear=0;
	s.size=0;
} 
~~~

### 1.2 入列

~~~C++
//入列 
bool insertQueue(sqQueue &s,int e){
	if(s.size==MaxSize-1) return false;	//判断队列是否已满
	s.data[s.rear]=e;					//值赋给尾指针所指向的位置
	s.rear=(s.rear+1)%MaxSize;			//尾指针+1取余变为循环队列
	s.size+=1;							//队列元素个数+1
	return true;
} 
~~~

上面第五行取余操作，可以将对列变为循环队列。

[循环队列结构图：](https://image.sybblogs.fun/img-common/202305251735432.png)

<img src="https://image.sybblogs.fun/img-common/202305251735432.png" alt="循环队列" style="zoom:33%;" />

### 1.3 出列

~~~C++
//出列 
bool popQueue(sqQueue &s,int &e){
	if(s.size==0) return false;		//判断队列是否为空
	e=s.data[s.front];				//将头指针指向值赋值给e
	s.front=(s.front+1)%MaxSize;	//头指针往后移一位，取余变为循环队列
	s.size-=1;						//队列元素个数-1
	return true;
} 
~~~

和上面入列一样，这一队列变为循环队列，存储数据和读取数据更为方便。

### 1.4 队列元素个数

~~~C++
//元素个数
void printQueue(sqQueue s){
    cout<<(s.rear-s.front+MaxSize)%MaxSize<<endl;
} 
~~~

执行上面代码会实现当前队列中的元素个数。同时队列`s.size`中保存的也是元素个数。即
`(s.rear-s.front+MaxSize)%MaxSize<<endl~s.size`

### 1.5 其他情况

上面的都是队头队尾指针初始化时，指向同一位置，但有时候会碰见队尾指针在队尾情况

[队尾指针在队尾情况：](https://image.sybblogs.fun/img-common/202305251750011.png)

<img src="https://image.sybblogs.fun/img-common/202305251750011.png" alt="队尾指针在队尾" style="zoom: 50%;" />

此时入队操作有所改变，我们要先让尾指针向后移一位，再进行插入。

~~~C++
//入列 
bool insertQueue(sqQueue &s,int e){
    s.rear=(s.rear+1)%MaxSize;			//尾指针+1取余变为循环队列
	s.data[s.rear]=e;					//值赋给尾指针所指向的位置	
	return true;
} 
~~~

而初始化方式也有所不同，让尾指针指向队尾元素，当第一次入队时通过取余操作，往后移动到第一位。

~~~C++
//初始化
bool initQueue(sqQueue &s){
	s.front=0;
	s.rear=MaxSize-1;				//尾指针指向尾部
} 
~~~

判空操作和判满操作也不同：

~~~C++
//判空
(s.rear+1)%MaxSize==s.front;
~~~

判满操作同上，除了`size`判满操作，我们也可以通过设置辅助遍历`tag`来记录上次是入队操作，还是出队操作。由于只有入队操作会让队满，而只有出队操作会让队空，所以当入队时设置`tag=1`，当出队时设置`tag=0`。

~~~C++
//通过tag方式判断队列已满
if((s.rear+1)%MaxSize==s.front&&s.tag==1)
~~~

## 2. 链式队列

### 2.1 链式队列的初始化

~~~C++
typedef struct Linknode{		//结点	
    int data;					
    struct Linknode *next;		
}linknode;						

typedef struct linkQueue{		//链式队列			
	linknode* front;			//头指针 
	linknode* rear;				//尾指针	 
}linkQueue;

//初始化
bool initQueue(linkQueue &q){
	//带头节点方式： 
	q.rear=(linknode* )malloc(sizeof(linknode));
	q.front=q.rear;
	q.front->next=NULL;
	//不带头结点方式:
	//q.front=NULL;
	//q.rear=NULL; 
} 
~~~

初始化创造两个结构体，第一个是结点，第二个存储链队列地址。

[带头结点初始化：](https://image.sybblogs.fun/img-common/202305251939775.png)

<img src="https://image.sybblogs.fun/img-common/202305251939775.png" alt="带头结点初始化方式" style="zoom: 50%;" />

[不带头结点初始化：](https://image.sybblogs.fun/img-common/202305251940579.png)

<img src="https://image.sybblogs.fun/img-common/202305251940579.png" alt="不带头结点初始化方式" style="zoom:50%;" />

### 2.2 链式队列的入队

~~~C++
//入队操作
bool insertQueue(linkQueue &q,int e){
	linknode *s=(linknode *)malloc(sizeof(linknode));
	s->data=e;
	s->next=NULL;
	//带头结点方式：
	//q.rear->next=s;				//新结点插入到rear之后
	//q.rear=s;						//修改表尾指针
	//不带头结点方式：
	if(q.front==NULL){				//条件成立，证明队列为NULL 
		q.front=s;					//头指着指向s 
		q.rear=s;					//尾指针指向s 
	} else{
		q.rear->next=s;				//否则不为空，尾指针域指向s 
		q.rear=s;					//尾指针指向s 
	}
} 
~~~

[带头结点入队：](https://image.sybblogs.fun/img-common/202305251941418.png)

<img src="https://image.sybblogs.fun/img-common/202305251941418.png" alt="带头结点入队" style="zoom:50%;" />

[不带头结点入队：](https://image.sybblogs.fun/img-common/202305251946648.png)

<img src="https://image.sybblogs.fun/img-common/202305251946648.png" alt="不带头结点入队" style="zoom:50%;" />

### 2.3 链式队列出队操作

- 带头结点出队

  ~~~C++
  //出队操作(带头结点)
  bool DeQueue(linkQueue &q, int &e){
  	if(q.front==q.rear) return false;	//空队
  	linknode *p=q.front->next;
  	e=p->data;							//用变量e返回队头元素
  	q.front->next=p->next; 				//修改头结点的 next 指针
  	if(q.rear==p)						//此次是最后一个结点出队
  		q.rear=q.front;					//修改rear 指针
  	free(p);							//释放结点空间
  	return true;
  }
  ~~~

  [带头结点出队操作：](https://image.sybblogs.fun/img-common/202305252000397.png)

  <img src="https://image.sybblogs.fun/img-common/202305252000397.png" alt="带头结点出队" style="zoom:50%;" />

  [带头最后一个结点出队：](https://image.sybblogs.fun/img-common/202305252001310.png)

  <img src="https://image.sybblogs.fun/img-common/202305252001310.png" alt="带头最后一个结点出队" style="zoom:50%;" />

  最后一个结点出队，实际上就是将队列再次变为空队列

- 不带头结点出队

  ~~~C++
  //不带头结点出队
  bool DeQueue(linkQueue &q, int &e){
      if(q.front==NULL ) return false;		//空队
      linknode *p=q.front;					//p指向此次出队的结点
      e=p->data;								//用变量x返回队头元素
      q.front=p->next;						//修改front 指针
      if(q.rear==p){							//此次是最后一个结点出队
          q.front = NULL;						//front指向NULL
          q.rear = NULL;						//rear指向NULL
      }
      free(p);								//释放结点空间
      return true;
  }
  ~~~

  [不头结点出队：](https://image.sybblogs.fun/img-common/202305252005348.png)

  <img src="https://image.sybblogs.fun/img-common/202305252005348.png" alt="不头结点出队" style="zoom:50%;" />

## 3. 双端队列

[双端队列定义：](https://image.sybblogs.fun/img-common/202305261553330.png)

<img src="https://image.sybblogs.fun/img-common/202305261553330.png" alt="双端队列定义" style="zoom: 33%;" />

具体又可以细分为：输入受限的双端队列、输出受限的双端队列

[输入受限的双端队列和输出受限的双端队列：](https://image.sybblogs.fun/img-common/202305261555897.png)

<img src="https://image.sybblogs.fun/img-common/202305261555897.png" alt="输出或输出受限的双端队列" style="zoom:33%;" />

考点：和栈一样会考某组数据出栈顺序是否合法。可以用卡特兰数计算出一组数据有多少种合法出战组合。
$$
\begin{equation*}
	\begin{aligned}
&卡特兰数:\frac{1}{n+1}C^{n}_{2n}\\
\\
&如:输入数列为:1,2,3,4\\
\\
&合法输出组合为:\frac{1}{4+1}C^4_8=14
	\end{aligned}
\end{equation*}
$$

## 4. 队列的应用——树的遍历

队列有一个重要应用：树的层次遍历。

[树的遍历：](https://image.sybblogs.fun/img-common/202306191704305.png)

<img src="https://image.sybblogs.fun/img-common/202306191704305.png" alt="树的遍历" style="zoom: 50%;" />

遍历步骤：

1. 遍历$1$号节点，将一号两个子节点放入队列队尾：$1\rightarrow2\rightarrow3$
2. 遍历完$1$号节点后出队，遍历$2$号节点两个子节点放入队尾：$2\rightarrow3\rightarrow4\rightarrow5$
3. 遍历$2$号后出队，遍历$3$号节点两个子节点放入队尾：$3\rightarrow4\rightarrow5\rightarrow6\rightarrow7$
4. 之后遍历$4$节点，$4$节点没有子节点，遍历完后直接弹出：$5\rightarrow6\rightarrow7$
5. 遍历$5$节点，子节点入队：$5\rightarrow6\rightarrow7\rightarrow8\rightarrow9$
6. 遍历$5$节点后，$6$节点没有子节点，遍历完后直接弹出：$7\rightarrow8\rightarrow9$
7. 遍历$7$节点，将子节点放入队列：$7\rightarrow8\rightarrow9\rightarrow19\rightarrow11$
8. 依次遍历弹出即可

## 5. 特殊矩阵的压缩存储

### 5.1 一维数组

数组`a[10]`在内存中存储如下：

[数据存储：](https://image.sybblogs.fun/img-common/202306191718919.png)

<img src="https://image.sybblogs.fun/img-common/202306191718919.png" alt="数据存储" style="zoom:33%;" />

各个元素大小相同，且物理上连续存放。所以我们可以根据数组起始地址得到任何一个数组内存地址。

计算方法：==$a[i]$存放地址$=起始地址+i*sizeof(ElemType)$==。数组下标$i$默认从$0$开始，如果从$1$开始，计算公式要改为`i-1`。

### 5.2 二维数组

数组`b[2][4]`内存存储如下：

[二维数组存储：](https://image.sybblogs.fun/img-common/202306191725303.png)

<img src="https://image.sybblogs.fun/img-common/202306191725303.png" alt="二维数组存储" style="zoom: 50%;" />

存储方式有两种：行优先(一行一行存)，列优先(一列一列存)。

计算方法：$M$行$N$列二维数组`b[m][n]`，按照==行优先==存储，则==$b[i][j]$的存储地址$=起始地址+(i*N+j)*sizeof(ElemType)$==

$M$行$N$列二维数组`b[m][n]`，按照==列优先==存储，则==$b[i][j]$的存储地址$=起始地址+(j*M+i)*sizeof(ElemType)$==

### 5.3 对称矩阵压缩存储

若$n$阶方阵中任意一个元素$a_{i,j}$都有$a_{i,j}=a_{j,i}$，则该矩阵为对称矩阵。

[对称矩阵：](https://image.sybblogs.fun/img-common/202306191742520.png)

<img src="https://image.sybblogs.fun/img-common/202306191742520.png" alt="对称矩阵" style="zoom:33%;" />

其特点就是关于主对角线下标$i=j$对称

[对称矩阵特点：](https://image.sybblogs.fun/img-common/202306191745807.png)

<img src="https://image.sybblogs.fun/img-common/202306191745807.png" alt="对称矩阵特点" style="zoom: 50%;" />

存储数组：数组从$0$开始，大小为：$\frac{(1+n)·n}{2}-1$的一维数组存储

存储方式：只存储主对角线$+上/$下三角区域

- 策略一：按照行优先原则，将各个元素存入一维数组中。

  [对称矩阵一维存储：](https://image.sybblogs.fun/img-common/202306191754712.png)

  <img src="https://image.sybblogs.fun/img-common/202306191754712.png" alt="对称矩阵一维存储" style="zoom: 50%;" />

  数组下标获取：$a_{i,j}$是数组$a[k]$第$\frac{i(i-1)}{2}+j$个元素，所以下标$k=\frac{i(i-1)}{2}+j-1$

- 策略二：按照列优先原则，将各个元素存入一维数组中。

  [对称矩阵列存储：](https://image.sybblogs.fun/img-common/202306191832897.png)

  <img src="https://image.sybblogs.fun/img-common/202306191832897.png" alt="对称矩阵列存储" style="zoom:50%;" />

  数组下标获取：$a_{i,j}$是数组$a[k]$下标$k=[n+(n-1)+(n-2)+...+(n-j-2)]+(i-j)$

### 5.4 三角矩阵

下三角矩阵：除了主对角线和下三角区，其余的元素都相同

上三角矩阵：除了主对角线和上三角区，其余的元素都相同

[下三角矩阵：](https://image.sybblogs.fun/img-common/202306191838365.png)

<img src="https://image.sybblogs.fun/img-common/202306191838365.png" alt="下三角矩阵" style="zoom:50%;" />

[上三角矩阵：](https://image.sybblogs.fun/img-common/202306191839702.png)

<img src="https://image.sybblogs.fun/img-common/202306191839702.png" alt="上三角矩阵" style="zoom:50%;" />

存储策略：按行优先原则将橙色区元素存入一维数组，并在最后一个位置存储常数$c$.

[三角矩阵行优先存储：](https://image.sybblogs.fun/img-common/202306191841065.png)

<img src="https://image.sybblogs.fun/img-common/202306191841065.png" alt="三角矩阵行优先存储" style="zoom:50%;" />

求$a_{i,j}$元素在数组中下标$k$：
$$
\begin{equation*}
	\begin{aligned}
k=\left\{ 
\begin{matrix}
\frac{i(i-1)}{2}+j-1,i\ge j(下三角区和主对角线元素)\\
\frac{n(n+1)}{2},i<j(上三角区元素)
\end{matrix}
\right.
\quad
	\end{aligned}
\end{equation*}
$$

### 5.5 三对角矩阵的压缩存储

又称为带状矩阵，当满足$|i-j|>1时,$有$a_{i,j}=0(1\le i,j\le n)$

[三对角矩阵：](https://image.sybblogs.fun/img-common/202306191903248.png)

<img src="https://image.sybblogs.fun/img-common/202306191903248.png" alt="三对角矩阵" style="zoom:33%;" />

压缩策略：按行优先原则(列优先)，只存储带状部分(非$0$部分)

[三对角矩阵压缩存储：](https://image.sybblogs.fun/img-common/202306191905297.png)

<img src="https://image.sybblogs.fun/img-common/202306191905297.png" alt="三对角矩阵压缩存储" style="zoom: 50%;" />

$a_{i,j}(|i-j|\le1)$元素在数组中是第几个：

前$i-1$行共$3(i-1)-1$个元素，$a_{i,j}$是$i$行第$j-i+2$个元素，$a_{i,j}$是第==$2i+j-2$==个元素。

若已知数组下标$k$，如何得到$i,j$：

①前$i-1$行共$3(i-1)-1$个元素

②前$i$行共$3i-1$个元素

③显然$3(i-1)-1<k+1\le3i-1$，即$i\ge\frac{(k+2)}{3}$。$i$向上取整即可满足这个不等式：$i=[\frac{k+2}{3}]$

### 5.6 稀疏矩阵压缩存储

稀疏矩阵：非零元素远远少于矩阵元素个数。

[稀疏矩阵：](https://image.sybblogs.fun/img-common/202306191919409.png)

<img src="https://image.sybblogs.fun/img-common/202306191919409.png" alt="稀疏矩阵" style="zoom: 33%;" />

压缩存储策略：

- 顺序存储：三元组，存储行、列、值

  [稀疏矩阵三元组存储：](https://image.sybblogs.fun/img-common/202306241812141.png)

  <img src="https://image.sybblogs.fun/img-common/202306241812141.png" alt="三元组存储" style="zoom: 50%;" />

- 十字链表法：

  定义一个节点，节点包含非零元素所在的行、列、值。节点还会有两个指针：

  [十字链表节点：](https://image.sybblogs.fun/img-common/202306241847376.png)

  <img src="https://image.sybblogs.fun/img-common/202306241847376.png" alt="十字链表节点" style="zoom:50%;" />

  再定义两个数组：向下域(存放列指针)和向右域(存放行指针)，数组中存放的是一个个指针。

  [十字链表域：](https://image.sybblogs.fun/img-common/202306241850960.png)

  <img src="https://image.sybblogs.fun/img-common/202306241850960.png" alt="十字链表" style="zoom: 50%;" />

  这里以行遍历为例：行数组中第一个指针指向节点值是4，其节点行指针域保存本行下一个非零元素指针，当找到下一个节点行指针域为NULL时。行数组$+1$进入下一行，执行过程同上。

  列遍历同行遍历。

  

[矩阵常见考题：](https://image.sybblogs.fun/img-common/202306241819776.png)

<img src="https://image.sybblogs.fun/img-common/202306241819776.png" alt="矩阵考题" style="zoom: 50%;" />

# 六. 串

串，即字符串。是一种特殊的线性表，数据元素之间呈线性关系。

[串的线性关系：](https://image.sybblogs.fun/img-common/202306291538128.png)

<img src="https://image.sybblogs.fun/img-common/202306291538128.png" alt="串的线性关系" style="zoom:33%;" />

术语：

1. 子串：串中任意个**连续的字符**组成的子序列。空串也是字符串的子串。
2. 主串：整个字符串
3. 字符在主串中的位置：字符在串中的序号，从$1$开始。
4. 字串在主串中的位置：字串的第一个字符在主串中的位置，也是从$1$开始。如：$T=$`iPhone pro Max`，`pro`在$T$中位置是$8$

5. 只有长度为$0$时，才是空串。空格也算字符串，每个占$1B$

串的基本操作增删改查等，通常以子串为操作对象。

字符集编码：任何数据存到计算机中一定是二进制数，需要确定一个字符和二进制数的对应规则，这就是"编码"。一般考试用`ASCII`编码，一个字符大小为$1B$。

## 1. 串的存储方法

一般采用以下几种存储方法：

[串的几种存储：](https://image.sybblogs.fun/img-common/202306291607941.png)

<img src="https://image.sybblogs.fun/img-common/202306291607941.png" alt="串存储方法" style="zoom: 33%;" />

方案一缺点是从$0$开始，与串的序列不符。方案二缺点是`char[0]`大小不能超过255。所以经常采用方案四。

## 2. 串的顺序存储

### 2.1 定长顺序存储

可以采用静态数组方式实现串的顺序存储

~~~C++
#define MaxLEN 255
typedef struct{
    char ch[MaxLEN];
    int length;
}SString;
~~~

这样做缺点是数组长度是定长的，不能改变。

### 2.2 堆分配存储

用动态数组方式实现

~~~C++
typedef struct{
    char *ch;
    int length;
}HString;
HString S;
s.ch=(char*)malloc(MaxLEN*sizeof(char));
~~~

## 3. 串的链式存储

### 3.1 低密度存储

存储密度低，每个字符$1B$，而每个指针$4B$

~~~C++
typedef struct StringNode{
    char ch;
    struct StringNode *next;
}StringNode,*String;
~~~

[串低密度存储：](https://image.sybblogs.fun/img-common/202306291615862.png)

<img src="https://image.sybblogs.fun/img-common/202306291615862.png" alt="串低密度存储" style="zoom:50%;" />

### 3.2 高密度存储

每个结构体有一个长度为$4$的字符型数组

~~~C++
typedef struct StingNode{
    char ch[4];
    struct StingNode *next;
}StingNode,*String;
~~~

[串高密度存储：](https://image.sybblogs.fun/img-common/202306291617238.png)

<img src="https://image.sybblogs.fun/img-common/202306291617238.png" alt="串高密度存储" style="zoom:50%;" />

最后一个节点存储不满，可以用特殊字符标记，建议用`\0`

## 4. 字符串基本操作

### 4.1 求字串

要求：用`sub`返回串`S`的第`pos`个字符起长度为`len`的子串。

~~~C++
typedef struct{
    char ch[MaxLEN];
    int length;
}SString;
bool SubString(SString &Sub,SString S,int pos,int len){//sub:暂存;S:主串;pos:起始位置;len:截取长度
    if(pos+len-1>S.length) return false;	
    for(int i=pos;i<pos+len;i++){
        Sub.ch[i-pos+1]=S.ch[i];
    }
    Sub.length=len;
    return true;
}
~~~

### 4.2 字符串比较

若$S>T$，则返回值$>0$；若$S=T$，则返回值$=0$；若$S<T$，则返回值$<0$.

~~~C++
int StrCompare(SString S,SString T){
	for(int i=1;i<=S.length&&i<=T.length;i++){
        if(S.ch[i]!=T.ch[i]) return S.ch[i]-T.ch[i];
    }
    //所有字符串都相同，则长度大的字符串大
    return S.length-T.length;
}
~~~

### 4.3 定位操作

若主串$S$中存在与串$T$值相同的子串，则返回它在主串$S$中第一次出现的位置，否则函数值为$0$。

~~~C++
int Index(SString S,SString T){
    int i=1,n=StrLength(S),m=StrLength(T);
    SString sub;//暂存字串
    while(i<=n-m+1){
        SubString(sub,S,i,m);
        if(StrCompare(sub,T)!=0) ++i;
        else return i;//返回子串在主串中的位置
    }
    return 0;
}
~~~

每次从$S$中取$T$大小的字符，逐个对比即可。

## 5. 朴素模式匹配算法

字符串模式匹配：在一大片字符串(主串)中搜索某个字符串(模式串)。如：一个文档中搜索一段话。

这里解释较容易混淆概念：子串是主串的一部分，一定存在。模式串不一定能在主串中找到。

朴素模式匹配思路：在主串中依次取和模式串长度相同字符串进行匹配。如：主串长度为$n$，模式串长度为$m$，将主串中所有长度为$m$的子串依次进行对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。最多对比$n-m+1$个子串。

代码实现：用两个标记指针$i,j$，分别指向主串和模式串的第一个元素，每匹配依次，两个指针后移，匹配到不相同元素时让$i=i-j+2,j=1$，重新匹配。

~~~C++
int Index(SString S,SString T){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[i]){
            ++i,++j;//字符相等继续比较后续字符
        }else{
            i=i-j+2;
            j=1//指针后退重新开始匹配
        }
    }
    if(j>T.length) return i-T.length;//返回主串中匹配相同位置
    else return 0;//所有都不匹配返回0
}
~~~

时间复杂度：最坏情况，每个子串都要对比$m$个字符，共$n-m+1$个子串，复杂度$=O((n-m+1)m)=O(nm-m^2+m)=O(nm)$(由于很多时候往往$n\ge m$，所以$nm$数量级要远远大于$m^2,m$.所以只保留$nm$)

## 6. KMP算法匹配字符串

KMP算法是朴素模式匹配算法优化。利用好模式串本身带有的信息可以跳过中间很多没有必要的对比，从而使算法效率得到提升。给出一组子串和一个模式串：

1. 从主串$1$位置开始匹配，假定模式串前$5$个元素都匹配成功，但最后一个匹配失败。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111745319.png" alt="主串0" style="zoom:50%;" />
   <img src="https://image.sybblogs.fun/img-common/202307111745660.png" alt="模式串0" style="zoom:50%;" />

   对于模式串`T='abaabc'`，当第6个元素匹配失败时，可令主串指针$i$不变，模式串指针$j=3$，直接跳过$2,3$循环对比

   <img src="https://image.sybblogs.fun/img-common/202307111739872.png" alt="主串1" style="zoom:50%;" />
   <img src="https://image.sybblogs.fun/img-common/202307111739306.png" alt="模式串1" style="zoom: 50%;" />

2. 从主串$5$位置开始匹配，假定模式串的前$5$个元素都匹配成功，但最后一个匹配失败。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111753113.png" alt="主串2" style="zoom:50%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111754115.png" alt="模式串2" style="zoom:50%;" />

   同样对于模式串`T='abaabc'`，当第6个元素匹配失败时，可令主串指针$i$不变，模式串指针$j=3$，直接跳过$6,7$循环对比。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111757203.png" alt="主串3" style="zoom:50%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111757011.png" alt="模式串3" style="zoom:50%;" />

3. 从主串$1$位置开始匹配，假定模式串前$4$个元素都匹配成功，但第$5$个匹配失败。对于模式串`T='abaabc'`，当第5个元素匹配失败时，也就代表主串中前四个元素信息可以确定是`abaa`。此时可以让主串指针$i$不变，模式串指针指向$j=2$。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111802273.png" alt="主串4" style="zoom:50%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111802698.png" alt="模式串4" style="zoom:50%;" />

4. 从主串$1$位置开始匹配，假定模式串前$3$个元素都匹配成功，但第$4$个匹配失败。对于模式串`T='abaabc'`，当第4个元素匹配失败时，也就代表主串中前三个元素信息可以确定是`aba`。此时可以让主串指针$i$不变，模式串指针指向$j=2$。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111805669.png" alt="主串5" style="zoom:50%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111805030.png" alt="模式串5" style="zoom:50%;" />

5. 以此类推，主串$1$位置开始匹配，假定模式串前$2$个元素都匹配成功，但第$3$个匹配失败。对于模式串`T='abaabc'`，当第3个元素匹配失败时，也就代表主串中前二个元素信息可以确定是`ab`。可以让主串指针$i$不变，模式串指针指向$j=1$。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111808500.png" alt="主串6" style="zoom:50%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111808514.png" alt="模式串6" style="zoom:50%;" />

6. 同样的假定模式串第$2$个元素匹配失败，可令主串$i$不变，模式串$j=1$

7. 当第$1$个元素匹配失败时，匹配下一个相邻子串，令$j=0,i++,j++$

优化后的主串指针$i$不"回溯"。对于模式串`T='abaabc'`，回溯有以下情况：

[回溯情况：](https://image.sybblogs.fun/img-common/202307111903614.png)

<img src="https://image.sybblogs.fun/img-common/202307111903614.png" alt="回溯情况" style="zoom:50%;" />

我们可以用一个$next[]$数组存放模式串回溯信息。上面匹配情况$next$数组如下：

[next数组：](https://image.sybblogs.fun/img-common/202307111906009.png)

<img src="https://image.sybblogs.fun/img-common/202307111906009.png" alt="next数组" style="zoom:50%;" />

当第一个元素匹配失败时，令$j=next[1]$；当第二个元素匹配失败时，令$j=next[2]$；当第三个元素匹配失败时，令$j=next[3]$....

判断代码：

~~~C++
if(S[i]!=T[j]){
    j=next[i]
}
if(j==0){
    i++;
    j++;
}
~~~

模式匹配部分完整代码：

~~~C++
int Index_KMP(SString S,SString T,int next[]){
    int i=1, j=1;
    while( i<=S.length&&j<=T.length){
        if(j==0||S.ch[i]==T.ch[j]){
            ++i;
            ++j;			//继续比较后继字符
        }
        else j=next[j];		//模式串向右移动
    }
    if(j>T.length)
        return i-T.length;	//匹配成功
    eLse return 0;
}
~~~

KMP算法最欢时间复杂度$O(m+n)$.其中求$next$数组时间复杂度为$O(m)$，模式匹配时间复杂度为$O(n)$

## 7. ==求next数组==

求next数组过程很关键，要利用next数组进行匹配，主串指针不用回溯，从而减少时间复杂度。

求字符串`google`的next数组过程：字符串`google`长度是$6$，那么next数组长度也应该是$6$。主串指针为$i$，模式串指针为$j$

- $next[1]$的含义是当第一个字符匹配失败要回溯的位置。

  此时让$next[1]$的值为$0$，实际上任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串，因此，`next[1]`都无脑写$0$

- $next[2]$的含义是当第二个字符匹配失败要回溯的位置。此时只知道主串前一个元素的值。

  任何模式串都一样，第$2$个字符不匹时，应尝试匹配模式串的第$1$个字符，因此，`next[2]`都无脑写$1$

- $next[3]$是第三个字符匹配失败要回溯位置。在匹配失败元素前面画一条竖线。此时知道主串前两个元素的值。如下：

  <img src="https://image.sybblogs.fun/img-common/202309211301104.png" alt="求next数组" style="zoom:50%;" />

  尝试模式串往后移动一位与主串对应元素进行匹配：

  <img src="https://image.sybblogs.fun/img-common/202309211302966.png" alt="求next数组2" style="zoom:50%;" />

  显然$g!=o$故再往后移：

  <img src="https://image.sybblogs.fun/img-common/202309211303810.png" alt="求next数组3" style="zoom:50%;" />

  此时移动到匹配失败元素的位置，而指针$j=1$故$next[3]=1$

- 同理，当第四个元素匹配失败要回溯位置$next[4]$

  <img src="https://image.sybblogs.fun/img-common/202309211306022.png" alt="求next数组4" style="zoom:50%;" />

  模式串右移一位，与对应主串匹配：

  <img src="https://image.sybblogs.fun/img-common/202309211307654.png" alt="求next数组5" style="zoom:50%;" />

  $g!=o$再次右移仍不匹配，直到模式串指针$j$移动到主串指针$i$指向的位置

  <img src="https://image.sybblogs.fun/img-common/202309211310903.png" alt="求next数组6" style="zoom:50%;" />

  此时$j=1$，故$next[4]=1$

- $next[5]$的值，同理

  <img src="https://image.sybblogs.fun/img-common/202309211313022.png" alt="求next数组7" style="zoom:50%;" />

  模式串右移同时观察是否匹配对应主串，当移动到第四位时：

  <img src="https://image.sybblogs.fun/img-common/202309211314431.png" alt="求next数组8" style="zoom:50%;" />

  发现模式串第一位$g$与主串可以匹配，但由于主串$i$所指位置不确定，故`next[5]=j`，即next[5]=2

- 同理得$next[6]=1$

总结：next数组的作用：当模式串的第j个字符失配时，从模式串的第`next[j]`的继续往后匹配

步骤总结：在不匹配的位置前边，划一根分界线，模式串一步一步往后退，直到分界线之前能匹配上，或模式串完全跨过分界线为止此时$j$指向哪儿，next数组值就是多少。代码如下：

~~~C++
//计算next数组 
void nextVal(char s[],int next[],int len){
	//c是不匹配的位置，i主串位置，j匹配串位置；由于前两位匹配失败回溯值确定，所以从第三个位置开始匹配
    //由于不匹配位置从3开始,故主串自动右移一位与模式串第一位进行匹配,即i=2,j=1
	int c=3,i=2,j=1;
	while(c<=len){
        //首次循环如果模式串第一位匹配主串第二位是否相等
		if(s[i]==s[j]){
            //如果相等主串与模式串指针继续后移匹配
			++i,++j;
		}else{
            //如果不相等,主串继续后移,模式串回溯到1重新匹配
			i=i-j+2;
			j=1;
		}
        //如果主串指针i指向不匹配元素位置,则结束本次匹配,j的值就是next[c]的值
		if(i==c){
			next[c]=j;
            //继续计算下一次next[c]的值
			c++;
		}
	}
} 
~~~

## 8. KMP算法进一步优化

本质是对next数组的优化，将next数组优化为nextval数组。

以模式串`abaabc`为例，其对应next数组如下：

<img src="https://image.sybblogs.fun/img-common/202309211338861.png" alt="求next数组9" style="zoom:50%;" />

当$next[3]$时模式串指针$j$应该回溯到$1$的位置，此时会发现模式串回溯位置是字符`a`，而回溯之前匹配失败位置$3$处的值也是`a`，所以主串所指位置$i$处一定不是`a`，这样又要将模式串进行$next[1]$的回溯，相当于多一次不必要的回溯。

即$next[3]处所指向元素=next[1]处所指向元素$，而主串$S[i]处元素\ne next[3]处元素$

<img src="https://image.sybblogs.fun/img-common/202309211346746.png" alt="求next数组10" style="zoom:50%;" />

直接办法是让`next[3]=next[1]=0`，此时如果模式串第三个位置匹配失败，执行$next[3]=0$，回溯到$0$处，此时直接跳过主串$S[3]$处必定失败的匹配。

同理，$next[5]$处值也可以优化为$next[2]$处的值，即$next[5]=next[2]=1$。优化后next数组如下：

<img src="https://image.sybblogs.fun/img-common/202309211358831.png" alt="求next数组11" style="zoom:50%;" />

其代码实现核心是失败位置$next[i]$所指向的元素是否**等于**主串$S[i]$处的元素。如果等于则优化为：$nextval[i]=nextVal[next[i]]$

~~~C++
//优化next数组,s模式串,len模式串长度
void nextVals(char s[],int next[],int nextVal[],int len){
	for(int i=2;i<=len;i++){
		if(s[next[i]]==s[i])
			nextVal[i]=nextVal[next[i]];
		else
			nextVal[i]=next[i];
	}
	for(int i=1;i<=len;i++){
		cout<<"nextVal："<<nextVal[i]<<endl;
	}
} 
~~~

# 七 ==树==

树是一种递归定义的结构。树的结构如下：

<img src="https://image.sybblogs.fun/img-common/202309212037104.png" alt="非空树结构" style="zoom:50%;" />

以上是非空树结构，还有空树$\varnothing——$结点为$0$的树。

## 1. 树的基本概念

非空树特点：

1. 有且仅有一个根节点

2. 没有后继的结点称为"叶子结点"(或终端结点)

3. 有后继的结点称为"分支结点"(或非终端结点)

4. 除了根节点，==任何一个节点都有且仅有一个前驱==

5. 每个节点可以有$0$个或多个后继

6. 除根节点外，其余节点可以分为若干个**子树**，这些子树特点是互不相交

   <img src="https://image.sybblogs.fun/img-common/202309212045820.png" alt="子树" style="zoom:50%;" />

结点之间的关系描述：

<img src="https://image.sybblogs.fun/img-common/202309212049150.png" alt="结点之间的关系描述" style="zoom:50%;" />

- 祖先结点：从子结点开始，往上经过结点都是祖先结点

  如：`爷爷`$——$`父亲`是`你`的祖先结点

- 孙子结点：从子结点开始，下面的分支都是孙子结点

  如：`F`是`父亲`的孙子结点

- 双亲结点(父结点)：一个结点直接前驱是父结点

  如：`你`的父结点是`父亲`

- 孩子结点：一个结点的直接后继是孩子结点

  如：`H`的孩子结点是`M`

- 兄弟结点：子树同一层结点为兄弟结点

  如：`I`，`j`是`H`的兄弟结点

- 堂兄弟结点：同一层结点为堂兄弟结点

  如：`G`，`H`，`I`是`J`的堂兄弟结点

- 路径：描述两个结点之间的路径，是单向的，只能从上往下。

- 路径长度：指经过了几条边

结点、树的属性描述

属性:
结点的层次(深度)——从上往下数

<img src="https://image.sybblogs.fun/img-common/202309212124113.png" alt="树结点的层次" style="zoom:50%;" />

结点的高度——从下往上数

<img src="https://image.sybblogs.fun/img-common/202309212124368.png" alt="树结点的高度" style="zoom:50%;" />

树的高度(深度)——树总共多少层

结点的度——一个结点有几个分支(包括根结点)。非叶子结点的度$>0$，叶子结点度$=0$

树的度——各结点的度的最大值。如上面树的度$=3$，是结点`D`

有序树：逻辑上看，树种结点的各子树从左到右是有次序的，不能互换。如：

<img src="https://image.sybblogs.fun/img-common/202309212049150.png" alt="结点之间的关系描述" style="zoom:50%;" />

无序树：树中结点的各子树从左至右是无次序的，可以互换。如：

<img src="https://image.sybblogs.fun/img-common/202309212131709.png" alt="无序树" style="zoom:50%;" />

森林：森林是$m(m\ge0)$棵互不相交的树的集合，可以允许有$\varnothing$现象。

<img src="https://image.sybblogs.fun/img-common/202309212133120.png" alt="森林" style="zoom:50%;" />

如果以上森林加一个共同根节点`A`，森林就变成了树。这是一个重要考点。

## 2. 树常考的性质

- 考点一：结点数$=$总度数$+1$

- 考点二：度为$m$的树、$m$叉树的区别

  $m$叉树：每个结点最多只能有$m$个孩子的树

  |            度为$m$的树             |              $m$叉树               |
  | :--------------------------------: | :--------------------------------: |
  | 任意结点的度$\le m$(最多$m$个孩子) | 任意结点的度$\le m$(最多$m$个孩子) |
  | 至少有一个结点度$=m$(有$m$个孩子)  |       允许所有结点的度都$<m$       |
  |  一定是非空树，至少有$m+1$个结点   |             可以是空树             |

  <img src="https://image.sybblogs.fun/img-common/202309212204069.png" alt="度为m树与m叉树" style="zoom:50%;" />

- 考点三：度为$m$的树第$i$层至多有$m^{i-1}$个结点$(i\ge1)$

  <img src="https://image.sybblogs.fun/img-common/202309212209936.png" alt="树常考点三" style="zoom:50%;" />

  第一层：最多$m^0$个结点；第二层：最多$m^1$个结点；第三层：最多$m^2$个结点；第四层：最多$m^3$个结点

  同理，$m$叉树第$i$层至多有$m^{i-1}$个结点$(i\ge1)$

- 考点四：高度为$h$的$m$叉树至多有$\frac{m^h-1}{m-1}$个结点

- 考点五：高度为$h$的$m$叉树至少有$h$个结点。高度为$h、$度为$m$的树至少有$h+m-1$个结点

  <img src="https://image.sybblogs.fun/img-common/202309212230180.png" alt="树常考点五" style="zoom: 50%;" />

- 考点六：具有$n$个结点的$m$叉树的最小高度为$[\log_m(n(m-1)+1)]$[^7-2-1]。

  高度最小情况：所有结点都有$m$个孩子
  $$
  \begin{aligned}
  	\begin{gather*}
  \\\Large{证明：}\\
  &高度为h的m叉树至多有\frac{m^h-1}{m-1}个结点\\
  \\
  &前h-1有\frac{m^{h-1}-1}{m-1}个结点\\
  \\
  &\frac{m^{h-1}-1}{m-1}<n\le\frac{m^h-1}{m-1}\\
  \\
  &\therefore h-1<\log_m(n(m-1)+1)\le h
  	\end{gather*}
  \end{aligned}
  $$

- 考点七：设非空二叉树中度为$0、1$和$2$的结点个数分别为$n_0、n_1$和$n_2$，则==$n_0=n_2+1$==(度为$0$的叶子结点比度为$2$的叶子结点多一个)。

  假设树中结点总数为$n$，则：

  ①$n=n_0+n_1+n_2$

  ②$n=n_1+2n_2+1$(树的结点数$=$总度数$+1$)

  此时②$-$①$\Longrightarrow n_0=n_2+1$，即叶子结点比二分支结点多一个。

  <img src="https://image.sybblogs.fun/img-common/202309301654790.png" alt="二叉树考点七" style="zoom:50%;" />

- 考点八：二叉树第$i$层至多有$2^{i-1}$个结点$(i\ge1)$；$m$叉树第$i$层至多有$m^{i-1}$个结点$(i\ge1)$。

  <img src="https://image.sybblogs.fun/img-common/202309301855581.png" alt="二叉树考点八" style="zoom:50%;" />

- 考点九：高度为$h$的二叉树至多有$2^{h}-1$个结点(满二叉树)，高度为$h$的$m$叉树至多有$\frac{m^{h}-1}{m-1}$个结点

  等比数列求和公式：$a+aq+aq^2+\cdots+aq^{n-1}=\frac{a(1-qn)}{q}$

- 完全二叉树考点$1$：具有$n$个$(n>0)$结点的完全二叉树的高度$h$为$[\log_2(n+1)]$或$[\log_2n]+1$

  高为$h$的满二叉树共有$2^h-1$个结点

  高为$h-1$的满二叉树共有$2^{h-1}-1$个结点

  故$h-1<\log_2(n+1)\le h$化简可得$h=[\log_2(n+1)]$
  
  <img src="https://image.sybblogs.fun/img-common/202310071217339.png" alt="完全二叉树常考点1" style="zoom: 50%;" />

- 完全二叉树考点$2$：对于完全二叉树，可以由树的结点数$n$推出度为$0,1$和$2$的结点个数为$n_0,n_1,n_2$

  完全二叉树最多只有一个度为$1$的结点，即$n_1=0$或$1$

  假设$n_0$是叶子结点的个数，$n_2$是双分支结点的个数，则$n_0=n_2+1\Longrightarrow n_0+n_2=2n_2+1$，故$n_0+n_2$一定是奇数。

  例：若一个完全二叉树有$2k$(偶数)个结点，则$n_1=1,n_0=k,n_2=k-1$

  <img src="https://image.sybblogs.fun/img-common/202310071219386.png" alt="完全二叉树常考点2" style="zoom:50%;" />

[常考点总结：](https://image.sybblogs.fun/img-common/202310071233110.png)

<img src="https://image.sybblogs.fun/img-common/202310071233110.png" alt="常考点总结" style="zoom:50%;" />

## 3. 二叉树

二叉树是$n(n\ge0)$个结点的有限集合

①或者是**空二叉树**，即$n=0$

②或者由一个根结点和两个互不相交的被称为根的左子树喝右子树组成，左子树和右子树又分别是一颗二叉树。

<img src="https://image.sybblogs.fun/img-common/202309252221835.png" alt="二叉树" style="zoom:50%;" />

特点：每个结点至多只有两棵子树，左右子树不能颠倒(二叉树是有序树)；二叉树是递归定义的数据结构。

二叉树五种状态：

<img src="https://image.sybblogs.fun/img-common/202309252226308.png" alt="二叉树五种状态" style="zoom: 33%;" />

### 3.1 几个特殊二叉树

#### 满二叉树

满二叉树：一棵高度为$h$，且含有$2^h-1$个结点的二叉树

<img src="https://image.sybblogs.fun/img-common/202309252229321.png" alt="满二叉树" style="zoom:50%;" />

特点：

①只有最后一层有叶子结点；

②不存在度为$1$的结点；

③按层序从$1$开始编号，结点$i$的左孩子为$2i$，右孩子为$2i+1$；结点$i$的父结点为$[i/2]$

#### 完全二叉树

完全二叉树：当且仅当其每个结点都与高度为$h$的**满二叉**树中编号为$1$~$n$的结点一一对应时，称为完全二叉树。

特点：

①只有最后两层可能有叶子结点；

②且最多只有一个度为$1$的结点。

③按层序从$1$开始编号，结点$i$的左孩子为$2i$，右孩子为$2i+1$；结点$i$的父结点为$[i/2]$

④$i\le[n/2]$为分支结点，$i>[n/2]$为叶子结点

⑤一个结点如果有孩子，一定是左孩子。

满二叉树是完全二叉树，而完全二叉树不一定是满二叉树。

<img src="https://image.sybblogs.fun/img-common/202309252314777.png" alt="完全二叉树" style="zoom:50%;" />

#### 二叉排序树

二叉排序树是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树:

①左子树上所有结点的关键字均小于根结点的关键字;

②右子树上所有结点的关键字均大于根结点的关键字。

③左子树和右子树又各是一棵二叉排序树。

<img src="https://image.sybblogs.fun/img-common/202309252332527.png" alt="二叉排序树" style="zoom:50%;" />

例：如果找`60`这个元素，先从根结点开始，根结点$19<60$往右结点走，右结点$50<60$再往右走，此时右结点$66>60$故往左走找到`60`元素的结点。

<img src="https://image.sybblogs.fun/img-common/202309301609187.png" alt="二叉排序树例子" style="zoom:50%;" />

#### 平衡二叉树

平衡二叉树，树上任一结点的左子树和右子树的深度之差不超过$1$

特点是：根节点子树越多，高度越低，搜索排序的效率越高。

<img src="https://image.sybblogs.fun/img-common/202309301626242.png" alt="平衡二叉树" style="zoom:50%;" />

同样平衡二叉树排序搜索效率很高。

### 3.2 二叉树存储结构

#### 顺序存储

要存储下面树结构：

<img src="https://image.sybblogs.fun/img-common/202310072028168.png" alt="二叉树顺序存储" style="zoom:50%;" />

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 100 
using namespace std;

struct treeNode{
	int data;
	bool isEmpy;
};

//初始化 
void initNode(treeNode t[]){
	for(int i=0;i<MaxSize;i++){
		t[i].isEmpy=true;
	}
}


int main(){
	treeNode t[MaxSize];
	initNode(t);
}
~~~

这里结构体中的`isEmpy`变量是该结点有没有元素，有的话为`false`，初始化时默认为`true`。其树元素在顺序表中存储如下：

<img src="https://image.sybblogs.fun/img-common/202310072030932.png" alt="二叉树顺序存储2" style="zoom:50%;" />
