[toc]

# 十一. 排序

排序就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。

排序算法评价指标：

- 时间复杂度

- 空间复杂度

- 算法稳定性：指表中相同元素先后位置，经过排序后有没有相对的变动。

  <img src="https://image.sybblogs.fun/img-common/202401031746064.png" alt="排序的稳定性" style="zoom:50%;" />

  注意：稳定排序算法并不一定比不稳定的算法优秀，主要看实际需求。

排序算法分类：

1. 内部排序：数据都在内存中。更关注算法时间和空间复杂度
2. 外部排序：数据太多，无法全部放入内存。除了要关注算法时间和空间复杂度，还要关注如何使读$/$写磁盘次数更少。

<img src="https://image.sybblogs.fun/img-common/202401031750407.png" alt="排序的分类" style="zoom:50%;" />

## 1. 插入排序

算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。

动画演示：

<img src="https://image.sybblogs.fun/img-common/202401041338164.gif" alt="插入排序演示" style="zoom:50%;" />

### 1.1 算法实现及分析

排序从第二个元素开始，默认当前排序元素左边已经有序。只要比当前元素大的都往后移动，直到碰到比当前元素小(相等)的。

代码实现：

~~~c
//直接插入排序
void InsertSort(int A[],int n){
    int i,j, temp;
    for(i=1;i<n;i++)			//将各元素插入已排好序的序列中
        if(A[i]<A[i-1]){		//若A[i]关键字小于前驱
            temp=A[i];			//用temp暂存A[i]
            for(j=i-1;j>=0 && A[j]>temp;--j) //检查所有 前面已排好序的元素
                A[j+1]=A[j]; 	//所有大于temp的元素都向后挪位
            A[j+1]=temp;		//复制到插入位置
        }
}
~~~

带哨兵实现方法：

<img src="https://image.sybblogs.fun/img-common/202401041346735.png" alt="插入排序(哨兵法)" style="zoom:50%;" />

代码实现：

~~~c
//直接插入排序(带哨兵)
void InsertSort(int A[],int n){
    int i,j;
    for(i=2;i<=n;i++)			//依次将A[2]~A[n]插入到前面已排序序列
        if(A[i]<A[i-1]){		//若A[i]关键码小于其前驱，将A[i ]插入有序表
            A[0]=A[i];			//复制为哨兵，A[0]不存放元素
            for(j=i-1;A[0]<A[j];--j)//从后往前查找待插入位置
                A[j+1]=A[j];	//向后挪位
            A[j+1]=A[0];		//复制到插入位置
        }
}
~~~

带哨兵排序步骤：

1. 实际存放元素从$1$开始。会将当前排序元素复制到$A[0]$位置。

2. 接着对比左边元素，比当前元素大的都会后移，当左边某个元素大于或等于当前排序元素时，内层循环结束，将当前排序元素放在$j+1$的位置。

这样做的优点是不用没轮循环都判断$j\ge0$

算法效率分析：

- 空间复杂度：$O(1)$

- 时间复杂度：主要来自对比关键字、移动元素若有$n$个元素，则需要$n-1$趟处理

  最好情况(已经有序)：共$n-1$趟处理，每一趟只需要对比关键字$1$次，不用移动元素，则最好时间复杂度$O(n)$

  最坏情况(逆序)：每次都要移动元素。所以最坏时间复杂度$O(n^2)$。

  平均时间复杂度：$O(n^2)$

- 算法稳定性：相同两个元素，排序后相对位置不会改变，所以稳定。

- 适用性：可用于链表，也可用于顺序表。

### 1.2 算法优化

思路：之前都是用顺序查找方式移动元素，实际可用折半查找找到应该插入的位置，再移动元素

假设下面$55$之前元素已经有序，则优化插入排序步骤：

<img src="https://image.sybblogs.fun/img-common/202401041405310.png" alt="插入排序优化" style="zoom:50%;" />

- 首先`low=20;high=80`，则`mid=(low+high)/2=4`，即`mid`指向$50$元素。

  <img src="https://image.sybblogs.fun/img-common/202401041408233.png" alt="插入排序优化1" style="zoom: 50%;" />

- 由于$55>50$所以元素$55$可能插入再$50$元素的右边区间内。`low=mid+1;mid=(low+high)/2=6`，即`mid`指向$70$

  <img src="https://image.sybblogs.fun/img-common/202401041411493.png" alt="插入排序优化2" style="zoom:50%;" />

- 而$70>55$，所以$55$只可能插入在$70$元素左边区间。`high=mid-1;mid=(low+high)/2=5`，即`mid`指向$60$

  <img src="https://image.sybblogs.fun/img-common/202401041413490.png" alt="插入排序优化3" style="zoom: 50%;" />

- $60>55$，所以$55$只可能插入在$60$元素左边区间。`high=mid-1;`，此时`low>high`，故折半查找停止，应将`[low, i-1]`内的元素全部右移，并将`A[0]`复制到`low`所指位置。

  <img src="https://image.sybblogs.fun/img-common/202401041554748.png" alt="插入排序优化4" style="zoom:50%;" />

- 后面元素$60,90,10$同上，但要注意，当`mid`指向的元素和被查找元素相等时，**不应该停止查找**，为了算法稳定性，当元素相等时，我们应该在这个元素右边区间内查找。

代码实现：

~~~c
//折半插入排序
void InsertSort(int A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){			//依次将A[2]~A[n]插入前面的已排序序列
        A[0]=A[i];				//将A[i]暂存到A[0]
        low=1;high=i-1;			//设置折半查找的范围
        while(low<=high){		//折半查找(默认递增有序)
            mid=(low+high)/2;	//取中间点
            if(A[mid]>A[0]) high=mid-1; //查找左半子表
            else low=mid+1; 	//查找右半子表
        }
        for(j=i-1;j>=high+1;--j)
            A[j+1]=A[j];		//统一后移元素，空出插入位置
        A[high+1]=A[0];			//插入操作
    }
}
~~~

算法效率：

比起"直接插入排序"，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是$O(n^2)$

直接插入排序可以用于链表的排序。对于链表来说移动元素的次数变少了，但是关键字对比的次数依然是$O(n^2)$数量级,整体来看时间复杂度依然是$O(n^2)$

## 2. 希尔排序

希尔排序是对插入排序的优化。对于插入排序来说，如果要排序的元素基本有序，那么排序效率会高很多。而希尔排序核心思想是：先追求表中的元素部分有序，再逐渐逼近全局有序。

实现大致步骤：

1. 先将待排序表分割成若干形如$L[i,i+d,i + 2d,\cdots,i + kd]$的特殊子表。
2. 再对各个子表分别进行直接插入排序
3. 每次都缩小增量$d$，重复上述过程，直到$d=1$为止。

动画演示：

<img src="https://image.sybblogs.fun/img-common/202401041632826.gif" alt="希尔排序演示" style="zoom:50%;" />

例如：将下列表中元素进行升序排列

<img src="https://image.sybblogs.fun/img-common/202401041616177.png" alt="希尔排序" style="zoom: 50%;" />

步骤：

- 第一趟假设$d_1=\frac{n}{2}=4$，$n$为元素个数。将表中所有相距距离为$d(4)$的元素视为同一子表。

  <img src="https://image.sybblogs.fun/img-common/202401041618829.png" alt="希尔排序1" style="zoom:50%;" />

- 对上面四个子表进行直接插入排序。

  <img src="https://image.sybblogs.fun/img-common/202401041619812.png" alt="希尔排序2" style="zoom:50%;" />

- 第二趟假设$d_2=\frac{d_1}{2}=2$。将表中所有相距距离为$d(2)$的元素视为同一子表。

  <img src="https://image.sybblogs.fun/img-common/202401041621220.png" alt="希尔排序3" style="zoom:50%;" />

- 对上面各个子表进行直接插入排序。

  <img src="https://image.sybblogs.fun/img-common/202401041622568.png" alt="希尔排序4" style="zoom:50%;" />

- 接着第三趟$d_3=\frac{d_2}{2}=1$，此时所有元素都会划分为同一个子表。

  <img src="https://image.sybblogs.fun/img-common/202401041623177.png" alt="希尔排序5" style="zoom:50%;" />

- 整个表此时已呈现出基本有序，对整体再进行一次直接插入排序

  <img src="https://image.sybblogs.fun/img-common/202401041625285.png" alt="希尔排序6" style="zoom:50%;" />

上面例子中，每次将增量$d$缩小一半。这要是建议的做法。

代码实现：

~~~c
//希尔排序
void ShellSort(int A[] ,int n){
    int d,i,j;						//A[0]只是暂存单元,不是哨兵,当j<=0时,插入位置已到
    for(d=n/2; d>=1; d=d/2) 		//步长变化
        for(i=d+1; i<=n; ++i)
            if(A[i]<A[i-d]){		//需将A[i]插入有序增量子表
                A[0]=A[i];			//暂存在A[0]
                for(j= i-d; j>0 && A[0]<A[j]; j-=d)
                    A[j+d]=A[j];	//记录后移，查找插入的位置
                A[j+d]=A[0];		//插入
            }//if
}
~~~

> 上面内层第一个for循环中的`++i`，会让以$d$为间隔的子表轮流切换排序。

算法性能分析：

- 空间复杂度：$O(1)$

- 时间复杂度：根据$d_i$ 不同会受到影响目前无法用数学手段证明确切的时间复杂度。

  最坏时间复杂度：当$d=1$时，会直接变为插入排序。最坏时间复杂度为$O(n^2)$

  当数据元素$n$在某个范围内时，可达$O(n^{1.3})$

- 稳定性：不稳定

  <img src="https://image.sybblogs.fun/img-common/202401041711021.png" alt="希尔排序稳定性" style="zoom:50%;" />

- 适用性：仅适用于线性表，不能用于链表。

## 3. 冒泡排序

冒泡排序和快速排序一样属于交换排序的一种。

交换排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

<img src="https://image.sybblogs.fun/img-common/202401041725928.gif" alt="冒泡排序" style="zoom: 67%;" />

代码实现：

~~~c
//交换
void swap(int &a，int &b){
    int temp = a;
    a=b;
    b = temp;
}
//冒泡排序
void BubbleSort(int A[],int n){
    for(int i=0;i<n-1;i++){
        bool flag=false;			//表示本趟冒泡是否发生交换的标志
        for(int j=n-1;j>i;j--)		//一趟冒泡过程
            if(A[j-1]>A[j]){		//若为逆序
                swap(A[j-1],A[j]); 	//交换
                flag=true;	
            }
        if(flag==false)
            return;					//本趟遍历后没有发生交换，说明表已经有序
    }
}
~~~

注意：如果某一趟排序过程中未发生"交换"则算法可提前结束。

算法效率分析：

- 空间复杂度：$O(1)$

- 时间复杂度：

  最好情况(原本有序)：$O(n)$

  最坏情况(逆序)：$O(n^2)$

  平均情况：$O(n^2)$

- 稳定性：稳定
- 适用性：链表，顺序表都可用

## ==4. 快速排序==

算法实现思路：

在待排序表中任取一个元素作为枢轴(通常取首元素)。通过一趟排序，将待排序表划分为独立的两个部分。这两部分中，左半部分所有元素都小于枢轴元素；右半部分都大于枢轴元素，则枢轴元素确定其最终元素位置。这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在最终位置上，完成排序。

动画演示如下：

<img src="https://image.sybblogs.fun/img-common/202401051318963.gif" alt="快速排序演示" style="zoom: 67%;" />

代码如下：

~~~c
int partition(int arr[],int low,int high) {
	int tempA=arr[low];					//枢轴元素
	while(low<high) {					//用low、high搜索枢轴的最终位置
		while(low<high&&arr[high]>=tempA) high--;//比枢轴小的元素移动到左端,即low所指位置
		arr[low]=arr[high];
		while(low<high&&arr[low]<=tempA) low++;//比枢轴大的元素移动到右端,即high所指位置
		arr[high]=arr[low];
	}
	arr[low]=tempA;						//确定枢轴元素存放到最终位置
	return low;							//返回存放枢轴的最终位置
}

void quickSort(int arr[],int low,int high) {
	if(low<high) {
		int p=partition(arr,low,high);	//划分确定枢轴元素位置
		quickSort(arr,low,p-1);			//枢轴左边表进行递归确定位置
		quickSort(arr,p+1,high);		//右表确定位置
	}
}
~~~

效率分析：

<img src="https://image.sybblogs.fun/img-common/202401051342125.png" alt="快速排序效率分析" style="zoom:50%;" />

通过上图可以看出每一层只需要处理剩下蓝色部分待排序元素，所以时间复杂度不超过$O(n)$。即时间复杂度$O(n*递归层数)$

由于需要用到递归，层数越多用到空间越多，所以每一层空间复杂度是$O(递归层数)$

可以看出对于快速排序时间与空间复杂度分析必须要研究递归层数：

<img src="https://image.sybblogs.fun/img-common/202401051346515.png" alt="快速排序效率分析1" style="zoom:50%;" />

可以得出结论：快速排序就是把$n$个元素组织成二叉树，二叉树的层数就是递归调用的层数。所以可以将问题转换为二叉树高度求法。

$n$个结点二叉树最小高度$=\lfloor\log_2n\rfloor+1$；最大高度$=n$。

所以对于快速排序其最小递归层数$=\lfloor\log_2n\rfloor+1$，最大递归层数$=n$。即

- 最好时间复杂度是：$O(n\log_2n)$；

  最坏时间复杂度：$O(n^2)$

- 最好空间复杂度：$O(\log_2n)$

  最坏空间复杂度：$O(n)$

**快速排序是不稳定地算法**。

注意：若每一次选中的枢轴元素将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。若初始序列**有序或逆序**，则快速排序的性能最差(因为每次选择的都是最靠边的元素)。

基于上面分析，快速排序算法优化思路：尽量选择可以把数据中分的枢轴元素。如：

1. 选头、中、尾三个位置的元素，取中间值作为枢轴元素
2. 随机选一个元素作为枢轴元素

在实际应用当中快速排序是所有内部排序算法中平均性能最优的排序算法。

## 5. 简单选择排序

选择排序：每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列

选择排序分类：简单选择排序和堆排序。

算法思路：每一趟在待排序元素中选取关键字最小的元素加入有序子序列

动画演示：

<img src="https://image.sybblogs.fun/img-common/202401051410438.gif" alt="简单选择排序" style="zoom: 67%;" />

实现代码：

~~~c
//交换
void swap(int &a,int &b){
    a=a-b;
    b=a+b;
    a=b-a;
    
}

//简单选择排序
void SelectSort(int A[],int n){
    for(int i=0;i<n-1;i++){				//一共进行n-1趟
        int min=i;						//记录最小元素位置
        for(int j=i+1;j<n;j++)			//在A[i...n-1]中选择最小的元素
            if(A[j]<A[min]) min=j;		//更新最小元素位置
        if(min!=i)
            swap(A[i],A[min] );			//封装的swap( )函数移动元素
    }
}
~~~

算法效率分析：

- 时间复杂度：无论有序、逆序、还是乱序，一定需要$n-1$趟处理。所以时间复杂度$=O(n^2)$
- 空间复杂度：$O(1)$

- 稳定性：不稳定

适用性：即可用于顺序表，也可以用于链表。

## 6. 堆排序

堆排序的实现需要用到堆这种数据结构。堆这种数据结构又可以进一步划分为**大根堆**和**小根堆**。

堆结构和二叉树的顺序存储类似：

<img src="https://image.sybblogs.fun/img-common/202309252314777.png" alt="完全二叉树" style="zoom:50%;" />

二叉树顺序表中存储结构：

<img src="https://image.sybblogs.fun/img-common/202401061409545.png" alt="二叉树顺序存储回忆" style="zoom:50%;" />

几个重要操作：

- $i$号结点的左孩子：$2i$
- $i$号结点的右孩子：$2i+1$
- $i$号结点的父节点：$\lfloor  i/2\rfloor$
- $i$结点所在的层次：$\lceil\log_2(n+1)\rceil或\lfloor\log_2n\rfloor+1$

若完全二叉树中共有$n$个结点，则：

- 判断$i$是否有左孩子：$2i\le n?$
- 判断$i$是否有右孩子：$2i+1\le n?$
- 判断$i$是否是叶子$/$分支结点：$\lfloor i>n/2\rfloor?$

### 6.1 堆排序实现

堆结构也可以看作是一颗完全二叉树在顺序表存储结构：

<img src="https://image.sybblogs.fun/img-common/202401061410804.png" alt="大根堆" style="zoom:50%;" />

上图左边是存储结构，右边是逻辑结构。可以观察到大根堆就是在完全二叉树中，**所有的根结点$\ge$左右子树**。

所以堆排序步骤：

1. 首先将给定的随机序列表按照根结点$\ge$左右子树特点，将表转换为大根堆结构

   具体做法是检查二叉树中所有根结点是否满足根结点$\ge$左右子树这一特性，若不满足，与当前结点更大的孩子交换。

2. 由于大根堆表中第一个元素一定是最大元素，所以将其移动至表尾

3. 接着对剩下的表中元素再次进行大根堆结构恢复操作。

4. 依次循环上面三个步骤，直到所有最后表中只剩一个元素，排序结束

例子：给定以下序列表进行升序排序

<img src="https://image.sybblogs.fun/img-common/202401061421960.png" alt="大根堆排序" style="zoom:50%;" />

排序步骤：

- 首先将序列表组成的二叉树转换为大根堆结构。再顺序表的完全二叉树中，非终端结点的编号为$i\le\lfloor\frac{n}{2}\rfloor$。即第一个被处理根结点是$\frac{8}{2}=4$。即$9$元素。

- 对于$9$元素，其只有左孩子，并且左孩子$32>9$，所以交换位置

  <img src="https://image.sybblogs.fun/img-common/202401061448381.png" alt="大根堆排序1" style="zoom:50%;" />

- 接着处理$3$号结点，即$78$，其左右孩子为$65,87>78$，所以交换$78$和$87$位置

  <img src="https://image.sybblogs.fun/img-common/202401061450098.png" alt="大根堆排序2" style="zoom: 50%;" />

- 处理$2$号结点$17$，其左右孩子$32,45$，比左右孩子都小所以取最大的$45$交换

  <img src="https://image.sybblogs.fun/img-common/202401061452180.png" alt="大根堆排序3" style="zoom:50%;" />

- $1$号结点$53$比右孩子$87$小，所以交换

  <img src="https://image.sybblogs.fun/img-common/202401061454235.png" alt="大根堆排序4" style="zoom:50%;" />

- 交换后发现以$53$为根的子树仍然不平衡，继续用之前方法，$53$小于左右子树，所以挑最大的元素$78$交换

  <img src="https://image.sybblogs.fun/img-common/202401061455269.png" alt="大根堆排序5" style="zoom:50%;" />

- 此时，整个二叉树已经称为标准的大根堆结构，将序列表第一个元素换至表尾

  <img src="https://image.sybblogs.fun/img-common/202401061525674.png" alt="大根堆排序6" style="zoom:50%;" />

- 接着将剩下元素重新恢复大根堆结构。恢复后结构如下：

  <img src="https://image.sybblogs.fun/img-common/202401061528979.png" alt="大根堆排序7" style="zoom:50%;" />

- 此时已经完成第一趟处理，之后重复上述操作即可。经过$n-1$趟处理，将序列表变为有序表：

  <img src="https://image.sybblogs.fun/img-common/202401061529441.png" alt="大根堆排序8" style="zoom:50%;" />

注意：基于大根堆的堆排序，得到是递增序列，而基于小根堆得到的是递减序列。

实现代码：

~~~c
//将以k为根的子树调整为大根堆
void HeadAdjust(int A[],int k,int len){
    A[0]=A[k];					//A[0] 暂存子树的根结点
    for(int i=2*k;i<=len;i*=2){ //沿key较大的子结点向下筛选
        if(i<len&&A[i]<A[i+1])
            i++;				//取key较大的子结点的下标
        if(A[0]>=A[i]) break; 	//筛选结束
        else{
            A[k]=A[i];			//将A[i]调整到双亲结点上
            k=i;				//修改K值，以便继续向下筛选
        }
    }
    A[k]=A[0];					//被筛选结点的值放入最终位置
}

//建立大根堆
void BuildMaxHeap(int A[],int len){
    for(int i=len/2;i>0;i--)	//从后往前调整所有非终端结点
        HeadAdjust(A,i,len);
}

//堆排序的完整逻辑
void HeapSort(int A[],int len){
    BuildMaxHeap(A,len);		//初始建堆
    for(int i=len;i>1;i--){		//n-1趟的交换和建堆过程
        swap(A[i],A[1]);		//堆顶元素和堆底元素交换
        HeadAdjust(A,1,i-1);	//把剩余的待排序元素整理成堆
    }
}
~~~

算法效率分析：

由于所有操作都是基于`HeadAdjust()`这个函数的，所以要分析该函数效率：

由于一个结点每下坠一层，最多只需要对比关键字两次。若树高为$h$，某结点在第$i$层，则将这个结点向下调整最多只需要下坠$h-i$层，关键字对比次数不超过$2(h-i)$，$n$个结点的完全二叉树树高$h=\lfloor \log_2n\rfloor|+1$。

第$i$层最多有$2^{i-1}$个结点，而只有第$1\sim (h-1)$层的结点才有可能需要下坠调整。将整棵树调整为大根堆，关键字对比次数不超过：
$$
\begin{equation*}
	\begin{aligned}
&\sum_{i=h-1}^{1}2^{i-1}2(h-i)=\sum_{i=h-1}^{1}2^i(h-i)\\
\\
&=\sum_{j=1}^{h-1}2^{h-j}j\le 2n\sum_{j=1}^{h-1}\frac{j}{2^j}\le4n
	\end{aligned}
\end{equation*}
$$
所以，建堆的过程，关键字对比次数不超过$4n$，建堆时间复杂度$=O(n)$。

而`HeapSort()`中`for`循环排序过程中总共需要$n-1$趟调整，每趟调整都要将根结点下坠。而每次下坠最多只需要对比关键字$2$次，因此每一趟排序复杂度不超过$O(h)=O(\log_2n)$，所以总的时间复杂度是$O(n\log_2n)$。

- 堆排序总的时间复杂度$=O(n\log_2n)+O(n)=O(n\log_2n)$
- 总的空间复杂度$=O(1)$
- 稳定性：不稳定

### 6.2 堆的插入

假设以小根堆为例，对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这样一路上升，直到无法继续上升(根结点比新元素小)为止。

例：将下列小根堆中插入新元素$13$

<img src="https://image.sybblogs.fun/img-common/202401061600628.png" alt="堆的插入" style="zoom:50%;" />

- 首先将新元素$13$放入表尾，再和父结点进行对比，父结点是$\lfloor\frac{9}{2}\rfloor=4$，即元素$32$。而$32>13$，所以互换

  <img src="https://image.sybblogs.fun/img-common/202401061601513.png" alt="堆的插入1" style="zoom:50%;" />

- 接着继续和父结点$17$，对比，显然$13$更小，交换

  <img src="https://image.sybblogs.fun/img-common/202401061602284.png" alt="堆的插入2" style="zoom:50%;" />

- 接着和父结点$9$对比，$9<13$，所以不用交换结束，小根堆符合条件。

插入总共对比关键字$3$次。

### 6.3 堆的删除

首先从序列表中将被删除元素删除，接着将表尾元素替换到被删除元素位置，再进行小根堆恢复：被删除的元素用堆底元素替代，然后让该元素不断下坠，直到无法下坠为止。

例：将下列小根堆中删除$13$元素

<img src="https://image.sybblogs.fun/img-common/202401061606719.png" alt="堆的删除" style="zoom:50%;" />

- 首先删除$13$元素，将表位元素$46$移动到$13$位置，即下标为$2$的位置

  <img src="https://image.sybblogs.fun/img-common/202401061607534.png" alt="堆的删除1" style="zoom:50%;" />

- $46$和左右孩子进行对比，和最小的交换。即$17$和$46$交换

  <img src="https://image.sybblogs.fun/img-common/202401061608217.png" alt="堆的删除2" style="zoom:50%;" />

- 接着再和左右孩子对比，$46<32$，继续交换

  最后小根堆恢复

  <img src="https://image.sybblogs.fun/img-common/202401061610315.png" alt="堆的删除3" style="zoom:50%;" />

删除总共对比关键字$4$次。

## 7. 归并排序

