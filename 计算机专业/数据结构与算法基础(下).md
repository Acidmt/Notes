[toc]

# 十一. 排序

排序就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。

排序算法评价指标：

- 时间复杂度

- 空间复杂度

- 算法稳定性：指表中相同元素先后位置，经过排序后有没有相对的变动。

  <img src="https://image.sybblogs.fun/img-common/202401031746064.png" alt="排序的稳定性" style="zoom:50%;" />

  注意：稳定排序算法并不一定比不稳定的算法优秀，主要看实际需求。

排序算法分类：

1. 内部排序：数据都在内存中。更关注算法时间和空间复杂度
2. 外部排序：数据太多，无法全部放入内存。除了要关注算法时间和空间复杂度，还要关注如何使读$/$写磁盘次数更少。

<img src="https://image.sybblogs.fun/img-common/202401031750407.png" alt="排序的分类" style="zoom:50%;" />

## 1. 插入排序

算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。

动画演示：

<img src="https://image.sybblogs.fun/img-common/202401041338164.gif" alt="插入排序演示" style="zoom:50%;" />

### 1.1 算法实现及分析

排序从第二个元素开始，默认当前排序元素左边已经有序。只要比当前元素大的都往后移动，直到碰到比当前元素小(相等)的。

代码实现：

~~~c
//直接插入排序
void InsertSort(int A[],int n){
    int i,j, temp;
    for(i=1;i<n;i++)			//将各元素插入已排好序的序列中
        if(A[i]<A[i-1]){		//若A[i]关键字小于前驱
            temp=A[i];			//用temp暂存A[i]
            for(j=i-1;j>=0 && A[j]>temp;--j) //检查所有 前面已排好序的元素
                A[j+1]=A[j]; 	//所有大于temp的元素都向后挪位
            A[j+1]=temp;		//复制到插入位置
        }
}
~~~

带哨兵实现方法：

<img src="https://image.sybblogs.fun/img-common/202401041346735.png" alt="插入排序(哨兵法)" style="zoom:50%;" />

代码实现：

~~~c
//直接插入排序(带哨兵)
void InsertSort(int A[],int n){
    int i,j;
    for(i=2;i<=n;i++)			//依次将A[2]~A[n]插入到前面已排序序列
        if(A[i]<A[i-1]){		//若A[i]关键码小于其前驱，将A[i ]插入有序表
            A[0]=A[i];			//复制为哨兵，A[0]不存放元素
            for(j=i-1;A[0]<A[j];--j)//从后往前查找待插入位置
                A[j+1]=A[j];	//向后挪位
            A[j+1]=A[0];		//复制到插入位置
        }
}
~~~

带哨兵排序步骤：

1. 实际存放元素从$1$开始。会将当前排序元素复制到$A[0]$位置。

2. 接着对比左边元素，比当前元素大的都会后移，当左边某个元素大于或等于当前排序元素时，内层循环结束，将当前排序元素放在$j+1$的位置。

这样做的优点是不用没轮循环都判断$j\ge0$

算法效率分析：

- 空间复杂度：$O(1)$

- 时间复杂度：主要来自对比关键字、移动元素若有$n$个元素，则需要$n-1$趟处理

  最好情况(已经有序)：共$n-1$趟处理，每一趟只需要对比关键字$1$次，不用移动元素，则最好时间复杂度$O(n)$

  最坏情况(逆序)：每次都要移动元素。所以最坏时间复杂度$O(n^2)$。

  平均时间复杂度：$O(n^2)$

- 算法稳定性：相同两个元素，排序后相对位置不会改变，所以稳定。

- 适用性：可用于链表，也可用于顺序表。

### 1.2 算法优化

思路：之前都是用顺序查找方式移动元素，实际可用折半查找找到应该插入的位置，再移动元素

假设下面$55$之前元素已经有序，则优化插入排序步骤：

<img src="https://image.sybblogs.fun/img-common/202401041405310.png" alt="插入排序优化" style="zoom:50%;" />

- 首先`low=20;high=80`，则`mid=(low+high)/2=4`，即`mid`指向$50$元素。

  <img src="https://image.sybblogs.fun/img-common/202401041408233.png" alt="插入排序优化1" style="zoom: 50%;" />

- 由于$55>50$所以元素$55$可能插入再$50$元素的右边区间内。`low=mid+1;mid=(low+high)/2=6`，即`mid`指向$70$

  <img src="https://image.sybblogs.fun/img-common/202401041411493.png" alt="插入排序优化2" style="zoom:50%;" />

- 而$70>55$，所以$55$只可能插入在$70$元素左边区间。`high=mid-1;mid=(low+high)/2=5`，即`mid`指向$60$

  <img src="https://image.sybblogs.fun/img-common/202401041413490.png" alt="插入排序优化3" style="zoom: 50%;" />

- $60>55$，所以$55$只可能插入在$60$元素左边区间。`high=mid-1;`，此时`low>high`，故折半查找停止，应将`[low, i-1]`内的元素全部右移，并将`A[0]`复制到`low`所指位置。

  <img src="https://image.sybblogs.fun/img-common/202401041554748.png" alt="插入排序优化4" style="zoom:50%;" />

- 后面元素$60,90,10$同上，但要注意，当`mid`指向的元素和被查找元素相等时，**不应该停止查找**，为了算法稳定性，当元素相等时，我们应该在这个元素右边区间内查找。

代码实现：

~~~c
//折半插入排序
void InsertSort(int A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){			//依次将A[2]~A[n]插入前面的已排序序列
        A[0]=A[i];				//将A[i]暂存到A[0]
        low=1;high=i-1;			//设置折半查找的范围
        while(low<=high){		//折半查找(默认递增有序)
            mid=(low+high)/2;	//取中间点
            if(A[mid]>A[0]) high=mid-1; //查找左半子表
            else low=mid+1; 	//查找右半子表
        }
        for(j=i-1;j>=high+1;--j)
            A[j+1]=A[j];		//统一后移元素，空出插入位置
        A[high+1]=A[0];			//插入操作
    }
}
~~~

算法效率：

比起"直接插入排序"，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是$O(n^2)$

直接插入排序可以用于链表的排序。对于链表来说移动元素的次数变少了，但是关键字对比的次数依然是$O(n^2)$数量级,整体来看时间复杂度依然是$O(n^2)$

## 2. 希尔排序

希尔排序是对插入排序的优化。对于插入排序来说，如果要排序的元素基本有序，那么排序效率会高很多。而希尔排序核心思想是：先追求表中的元素部分有序，再逐渐逼近全局有序。

实现大致步骤：

1. 先将待排序表分割成若干形如$L[i,i+d,i + 2d,\cdots,i + kd]$的特殊子表。
2. 再对各个子表分别进行直接插入排序
3. 每次都缩小增量$d$，重复上述过程，直到$d=1$为止。

动画演示：

<img src="https://image.sybblogs.fun/img-common/202401041632826.gif" alt="希尔排序演示" style="zoom:50%;" />

例如：将下列表中元素进行升序排列

<img src="https://image.sybblogs.fun/img-common/202401041616177.png" alt="希尔排序" style="zoom: 50%;" />

步骤：

- 第一趟假设$d_1=\frac{n}{2}=4$，$n$为元素个数。将表中所有相距距离为$d(4)$的元素视为同一子表。

  <img src="https://image.sybblogs.fun/img-common/202401041618829.png" alt="希尔排序1" style="zoom:50%;" />

- 对上面四个子表进行直接插入排序。

  <img src="https://image.sybblogs.fun/img-common/202401041619812.png" alt="希尔排序2" style="zoom:50%;" />

- 第二趟假设$d_2=\frac{d_1}{2}=2$。将表中所有相距距离为$d(2)$的元素视为同一子表。

  <img src="https://image.sybblogs.fun/img-common/202401041621220.png" alt="希尔排序3" style="zoom:50%;" />

- 对上面各个子表进行直接插入排序。

  <img src="https://image.sybblogs.fun/img-common/202401041622568.png" alt="希尔排序4" style="zoom:50%;" />

- 接着第三趟$d_3=\frac{d_2}{2}=1$，此时所有元素都会划分为同一个子表。

  <img src="https://image.sybblogs.fun/img-common/202401041623177.png" alt="希尔排序5" style="zoom:50%;" />

- 整个表此时已呈现出基本有序，对整体再进行一次直接插入排序

  <img src="https://image.sybblogs.fun/img-common/202401041625285.png" alt="希尔排序6" style="zoom:50%;" />

上面例子中，每次将增量$d$缩小一半。这要是建议的做法。

代码实现：

~~~c
//希尔排序
void ShellSort(int A[] ,int n){
    int d,i,j;						//A[0]只是暂存单元,不是哨兵,当j<=0时,插入位置已到
    for(d=n/2; d>=1; d=d/2) 		//步长变化
        for(i=d+1; i<=n; ++i)
            if(A[i]<A[i-d]){		//需将A[i]插入有序增量子表
                A[0]=A[i];			//暂存在A[0]
                for(j= i-d; j>0 && A[0]<A[j]; j-=d)
                    A[j+d]=A[j];	//记录后移，查找插入的位置
                A[j+d]=A[0];		//插入
            }//if
}
~~~

> 上面内层第一个for循环中的`++i`，会让以$d$为间隔的子表轮流切换排序。

算法性能分析：

- 空间复杂度：$O(1)$

- 时间复杂度：根据$d_i$ 不同会受到影响目前无法用数学手段证明确切的时间复杂度。

  最坏时间复杂度：当$d=1$时，会直接变为插入排序。最坏时间复杂度为$O(n^2)$

  当数据元素$n$在某个范围内时，可达$O(n^{1.3})$

- 稳定性：不稳定

  <img src="https://image.sybblogs.fun/img-common/202401041711021.png" alt="希尔排序稳定性" style="zoom:50%;" />

- 适用性：仅适用于线性表，不能用于链表。

## 3. 冒泡排序

冒泡排序和快速排序一样属于交换排序的一种。

交换排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

<img src="https://image.sybblogs.fun/img-common/202401041725928.gif" alt="冒泡排序" style="zoom: 67%;" />

代码实现：

~~~c
//交换
void swap(int &a，int &b){
    int temp = a;
    a=b;
    b = temp;
}
//冒泡排序
void BubbleSort(int A[],int n){
    for(int i=0;i<n-1;i++){
        bool flag=false;			//表示本趟冒泡是否发生交换的标志
        for(int j=n-1;j>i;j--)		//一趟冒泡过程
            if(A[j-1]>A[j]){		//若为逆序
                swap(A[j-1],A[j]); 	//交换
                flag=true;	
            }
        if(flag==false)
            return;					//本趟遍历后没有发生交换，说明表已经有序
    }
}
~~~

注意：如果某一趟排序过程中未发生"交换"则算法可提前结束。

算法效率分析：

- 空间复杂度：$O(1)$

- 时间复杂度：

  最好情况(原本有序)：$O(n)$

  最坏情况(逆序)：$O(n^2)$

  平均情况：$O(n^2)$

- 稳定性：稳定
- 适用性：链表，顺序表都可用

## ==4. 快速排序==

算法实现思路：

在待排序表中任取一个元素作为枢轴(通常取首元素)。通过一趟排序，将待排序表划分为独立的两个部分。这两部分中，左半部分所有元素都小于枢轴元素；右半部分都大于枢轴元素，则枢轴元素确定其最终元素位置。这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在最终位置上，完成排序。

动画演示如下：

<img src="https://image.sybblogs.fun/img-common/202401051318963.gif" alt="快速排序演示" style="zoom: 67%;" />

代码如下：

~~~c
int partition(int arr[],int low,int high) {
	int tempA=arr[low];					//枢轴元素
	while(low<high) {					//用low、high搜索枢轴的最终位置
		while(low<high&&arr[high]>=tempA) high--;//比枢轴小的元素移动到左端,即low所指位置
		arr[low]=arr[high];
		while(low<high&&arr[low]<=tempA) low++;//比枢轴大的元素移动到右端,即high所指位置
		arr[high]=arr[low];
	}
	arr[low]=tempA;						//确定枢轴元素存放到最终位置
	return low;							//返回存放枢轴的最终位置
}

void quickSort(int arr[],int low,int high) {
	if(low<high) {
		int p=partition(arr,low,high);	//划分确定枢轴元素位置
		quickSort(arr,low,p-1);			//枢轴左边表进行递归确定位置
		quickSort(arr,p+1,high);		//右表确定位置
	}
}
~~~

效率分析：

<img src="https://image.sybblogs.fun/img-common/202401051342125.png" alt="快速排序效率分析" style="zoom:50%;" />

通过上图可以看出每一层只需要处理剩下蓝色部分待排序元素，所以时间复杂度不超过$O(n)$。即时间复杂度$O(n*递归层数)$

由于需要用到递归，层数越多用到空间越多，所以每一层空间复杂度是$O(递归层数)$

可以看出对于快速排序时间与空间复杂度分析必须要研究递归层数：

<img src="https://image.sybblogs.fun/img-common/202401051346515.png" alt="快速排序效率分析1" style="zoom:50%;" />

可以得出结论：快速排序就是把$n$个元素组织成二叉树，二叉树的层数就是递归调用的层数。所以可以将问题转换为二叉树高度求法。

$n$个结点二叉树最小高度$=\lfloor\log_2n\rfloor+1$；最大高度$=n$。

所以对于快速排序其最小递归层数$=\lfloor\log_2n\rfloor+1$，最大递归层数$=n$。即

- 最好时间复杂度是：$O(n\log_2n)$；

  最坏时间复杂度：$O(n^2)$

- 最好空间复杂度：$O(\log_2n)$

  最坏空间复杂度：$O(n)$

**快速排序是不稳定地算法**。

注意：若每一次选中的枢轴元素将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。若初始序列**有序或逆序**，则快速排序的性能最差(因为每次选择的都是最靠边的元素)。

基于上面分析，快速排序算法优化思路：尽量选择可以把数据中分的枢轴元素。如：

1. 选头、中、尾三个位置的元素，取中间值作为枢轴元素
2. 随机选一个元素作为枢轴元素

在实际应用当中快速排序是所有内部排序算法中平均性能最优的排序算法。

## 5. 简单选择排序

选择排序：每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列

选择排序分类：简单选择排序和堆排序。

算法思路：每一趟在待排序元素中选取关键字最小的元素加入有序子序列

动画演示：

<img src="https://image.sybblogs.fun/img-common/202401051410438.gif" alt="简单选择排序" style="zoom: 67%;" />

实现代码：

~~~c
//交换
void swap(int &a,int &b){
    a=a-b;
    b=a+b;
    a=b-a;
    
}

//简单选择排序
void SelectSort(int A[],int n){
    for(int i=0;i<n-1;i++){				//一共进行n-1趟
        int min=i;						//记录最小元素位置
        for(int j=i+1;j<n;j++)			//在A[i...n-1]中选择最小的元素
            if(A[j]<A[min]) min=j;		//更新最小元素位置
        if(min!=i)
            swap(A[i],A[min] );			//封装的swap( )函数移动元素
    }
}
~~~

算法效率分析：

- 时间复杂度：无论有序、逆序、还是乱序，一定需要$n-1$趟处理。所以时间复杂度$=O(n^2)$
- 空间复杂度：$O(1)$

- 稳定性：不稳定

适用性：即可用于顺序表，也可以用于链表。

## 6. 堆排序

