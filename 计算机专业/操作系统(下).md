[toc]

# 三. 内存管理

内存可存放数据。程序执行前需要先放到内存中才能被CPU处理，目的是为了缓和CPU与硬盘之间的速度矛盾。

由于在计算机组成原理知识可知指令中的地址是逻辑地址，而如何将逻辑地址转换为物理地址这里给出三种策略：绝对装入、可重定位装入(静态重定位)和动态运行时装入(动态重定位)。

- 绝对装入

  在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

  如：如果知道装入模块要从内存地址为$100$的地方开始存放，指令中的形式地址是$79$，编译器在编译的时候会将形式地址改为$179$，即装入模块起始位置往后$79$的位置是有效地址(EA)。这个有效地址也称绝对地址。

  前提是需要知道装入模块起始地址，而换一台电脑之后不能保证模块的起始地址还是从$100$位置开始存放，所以这种方式灵活性差，**只适用于单道程序环境。**也就是早起还没有操作系统的阶段使用。

- 可重定位装入(静态重定位)

  采用这种方式，编译、链接后的装入模块的地址都是从$0$开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行"重定位"，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。

  如果一个模块的起始地址是$100$，那么程序模块在装入内存时，所有的与地址相关的参数都会进行$+100$操作。

  <img src="https://image.sybblogs.fun/img-common/202402071420387.png" alt="可重定位装入" style="zoom: 33%;" />

  静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间(连续空间)，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

  这种方式用于用于早期的多道批处理操作系统。

- 动态运行时装入(动态重定位)

  编译、链接后的装入模块的地址都是从$0$开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。

  有一个专门用于存放模块起始位置的寄存器，即重定位寄存器。当一个模块装入内存后，模块在内存中的起始地址会放入重定位寄存器。之后指令中的逻辑地址(形式地址)$+$重定位寄存器中的值，即为有效地址。

  <img src="https://image.sybblogs.fun/img-common/202402071453270.png" alt="动态重定位" style="zoom:33%;" />

  采用动态重定位时允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中。在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

  这种方式用于现代操作系统。

程序的运行过程如下：

开发人员编写完代码之后，需要进行编译，由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)。这些模块已经包含目标代码所对应的指令，指令编址都是从逻辑地址$0$开始，相互独立的。

接着把目标模块都组装起来形成一个完整的装入模块。在Windows中装入模块就是exe可执行文件。此时装入模块有一个完整的链接地址。

最后把装入模块装入内存中即可。当装入内存中就确定了进程所对应的实际物理地址是多少。

<img src="https://image.sybblogs.fun/img-common/202402071506969.png" alt="程序的执行过程" style="zoom: 33%;" />

上面已经介绍了三种装入方式，但是链接的方式也有三种：

- 静态链接方式

  在程序运行之前，先将备目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)之后不再拆开。就是上面提到的方式。

- 装入时动态链接

  将各目标模块装入内存时，边装入边链接的链接方式。一边装入一边形成逻辑地址。

  <img src="https://image.sybblogs.fun/img-common/202402071509806.png" alt="装入时动态链接" style="zoom:33%;" />

- 运行时动态链接

  在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

  假如运行`main()`函数时用到`a()`函数，只需要将目标模块$1,2$装入内存即可，用不到的函数`b()`即目标模块$3$就不需要装入到内存。

  <img src="https://image.sybblogs.fun/img-common/202402071512623.png" alt="运行时动态链接" style="zoom: 33%;" />

内存基础知识总结：

<img src="https://image.sybblogs.fun/img-common/202402071514105.png" alt="内存基础知识总结" style="zoom:50%;" />

## 1. 内存管理

操作系统作为系统资源的管理者，当然也需要对内存进行管理。操作系统需要对内存进行以下几种管理：

1. 操作系统负责内存空间的分配与回收。

   程序装入内存后，操作系统要怎么记录哪些内存区域已经被分配出去了，哪些区域还处于空闲状体。当某个进程运行结束之后，要将进程占用的内存空间回收。当一个新的进程需要装入内存时操作系统应该指出放到哪片区域。

2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充

   某个游戏的大小超过60GB，按理来说这个游戏程序运行之前需要把60GB数据全部放入内存。然而，实际我的电脑内存才4GB，但操作系统使用虚拟技术(操作系统的虚拟性)，就可以运行。把物理上很小得内存拓展为逻辑上很大的内存。

3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。

   为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

   装入的方式有三种：绝对装入(编译时产生绝对地址)、可重定位装入(装入时将逻辑地址转换为物理地址)、动态运行时装入(运行时将逻辑地址转换为物理地址，需设置重定位寄存器)。 

4. 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

   让各个进程只能访问自己的内存空间。

   <img src="https://image.sybblogs.fun/img-common/202402071529076.png" alt="内存保护" style="zoom:50%;" />

   假设进程$1$的逻辑地址空间为$0\sim 179$，实际物理地址空间为$100\sim279$。内存保护的可以采取两种方法：

   方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。

   <img src="https://image.sybblogs.fun/img-common/202402071532368.png" alt="内存保护两种方式" style="zoom:50%;" />

   方法二：采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。

   <img src="https://image.sybblogs.fun/img-common/202402071534762.png" alt="内存保护两种方式2" style="zoom:50%;" />

   假如进程当前要访问一个逻辑地址为$80$的内存单元，首先逻辑地址会和界地址寄存器值进行对比，如果没有超过界地址寄存器种保存的最大逻辑地址的话，就认为这个地址是合法的。之后会和重定位寄存器的起始物理地址进行相加，最终就可以得到实际想要访问的物理地址。

### 1.1 内存空间的扩充

内存空间扩充技术有三种：覆盖技术、交换技术和虚拟存储技术(之后会介绍)

#### 覆盖技术

早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决"程序大小超过物理内存总和"的问题。

覆盖技术的思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。

具体的做法是内存中分为一个"固定区"和若干个"覆盖区"。需要常驻内存的段放在"固定区"中，调入后就不再调出(除非运行结束)不常用的段放在"覆盖区"，需要用到时调入内存，用不到时调出内存。

<img src="https://image.sybblogs.fun/img-common/202402071546038.png" alt="覆盖技术例子" style="zoom:50%;" />

如上图，A函数会依次调用B和C函数(注意是依次调用而不是同时调用)。B函数又会调用D函数，而C函数会依次调用E和F函数。

可以把A函数(包含main()函数)模块放到内存的固定去里，大小就是A模块的大小，即$8$k。另外由于B模块和C模块不可能同时访问，所以可以让B和C模块共享一个覆盖区即可，覆盖区大小为B和C模块中最大的，即$10$k。同样的D、E、F模块也会共享一个覆盖区，大小为其中最大的，即$12$k。

<img src="https://image.sybblogs.fun/img-common/202402071551232.png" alt="覆盖技术例子2" style="zoom:50%;" />

这样只用$30$k的大小就可以让程序顺利运行。

这种方式也有很明显的缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。所以对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

#### 交换技术

交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。

之前学到的中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。

<img src="https://image.sybblogs.fun/img-common/202402071556361.png" alt="交换技术" style="zoom:50%;" />

暂时换出外存等待的进程状态为挂起状态(挂起态，suspend)。挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。在加入这两种状态后就有了七状态模型。

<img src="https://image.sybblogs.fun/img-common/202402071557039.png" alt="七状态" style="zoom: 33%;" />

而此时会产生第一个问题，应该在外存(磁盘)的什么位置保存被换出的进程？

具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式。对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的$I/O$速度比文件区的更快。

<img src="https://image.sybblogs.fun/img-common/202402071600846.png" alt="对换区和文件区" style="zoom:50%;" />

第二个问题是什么时候应该交换？

交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程。如果缺页率明显下降，就可以暂停换出。

第三个问题是应该换出哪些进程？

可优先换出阻塞进程。可换出优先级低的进程。为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。

注意：PCB会常驻内存，不会被换出外存。所以操作系统换出进程并不是将所有的数据都放入外存，操作系统为了保持对换出进程的管理，进程的PCB信息还是会放在内存中进行管理。

覆盖与交换总结：

<img src="https://image.sybblogs.fun/img-common/202402071606830.png" alt="覆盖与交换总结" style="zoom:50%;" />

### 1.2 连续分配方式

内存空间的分配与回收有两种方式：连续分配方式和非连续分配方式。连续分配方式又可以进一步细分为：单一连续分配、固定分区分配、动态分区分配。

连续分配：指为用户进程分配的必须是一个连续的内存空间。非连续分配：为用户进程分配的是一个离散的内存空间。

#### 单一连续分配

在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间，并不支持多道程序并发运行。

<img src="https://image.sybblogs.fun/img-common/202402071625703.png" alt="单一连续分配" style="zoom: 33%;" />

当一个用户进程所需内存空间很小，但放入内存的用户区之后，用户去中其他的空闲区间，也不会分配给别的用户程序。所以说是整个用户程序独占整个用户区的存储空间。

<img src="https://image.sybblogs.fun/img-common/202402071628341.png" alt="单一连续分配2" style="zoom:33%;" />

所以优点：实现简单。无外部碎片。可以采用覆盖技术扩充内存。不一定需要采取内存保护(如：早期的PC操作系统MS-DOS)

缺点：只能用于单用户、单任务的操作系统中。有内部碎片。存储器利用率极低。

内部碎片是指分配给某进程的内存区域中，如果有些部分没有用就是"内部碎片"。

#### 固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

固定分区分配策略有两种：分区大小相等和分区大小不等。

如果采用分区大小相当这种策略，系统会把用户区整片的内存区间分割为若干个固定大小相等的区域。

<img src="https://image.sybblogs.fun/img-common/202402071634609.png" alt="分区大小相等" style="zoom:33%;" />

如果采用分区大小相当这种策略，系统会把用户区整片的内存区间分割为大小固定，但各个分区大小不相等的区域。

<img src="https://image.sybblogs.fun/img-common/202402071635705.png" alt="分区大小不相等" style="zoom:33%;" />

分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如：钢铁厂有$n$个相同的炼钢炉，就可把内存分为$n$个大小相等的区域存放$n$个炼钢炉控制程序)。

而分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)。

另外操作系统需要建立一个数据结构，即分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。

<img src="https://image.sybblogs.fun/img-common/202402071635705.png" alt="分区大小不相等" style="zoom:33%;" />

如果某个系统分区如下图所示，则对应的分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071641774.png" alt="分区说明表" style="zoom: 50%;" />

用数据结构的数组(或链表)即可表示这个表。当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为"已分配"。

优点：实现简单，无外部碎片。

缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。同时会产生内部碎片，内存利用率低。

#### 动态分区分配

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

如：假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB。则进程$1$占用20MB、进程$2$占14MB、进程$3$占用18MB。

<img src="https://image.sybblogs.fun/img-common/202402071646900.png" alt="动态分区分配" style="zoom:50%;" />

这样会产生三个问题：

1. 系统要用什么样的数据结构记录内存的使用情况?

   系统中的分区的大小和数量会变的，并且有的分区已经分配，而有的没有分配，所以需要用一个数据结构表示。

2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?

   如上图，此时进程$2$运行结束，移除内存。如果有一个4MB的进程到达，这个新到达的进程要放到哪个内存空间是一个问题。

3. 如何进行分区的分配与回收操作?

   假设进程$3$运行结束，移除内存。此时会空出18MB的内存空间，那么这$18$MB空闲分区处理是要和其他合并还是要进行其他操作。

接下来会详细介绍这三个问题。

- 系统要用什么样的数据结构记录内存的使用情况?

  会采用两种常用的数据结构：空闲分区表和空闲分区链。

  <img src="https://image.sybblogs.fun/img-common/202402071654689.png" alt="分区" style="zoom:50%;" />

  上图如果建立一个空闲分区表，则每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。

  <img src="https://image.sybblogs.fun/img-common/202402071655949.png" alt="分区表" style="zoom:50%;" />

  如果建立一个分区链，则每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

  <img src="https://image.sybblogs.fun/img-common/202402071656154.png" alt="分区链" style="zoom:50%;" />

- 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?

  假如现在有一个进程$5$，有$4$MB，存放在上图空闲分区中，要选那一块进行存放？

  把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。

- 如何进行分区的分配与回收操作?

  这里以数据表结构为例演示分配操作，数据链原理类似。

  情况一：

  <img src="https://image.sybblogs.fun/img-common/202402071702293.png" alt="动态分配" style="zoom: 33%;" />

  如上图所示，假设当前有一个进程$5$(4MB)，需要分配，如果采用某种算法确定进程$5$要放在$20$MB的空闲分区中，即分区$1$号。分配好的内存如下：

  <img src="https://image.sybblogs.fun/img-common/202402071703563.png" alt="动态分配2" style="zoom: 33%;" />

  分配完毕后需要修改分区表，修改好的分区表如下：

  <img src="https://image.sybblogs.fun/img-common/202402071705805.png" alt="动态分配3" style="zoom: 50%;" />

  情况二：

  同样，如果采用某种算法确定进程$5$要放在$4$MB的空闲分区中，即分区$3$号。分配好的内存如下：

  <img src="https://image.sybblogs.fun/img-common/202402071706083.png" alt="动态分配4" style="zoom: 33%;" />

  分配完毕后需要修改分区表，这里直接删除分区$3$号空闲区：

  <img src="https://image.sybblogs.fun/img-common/202402071707915.png" alt="动态分配5" style="zoom:50%;" />

  回收也有几种情况：

  情况一：回收区的后面有一个相邻的空闲分区

  假设进程$4$已经运行结束，可以把进程$4$的$4$MB的空间回收。

  <img src="https://image.sybblogs.fun/img-common/202402071710354.png" alt="动态分配6" style="zoom:50%;" />

  此时这块回收区域的后面有一个10MB的空闲分区，因此在这块内存分区回收后，需要将这块空间与10MB的合并：

  <img src="https://image.sybblogs.fun/img-common/202402071711705.png" alt="动态分配7" style="zoom:50%;" />

  合并需要修改分区表：

  <img src="https://image.sybblogs.fun/img-common/202402071711098.png" alt="动态分配8" style="zoom:50%;" />

  所以两个相邻的空闲分区合并为一个。

  情况二：回收区的前面有一个相邻的空闲分区。解决方法同情况一，都是这及将两个空闲区合并为一个。

  情况三：回收区的前、后各有一个相邻的空闲分区

  <img src="https://image.sybblogs.fun/img-common/202402071713320.png" alt="动态分配9" style="zoom:50%;" />

  假设进程$4$运行结束，此时前后都有空闲的分区，此时需要将三块空间都进行合并。

  <img src="https://image.sybblogs.fun/img-common/202402071715281.png" alt="动态分配11" style="zoom: 50%;" />

  合并分区表如下：

  <img src="https://image.sybblogs.fun/img-common/202402071716720.png" alt="动态分配10" style="zoom:50%;" />

  情况四：回收区的前、后都没有相邻的空闲分区

  <img src="https://image.sybblogs.fun/img-common/202402071717229.png" alt="动态分配12" style="zoom:50%;" />

  此时进程$2$运行结束，此时分区表需要新增一个空闲区：

  <img src="https://image.sybblogs.fun/img-common/202402071718228.png" alt="动态分配13" style="zoom:50%;" />

注：新增一个表项时，各表项的顺序不一定按照上面地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。

动态分区分配没有内部碎片，但是有外部碎片。

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上就是内部碎片。
外部碎片：是指内存中的某些空闲分区由于太小而难以利用。

<img src="https://image.sybblogs.fun/img-common/202402071722741.png" alt="内部碎片" style="zoom:50%;" />

如上图所示，假设此时有一个进程$5$所需要$20$MB内存空间，但上面每个空闲分区都不够，所以这些空闲的小分区就是外部碎片。如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些"碎片"不能满足进程的需求。可以通过紧凑(拼凑，Compaction) 技术来解决外部碎片。

如上图，虽然每个空闲区都不够进程$5$放入，但空闲区的总和正好是$20$MB。此时使用紧凑技术就是将内存中各个进程挪位，腾出一个更到的空闲区。

<img src="https://image.sybblogs.fun/img-common/202402071726640.png" alt="内部碎片2" style="zoom:50%;" />

前面介绍的三种装入方式当中，动态重定位方式显然最方便实现这些进程在内存中移动位置这件事。其实就是将进程起始地址放入重定位寄存器中。

连续分配管理总结：

<img src="https://image.sybblogs.fun/img-common/202402071731028.png" alt="连续分配管理总结" style="zoom: 50%;" />

### 1.3 动态分区分配算法

用于解决在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配的问题。

动态分区分配算法有四种：首次适应算法(First Fit)、最佳适应算法(Best Fit)、最坏适应算法(Worst Fit)、邻近适应算法(Next Fit)。

#### 首次适应算法

算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

实现方式：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071917218.png" alt="首次适应算法" style="zoom:50%;" />

某个系统中内存分配如上图所示，采用首次适应算法对应的空闲分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071918826.png" alt="首次适应算法分区表" style="zoom:50%;" />

上面是按照起始地址由低到高排列。对应的空闲分区链如下：

<img src="https://image.sybblogs.fun/img-common/202402071919572.png" alt="首次适应算法分区链" style="zoom:50%;" />

以空闲分区链为例，当有一个进程$5$(15MB)，其分配到内存中的情况根据首次适应算法的规则，从空闲分区链的链头依次查找找到第一个能够满足大小的分区。经过检查发现第一个$20$字节的空闲分区已经可以满足要求，所以将进程$5$分配给$20$MB的空闲分区中。

<img src="https://image.sybblogs.fun/img-common/202402071925944.png" alt="首次适应算法分区链1" style="zoom:50%;" />

此时这里剩余$5$MB剩余空间，修改空闲分区链

<img src="https://image.sybblogs.fun/img-common/202402071926429.png" alt="首次适应算法分区链2" style="zoom:50%;" />

如果再来一个进程$6$(8MB)，使用首次适应算法，依次从空闲分区链表头部检查，直到第二个空闲分区$10$MB的可以满足。所以将进程$6$放入空闲分区，此时这个空闲分区还剩$2$MB。最后修改链表对应的位置空闲值即可。

#### 最佳适应算法

算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当"大进程"到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。

实现方式：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。即找到的第一个空闲分区一定是能满足进程所需空间，并且最小的空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071934451.png" alt="最佳适应算法" style="zoom:50%;" />

如果系统中的内存使用情况如上图所示。对应的空闲分区链和空闲分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071935941.png" alt="最佳适应算法分区表和分区链" style="zoom:50%;" />

是按照空闲分区从小到大递增的顺序排列。假如当前有一个新进程$6$(9MB)，根据最佳适应算法，从空闲分区链表表头开始遍历找到第一个能满足新进程大小的分区即可(同时也能满足是进程所需的最小空闲分区)。这里是第二个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071939503.png" alt="最佳适应算法分区表和分区链1" style="zoom:50%;" />

由于最佳适应算法的空闲分区链和空闲分区表需要按照空闲大小的递增次序排列，所以这里新进程占据空闲分区大小为$10$MB的分区后，需要修改空闲分区链。

<img src="https://image.sybblogs.fun/img-common/202402071940834.png" alt="最佳适应算法分区表和分区链2" style="zoom:50%;" />

缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。

#### 最坏适应算法

又称最大适应算法(Largest Fit)，与最佳适应算法相反，算法思想是为了解决最佳适应算法的问题，即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

实现方式：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071934451.png" alt="最佳适应算法" style="zoom:50%;" />

如果系统中的内存使用情况如上图所示。对应的空闲分区链和空闲分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071944765.png" alt="最坏适应分区表和分区链" style="zoom:50%;" />

此时有个新进行$5$(3MB)，按照最坏适应算法遍历，从空闲分区链表表头开始遍历找到第一个能满足新进程大小的分区即可(同时也能满足是进程所需的最大空闲分区)。这里是第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071945423.png" alt="最坏适应分区表和分区链1" style="zoom:50%;" />

同时修改分区链和分区表：

<img src="https://image.sybblogs.fun/img-common/202402071945923.png" alt="最坏适应分区表和分区链2" style="zoom:50%;" />

如果有另一个新进程$6$(9MB)，按照最坏适应算法遍历，从空闲分区链表表头开始遍历找到第一个能满足新进程大小的分区即可(同时也能满足是进程所需的最大空闲分区)。这里是第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071947076.png" alt="最坏适应分区表和分区链3" style="zoom:50%;" />

同时修改空闲分区链，修改后第一个空闲分区变为$8$MB，为了维持最坏适应算法递减次序的规则，需要对空闲分区链进行修改。

<img src="https://image.sybblogs.fun/img-common/202402071948967.png" alt="最坏适应分区表和分区链4" style="zoom:50%;" />

缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之，后有"大进程"到达，就没有内存分区可用了。

#### 邻近适应算法

算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

实现方式：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071953870.png" alt="邻近适应算法" style="zoom:50%;" />

如果系统中的内存使用情况如上图所示。对应的空闲分区链表如下：

<img src="https://image.sybblogs.fun/img-common/202402071953824.png" alt="邻近适应算法分区链" style="zoom:50%;" />

此时有一个新进程$5$(5MB)，根据邻近适应算法，由于是第一次遍历，需要从头遍历。所以第二个$6$MB空闲分区能满足。

<img src="https://image.sybblogs.fun/img-common/202402071955382.png" alt="邻近适应算法分区链1" style="zoom:50%;" />

同时修改空闲分区链

<img src="https://image.sybblogs.fun/img-common/202402071956083.png" alt="邻近适应算法分区链2" style="zoom:50%;" />

可以看到采用邻近适应算法和首次适应算法，只需要按照地址递增的次序进行排列即可。所以这里发生内存空闲分区变化，也不用对整个链表进行重现排列。这也是邻近适应算法和首次适应算法比最佳适应算法、最坏适应算法更优秀的地方。

假如又有一个进程$6$(5MB)，按照邻近适应算法规则，只需要从上一次查找到的位置依次往后查找即可。即从第二个结点开始往后遍历，发现第三个结点能够满足。

<img src="https://image.sybblogs.fun/img-common/202402072000460.png" alt="邻近适应算法分区链3" style="zoom:50%;" />

修改空闲分区链

<img src="https://image.sybblogs.fun/img-common/202402072000054.png" alt="邻近适应算法分区链4" style="zoom:50%;" />

可以看出邻近适应算法不需要从链头位置重新遍历，所以比首次适应算法更快。但这也并不代表比首次适应算法更优秀。

首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(所以首次适应算法包含了最佳适应算法的优点)。

邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了与首次适应算法相比，高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(邻近适应算法拥有最坏适应算法的缺点)。

四种算法中，首次适应算法的效果最好。

四种动态分区分配算法总结：

<img src="https://image.sybblogs.fun/img-common/202402072005932.png" alt="四种算法对比" style="zoom:50%;" />