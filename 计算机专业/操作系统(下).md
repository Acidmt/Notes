[toc]

# 三. 内存管理

内存可存放数据。程序执行前需要先放到内存中才能被CPU处理，目的是为了缓和CPU与硬盘之间的速度矛盾。

由于在计算机组成原理知识可知指令中的地址是逻辑地址，而如何将逻辑地址转换为物理地址这里给出三种策略：绝对装入、可重定位装入(静态重定位)和动态运行时装入(动态重定位)。

- 绝对装入

  在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

  如：如果知道装入模块要从内存地址为$100$的地方开始存放，指令中的形式地址是$79$，编译器在编译的时候会将形式地址改为$179$，即装入模块起始位置往后$79$的位置是有效地址(EA)。这个有效地址也称绝对地址。

  前提是需要知道装入模块起始地址，而换一台电脑之后不能保证模块的起始地址还是从$100$位置开始存放，所以这种方式灵活性差，**只适用于单道程序环境。**也就是早起还没有操作系统的阶段使用。

- 可重定位装入(静态重定位)

  采用这种方式，编译、链接后的装入模块的地址都是从$0$开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行"重定位"，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。

  如果一个模块的起始地址是$100$，那么程序模块在装入内存时，所有的与地址相关的参数都会进行$+100$操作。

  <img src="https://image.sybblogs.fun/img-common/202402071420387.png" alt="可重定位装入" style="zoom: 33%;" />

  静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间(连续空间)，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

  这种方式用于用于早期的多道批处理操作系统。

- 动态运行时装入(动态重定位)

  编译、链接后的装入模块的地址都是从$0$开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。

  有一个专门用于存放模块起始位置的寄存器，即重定位寄存器。当一个模块装入内存后，模块在内存中的起始地址会放入重定位寄存器。之后指令中的逻辑地址(形式地址)$+$重定位寄存器中的值，即为有效地址。

  <img src="https://image.sybblogs.fun/img-common/202402071453270.png" alt="动态重定位" style="zoom:33%;" />

  采用动态重定位时允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中。在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

  这种方式用于现代操作系统。

程序的运行过程如下：

开发人员编写完代码之后，需要进行编译，由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)。这些模块已经包含目标代码所对应的指令，指令编址都是从逻辑地址$0$开始，相互独立的。

接着把目标模块都组装起来形成一个完整的装入模块。在Windows中装入模块就是exe可执行文件。此时装入模块有一个完整的链接地址。

最后把装入模块装入内存中即可。当装入内存中就确定了进程所对应的实际物理地址是多少。

<img src="https://image.sybblogs.fun/img-common/202402071506969.png" alt="程序的执行过程" style="zoom: 33%;" />

上面已经介绍了三种装入方式，但是链接的方式也有三种：

- 静态链接方式

  在程序运行之前，先将备目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)之后不再拆开。就是上面提到的方式。

- 装入时动态链接

  将各目标模块装入内存时，边装入边链接的链接方式。一边装入一边形成逻辑地址。

  <img src="https://image.sybblogs.fun/img-common/202402071509806.png" alt="装入时动态链接" style="zoom:33%;" />

- 运行时动态链接

  在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

  假如运行`main()`函数时用到`a()`函数，只需要将目标模块$1,2$装入内存即可，用不到的函数`b()`即目标模块$3$就不需要装入到内存。

  <img src="https://image.sybblogs.fun/img-common/202402071512623.png" alt="运行时动态链接" style="zoom: 33%;" />

内存基础知识总结：

<img src="https://image.sybblogs.fun/img-common/202402071514105.png" alt="内存基础知识总结" style="zoom:50%;" />

## 1. 内存管理的概念

操作系统作为系统资源的管理者，当然也需要对内存进行管理。操作系统需要对内存进行以下几种管理：

1. 操作系统负责内存空间的分配与回收。

   程序装入内存后，操作系统要怎么记录哪些内存区域已经被分配出去了，哪些区域还处于空闲状体。当某个进程运行结束之后，要将进程占用的内存空间回收。当一个新的进程需要装入内存时操作系统应该指出放到哪片区域。

2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充

   某个游戏的大小超过60GB，按理来说这个游戏程序运行之前需要把60GB数据全部放入内存。然而，实际我的电脑内存才4GB，但操作系统使用虚拟技术(操作系统的虚拟性)，就可以运行。把物理上很小得内存拓展为逻辑上很大的内存。

3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。

   为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

   装入的方式有三种：绝对装入(编译时产生绝对地址)、可重定位装入(装入时将逻辑地址转换为物理地址)、动态运行时装入(运行时将逻辑地址转换为物理地址，需设置重定位寄存器)。 

4. 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

   让各个进程只能访问自己的内存空间。

   <img src="https://image.sybblogs.fun/img-common/202402071529076.png" alt="内存保护" style="zoom:50%;" />

   假设进程$1$的逻辑地址空间为$0\sim 179$，实际物理地址空间为$100\sim279$。内存保护的可以采取两种方法：

   方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。

   <img src="https://image.sybblogs.fun/img-common/202402071532368.png" alt="内存保护两种方式" style="zoom:50%;" />

   方法二：采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。

   <img src="https://image.sybblogs.fun/img-common/202402071534762.png" alt="内存保护两种方式2" style="zoom:50%;" />

   假如进程当前要访问一个逻辑地址为$80$的内存单元，首先逻辑地址会和界地址寄存器值进行对比，如果没有超过界地址寄存器种保存的最大逻辑地址的话，就认为这个地址是合法的。之后会和重定位寄存器的起始物理地址进行相加，最终就可以得到实际想要访问的物理地址。

## 2 内存空间的扩充

内存空间扩充技术有三种：覆盖技术、交换技术和虚拟存储技术(之后会介绍)

### 2.1 覆盖技术

早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决"程序大小超过物理内存总和"的问题。

覆盖技术的思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。

具体的做法是内存中分为一个"固定区"和若干个"覆盖区"。需要常驻内存的段放在"固定区"中，调入后就不再调出(除非运行结束)不常用的段放在"覆盖区"，需要用到时调入内存，用不到时调出内存。

<img src="https://image.sybblogs.fun/img-common/202402071546038.png" alt="覆盖技术例子" style="zoom:50%;" />

如上图，A函数会依次调用B和C函数(注意是依次调用而不是同时调用)。B函数又会调用D函数，而C函数会依次调用E和F函数。

可以把A函数(包含main()函数)模块放到内存的固定去里，大小就是A模块的大小，即$8$k。另外由于B模块和C模块不可能同时访问，所以可以让B和C模块共享一个覆盖区即可，覆盖区大小为B和C模块中最大的，即$10$k。同样的D、E、F模块也会共享一个覆盖区，大小为其中最大的，即$12$k。

<img src="https://image.sybblogs.fun/img-common/202402071551232.png" alt="覆盖技术例子2" style="zoom:50%;" />

这样只用$30$k的大小就可以让程序顺利运行。

这种方式也有很明显的缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。所以对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

### 2.2 交换技术

交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。

之前学到的中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。

<img src="https://image.sybblogs.fun/img-common/202402071556361.png" alt="交换技术" style="zoom:50%;" />

暂时换出外存等待的进程状态为挂起状态(挂起态，suspend)。挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。在加入这两种状态后就有了七状态模型。

<img src="https://image.sybblogs.fun/img-common/202402071557039.png" alt="七状态" style="zoom: 33%;" />

而此时会产生第一个问题，应该在外存(磁盘)的什么位置保存被换出的进程？

具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式。对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的$I/O$速度比文件区的更快。

<img src="https://image.sybblogs.fun/img-common/202402071600846.png" alt="对换区和文件区" style="zoom:50%;" />

第二个问题是什么时候应该交换？

交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程。如果缺页率明显下降，就可以暂停换出。

第三个问题是应该换出哪些进程？

可优先换出阻塞进程。可换出优先级低的进程。为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。

注意：PCB会常驻内存，不会被换出外存。所以操作系统换出进程并不是将所有的数据都放入外存，操作系统为了保持对换出进程的管理，进程的PCB信息还是会放在内存中进行管理。

覆盖与交换总结：

<img src="https://image.sybblogs.fun/img-common/202402071606830.png" alt="覆盖与交换总结" style="zoom:50%;" />

## 3 连续分配方式

内存空间的分配与回收有两种方式：连续分配方式和非连续分配方式。连续分配方式又可以进一步细分为：单一连续分配、固定分区分配、动态分区分配。

连续分配：指为用户进程分配的必须是一个连续的内存空间。非连续分配：为用户进程分配的是一个离散的内存空间。

### 3.1 分配方式

#### 单一连续分配

在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间，并不支持多道程序并发运行。

<img src="https://image.sybblogs.fun/img-common/202402071625703.png" alt="单一连续分配" style="zoom: 33%;" />

当一个用户进程所需内存空间很小，但放入内存的用户区之后，用户去中其他的空闲区间，也不会分配给别的用户程序。所以说是整个用户程序独占整个用户区的存储空间。

<img src="https://image.sybblogs.fun/img-common/202402071628341.png" alt="单一连续分配2" style="zoom:33%;" />

所以优点：实现简单。无外部碎片。可以采用覆盖技术扩充内存。不一定需要采取内存保护(如：早期的PC操作系统MS-DOS)

缺点：只能用于单用户、单任务的操作系统中。有内部碎片。存储器利用率极低。

内部碎片是指分配给某进程的内存区域中，如果有些部分没有用就是"内部碎片"。

#### 固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

固定分区分配策略有两种：分区大小相等和分区大小不等。

如果采用分区大小相当这种策略，系统会把用户区整片的内存区间分割为若干个固定大小相等的区域。

<img src="https://image.sybblogs.fun/img-common/202402071634609.png" alt="分区大小相等" style="zoom:33%;" />

如果采用分区大小相当这种策略，系统会把用户区整片的内存区间分割为大小固定，但各个分区大小不相等的区域。

<img src="https://image.sybblogs.fun/img-common/202402071635705.png" alt="分区大小不相等" style="zoom:33%;" />

分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如：钢铁厂有$n$个相同的炼钢炉，就可把内存分为$n$个大小相等的区域存放$n$个炼钢炉控制程序)。

而分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)。

另外操作系统需要建立一个数据结构，即分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。

<img src="https://image.sybblogs.fun/img-common/202402071635705.png" alt="分区大小不相等" style="zoom:33%;" />

如果某个系统分区如下图所示，则对应的分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071641774.png" alt="分区说明表" style="zoom: 50%;" />

用数据结构的数组(或链表)即可表示这个表。当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为"已分配"。

优点：实现简单，无外部碎片。

缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。同时会产生内部碎片，内存利用率低。

#### 动态分区分配

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

如：假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB。则进程$1$占用20MB、进程$2$占14MB、进程$3$占用18MB。

<img src="https://image.sybblogs.fun/img-common/202402071646900.png" alt="动态分区分配" style="zoom:50%;" />

这样会产生三个问题：

1. 系统要用什么样的数据结构记录内存的使用情况?

   系统中的分区的大小和数量会变的，并且有的分区已经分配，而有的没有分配，所以需要用一个数据结构表示。

2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?

   如上图，此时进程$2$运行结束，移除内存。如果有一个4MB的进程到达，这个新到达的进程要放到哪个内存空间是一个问题。

3. 如何进行分区的分配与回收操作?

   假设进程$3$运行结束，移除内存。此时会空出18MB的内存空间，那么这$18$MB空闲分区处理是要和其他合并还是要进行其他操作。

接下来会详细介绍这三个问题。

- 系统要用什么样的数据结构记录内存的使用情况?

  会采用两种常用的数据结构：空闲分区表和空闲分区链。

  <img src="https://image.sybblogs.fun/img-common/202402071654689.png" alt="分区" style="zoom:50%;" />

  上图如果建立一个空闲分区表，则每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。

  <img src="https://image.sybblogs.fun/img-common/202402071655949.png" alt="分区表" style="zoom:50%;" />

  如果建立一个分区链，则每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

  <img src="https://image.sybblogs.fun/img-common/202402071656154.png" alt="分区链" style="zoom:50%;" />

- 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?

  假如现在有一个进程$5$，有$4$MB，存放在上图空闲分区中，要选那一块进行存放？

  把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。

- 如何进行分区的分配与回收操作?

  这里以数据表结构为例演示分配操作，数据链原理类似。

  情况一：

  <img src="https://image.sybblogs.fun/img-common/202402071702293.png" alt="动态分配" style="zoom: 33%;" />

  如上图所示，假设当前有一个进程$5$(4MB)，需要分配，如果采用某种算法确定进程$5$要放在$20$MB的空闲分区中，即分区$1$号。分配好的内存如下：

  <img src="https://image.sybblogs.fun/img-common/202402071703563.png" alt="动态分配2" style="zoom: 33%;" />

  分配完毕后需要修改分区表，修改好的分区表如下：

  <img src="https://image.sybblogs.fun/img-common/202402071705805.png" alt="动态分配3" style="zoom: 50%;" />

  情况二：

  同样，如果采用某种算法确定进程$5$要放在$4$MB的空闲分区中，即分区$3$号。分配好的内存如下：

  <img src="https://image.sybblogs.fun/img-common/202402071706083.png" alt="动态分配4" style="zoom: 33%;" />

  分配完毕后需要修改分区表，这里直接删除分区$3$号空闲区：

  <img src="https://image.sybblogs.fun/img-common/202402071707915.png" alt="动态分配5" style="zoom:50%;" />

  回收也有几种情况：

  情况一：回收区的后面有一个相邻的空闲分区

  假设进程$4$已经运行结束，可以把进程$4$的$4$MB的空间回收。

  <img src="https://image.sybblogs.fun/img-common/202402071710354.png" alt="动态分配6" style="zoom:50%;" />

  此时这块回收区域的后面有一个10MB的空闲分区，因此在这块内存分区回收后，需要将这块空间与10MB的合并：

  <img src="https://image.sybblogs.fun/img-common/202402071711705.png" alt="动态分配7" style="zoom:50%;" />

  合并需要修改分区表：

  <img src="https://image.sybblogs.fun/img-common/202402071711098.png" alt="动态分配8" style="zoom:50%;" />

  所以两个相邻的空闲分区合并为一个。

  情况二：回收区的前面有一个相邻的空闲分区。解决方法同情况一，都是这及将两个空闲区合并为一个。

  情况三：回收区的前、后各有一个相邻的空闲分区

  <img src="https://image.sybblogs.fun/img-common/202402071713320.png" alt="动态分配9" style="zoom:50%;" />

  假设进程$4$运行结束，此时前后都有空闲的分区，此时需要将三块空间都进行合并。

  <img src="https://image.sybblogs.fun/img-common/202402071715281.png" alt="动态分配11" style="zoom: 50%;" />

  合并分区表如下：

  <img src="https://image.sybblogs.fun/img-common/202402071716720.png" alt="动态分配10" style="zoom:50%;" />

  情况四：回收区的前、后都没有相邻的空闲分区

  <img src="https://image.sybblogs.fun/img-common/202402071717229.png" alt="动态分配12" style="zoom:50%;" />

  此时进程$2$运行结束，此时分区表需要新增一个空闲区：

  <img src="https://image.sybblogs.fun/img-common/202402071718228.png" alt="动态分配13" style="zoom:50%;" />

注：新增一个表项时，各表项的顺序不一定按照上面地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。

动态分区分配没有内部碎片，但是有外部碎片。

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上就是内部碎片。
外部碎片：是指内存中的某些空闲分区由于太小而难以利用。

<img src="https://image.sybblogs.fun/img-common/202402071722741.png" alt="内部碎片" style="zoom:50%;" />

如上图所示，假设此时有一个进程$5$所需要$20$MB内存空间，但上面每个空闲分区都不够，所以这些空闲的小分区就是外部碎片。如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些"碎片"不能满足进程的需求。可以通过紧凑(拼凑，Compaction) 技术来解决外部碎片。

如上图，虽然每个空闲区都不够进程$5$放入，但空闲区的总和正好是$20$MB。此时使用紧凑技术就是将内存中各个进程挪位，腾出一个更到的空闲区。

<img src="https://image.sybblogs.fun/img-common/202402071726640.png" alt="内部碎片2" style="zoom:50%;" />

前面介绍的三种装入方式当中，动态重定位方式显然最方便实现这些进程在内存中移动位置这件事。其实就是将进程起始地址放入重定位寄存器中。

连续分配管理总结：

<img src="https://image.sybblogs.fun/img-common/202402071731028.png" alt="连续分配管理总结" style="zoom: 50%;" />

### 3.2 动态分区分配算法

用于解决在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配的问题。

动态分区分配算法有四种：首次适应算法(First Fit)、最佳适应算法(Best Fit)、最坏适应算法(Worst Fit)、邻近适应算法(Next Fit)。

#### 首次适应算法

算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

实现方式：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071917218.png" alt="首次适应算法" style="zoom:50%;" />

某个系统中内存分配如上图所示，采用首次适应算法对应的空闲分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071918826.png" alt="首次适应算法分区表" style="zoom:50%;" />

上面是按照起始地址由低到高排列。对应的空闲分区链如下：

<img src="https://image.sybblogs.fun/img-common/202402071919572.png" alt="首次适应算法分区链" style="zoom:50%;" />

以空闲分区链为例，当有一个进程$5$(15MB)，其分配到内存中的情况根据首次适应算法的规则，从空闲分区链的链头依次查找找到第一个能够满足大小的分区。经过检查发现第一个$20$字节的空闲分区已经可以满足要求，所以将进程$5$分配给$20$MB的空闲分区中。

<img src="https://image.sybblogs.fun/img-common/202402071925944.png" alt="首次适应算法分区链1" style="zoom:50%;" />

此时这里剩余$5$MB剩余空间，修改空闲分区链

<img src="https://image.sybblogs.fun/img-common/202402071926429.png" alt="首次适应算法分区链2" style="zoom:50%;" />

如果再来一个进程$6$(8MB)，使用首次适应算法，依次从空闲分区链表头部检查，直到第二个空闲分区$10$MB的可以满足。所以将进程$6$放入空闲分区，此时这个空闲分区还剩$2$MB。最后修改链表对应的位置空闲值即可。

#### 最佳适应算法

算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当"大进程"到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。

实现方式：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。即找到的第一个空闲分区一定是能满足进程所需空间，并且最小的空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071934451.png" alt="最佳适应算法" style="zoom:50%;" />

如果系统中的内存使用情况如上图所示。对应的空闲分区链和空闲分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071935941.png" alt="最佳适应算法分区表和分区链" style="zoom:50%;" />

是按照空闲分区从小到大递增的顺序排列。假如当前有一个新进程$6$(9MB)，根据最佳适应算法，从空闲分区链表表头开始遍历找到第一个能满足新进程大小的分区即可(同时也能满足是进程所需的最小空闲分区)。这里是第二个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071939503.png" alt="最佳适应算法分区表和分区链1" style="zoom:50%;" />

由于最佳适应算法的空闲分区链和空闲分区表需要按照空闲大小的递增次序排列，所以这里新进程占据空闲分区大小为$10$MB的分区后，需要修改空闲分区链。

<img src="https://image.sybblogs.fun/img-common/202402071940834.png" alt="最佳适应算法分区表和分区链2" style="zoom:50%;" />

缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。

#### 最坏适应算法

又称最大适应算法(Largest Fit)，与最佳适应算法相反，算法思想是为了解决最佳适应算法的问题，即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

实现方式：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071934451.png" alt="最佳适应算法" style="zoom:50%;" />

如果系统中的内存使用情况如上图所示。对应的空闲分区链和空闲分区表如下：

<img src="https://image.sybblogs.fun/img-common/202402071944765.png" alt="最坏适应分区表和分区链" style="zoom:50%;" />

此时有个新进行$5$(3MB)，按照最坏适应算法遍历，从空闲分区链表表头开始遍历找到第一个能满足新进程大小的分区即可(同时也能满足是进程所需的最大空闲分区)。这里是第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071945423.png" alt="最坏适应分区表和分区链1" style="zoom:50%;" />

同时修改分区链和分区表：

<img src="https://image.sybblogs.fun/img-common/202402071945923.png" alt="最坏适应分区表和分区链2" style="zoom:50%;" />

如果有另一个新进程$6$(9MB)，按照最坏适应算法遍历，从空闲分区链表表头开始遍历找到第一个能满足新进程大小的分区即可(同时也能满足是进程所需的最大空闲分区)。这里是第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071947076.png" alt="最坏适应分区表和分区链3" style="zoom:50%;" />

同时修改空闲分区链，修改后第一个空闲分区变为$8$MB，为了维持最坏适应算法递减次序的规则，需要对空闲分区链进行修改。

<img src="https://image.sybblogs.fun/img-common/202402071948967.png" alt="最坏适应分区表和分区链4" style="zoom:50%;" />

缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之，后有"大进程"到达，就没有内存分区可用了。

#### 邻近适应算法

算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

实现方式：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

<img src="https://image.sybblogs.fun/img-common/202402071953870.png" alt="邻近适应算法" style="zoom:50%;" />

如果系统中的内存使用情况如上图所示。对应的空闲分区链表如下：

<img src="https://image.sybblogs.fun/img-common/202402071953824.png" alt="邻近适应算法分区链" style="zoom:50%;" />

此时有一个新进程$5$(5MB)，根据邻近适应算法，由于是第一次遍历，需要从头遍历。所以第二个$6$MB空闲分区能满足。

<img src="https://image.sybblogs.fun/img-common/202402071955382.png" alt="邻近适应算法分区链1" style="zoom:50%;" />

同时修改空闲分区链

<img src="https://image.sybblogs.fun/img-common/202402071956083.png" alt="邻近适应算法分区链2" style="zoom:50%;" />

可以看到采用邻近适应算法和首次适应算法，只需要按照地址递增的次序进行排列即可。所以这里发生内存空闲分区变化，也不用对整个链表进行重现排列。这也是邻近适应算法和首次适应算法比最佳适应算法、最坏适应算法更优秀的地方。

假如又有一个进程$6$(5MB)，按照邻近适应算法规则，只需要从上一次查找到的位置依次往后查找即可。即从第二个结点开始往后遍历，发现第三个结点能够满足。

<img src="https://image.sybblogs.fun/img-common/202402072000460.png" alt="邻近适应算法分区链3" style="zoom:50%;" />

修改空闲分区链

<img src="https://image.sybblogs.fun/img-common/202402072000054.png" alt="邻近适应算法分区链4" style="zoom:50%;" />

可以看出邻近适应算法不需要从链头位置重新遍历，所以比首次适应算法更快。但这也并不代表比首次适应算法更优秀。

首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(所以首次适应算法包含了最佳适应算法的优点)。

邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了与首次适应算法相比，高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(邻近适应算法拥有最坏适应算法的缺点)。

四种算法中，首次适应算法的效果最好。

四种动态分区分配算法总结：

<img src="https://image.sybblogs.fun/img-common/202402072005932.png" alt="四种算法对比" style="zoom:50%;" />

## 4. 非连续分配的管理方式

非连续分配：为用户进程分配的可以是一些分散的内存空间。

如果一个系统支持分页存储的话，那么系统会把内存分为一个一个大小相等的区域。

<img src="https://image.sybblogs.fun/img-common/202402081304439.png" alt="分页存储" style="zoom: 33%;" />

如上图所示每个区域是4KB。每个分区就是一个"页框"(页框$=$页帧$=$内存块$=$物理块$=$物理页面)。每个页框有一个编号，即"页框号"(页框号$=$页帧号$=$内存块号$=$物理块号$=$物理页号)，页框号从$0$开始。

为了把进程数据和指令放入页框中，操作系统会把各个进程的逻辑地址空间分为与页框大小相等的单元。

<img src="https://image.sybblogs.fun/img-common/202402081310676.png" alt="分页存储进程" style="zoom:33%;" />

某个进程逻辑地址空间如上图所示，可以看到该进程是一个大小为$16$KB的进程，所以如果某个系统内存中页框大小是$4$KB，则该进程分为与内存页框相等的部分，因此每个部分是$4$KB。

<img src="https://image.sybblogs.fun/img-common/202402081312465.png" alt="分页存储进程2" style="zoom:50%;" />

上面将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个"页"或"页面"，每个页面也有一个编号，即"页号"。页号也是从0开始。如上图系统给进程的各个进行编号，这个编号就是"页号"(如`进程A_0`)或者叫页编号。进程的各个页会被放到内存的各个页框当中，即操作系统以页框为单位为各个进程分配内存空间，所以进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。

<img src="https://image.sybblogs.fun/img-common/202402081318526.png" alt="分页存储进程3" style="zoom:33%;" />

同时各个页面不必连续存放，可以放到不相邻的各个页框中。

这种一一对应的关系需要用数据结构"**页表**"来记录。即为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。而页表通常存在PCB(进程控制块)中。

上面提到过，进程的逻辑地址空间会被分为一个个的页面。每一个页面就会对应页表当中的一个页表项(一行)。而每个页表项由"页号"和"块号"组成。

<img src="https://image.sybblogs.fun/img-common/202402081326308.png" alt="页表" style="zoom:50%;" />

所以这样一个页表就可以记录下来进程各个页对应的实际存放的内存块之间的映射关系。

<img src="https://image.sybblogs.fun/img-common/202402081328593.png" alt="页表表示" style="zoom: 33%;" />

- 问题一

  假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节?

  内存块大小$=$页面大小$=4$KB$=2^{12}$B。则$4$GB的内存总共会被分为$\frac{2^{32}}{2^{12}}=2^{20}$个内存块。因此给内存块编号块号的范围应该是$0\sim2^{20}-1$。如果用二进制表示，则至少需要$20$bit位才能表示。而计算机分配空间是以字节为单位，所以至少要用$3$B来表示块号($3*8=24$bit)。因此一个页表项当中块号至少要占$3$B。

  而对于页号，页表项是连续存放的，因此页号可以是隐含的，不占存储空间(类比数组)。假设页表中的各页表项从内存地址为$X$的地方开始连续存放，则$i$号页表项的存放地址$=X+3*i$。由于页号是隐含的，因此每个页表项占$3$B，存储整个页表至少需要$3*(n+1)$B。

  注意：页表记录的只是内存块号，而不是内存块的起始地址。$J$号内存块的起始地址$=J*内存块大小$。

- 问题二

  将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换?

  特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的。

  <img src="https://image.sybblogs.fun/img-common/202402081348637.png" alt="地址转换" style="zoom: 33%;" />

  如果要访问逻辑地址$A$，则：

  1. 先确定逻辑地址$A$对应的页号$P$。

  2. 找到$P$号页面在内存中的起始地址(需要查页表)
  3. 确定逻辑地址$A$的页内偏移量$W$

  因为页面内部是连续存放的，所以
  $$
  逻辑地址A对应的物理地址=P号页面在内存中的起始地址+页内偏移量W
  $$
  如：在某计算机系统中，页面大小是$50$B。某进程逻辑地址空间大小为$200$B，则逻辑地址$110$对应的页号、页内偏移量是多少?

  <img src="https://image.sybblogs.fun/img-common/202402081355113.png" alt="确定逻辑地址的页号" style="zoom:33%;" />

  计算方法：
  $$
  \begin{equation*}
  	\begin{aligned}
  &页号=逻辑地址/页面长度(取除法的整数部分)\\
  \\
  &页内偏移量=逻辑地址\%页面长度(取除法的余数部分)
  	\end{aligned}
  \end{equation*}
  $$
  所以$页号=110/50=2$，$页内偏移量=110\%50=10$

在计算机内部，地址是用二进制表示的，如果页面大小刚好是$2$的整数幂，则计算机硬件可以很快速的把逻辑地址拆分成(页号，页内偏移量)

假设某计算机用$32$个二进制位表示逻辑地址，页面大小为$4$KB$=2^{12}$B$=4096$B

<img src="https://image.sybblogs.fun/img-common/202402081407441.png" alt="确定逻辑地址的页号2" style="zoom:50%;" />

后$12$位代表页内偏移量，前$20$位代表第几页。

<img src="https://image.sybblogs.fun/img-common/202402081655627.png" alt="确定逻辑地址的页号3" style="zoom:50%;" />

结论$1$：如果每个页面大小为$2$KB，用二进制数表示逻辑地址，则末尾$K$位即为页内偏移量，其余部分就是页号。

假设通过查询页表得知$1$号页面存放的内存块号是$9(1001)$，则$9$号内存块的起始地址$=9*4096$$=00000000000000001001\quad000000000000$
则逻辑地址$4097$对应的物理地址$=$页面在内存中存放的起始地址$+$页内偏移量$=$$(00000000000000001001\quad000000000001)$

结论$2$：如果页面大小刚好是$2$的整数幂，则只需把页表中记录的物理块号拼接上页内偏移量就能得到对应的物理地址。

总结：页面大小刚好是$2$的整数幂有以下好处：

1. 逻辑地址的拆分更加迅速，如果每个页面大小为$2$KB，用二进制数表示逻辑地址，则末尾$K$位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为$2$的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。
2. 物理地址的计算更加迅速，根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。

所以分页存储管理的逻辑地址结构如下所示：

<img src="https://image.sybblogs.fun/img-common/202402081714563.png" alt="逻辑地址结构" style="zoom:50%;" />

如果有$K$位表示"页内偏移量"，则说明该系统中一个页面的大小是$2$K个内存单元。如果有$M$位表示"页号"，则说明在该系统中，一个进程最多允许有$2$M个页面。页面大小、业内偏移量和逻辑地址结构三个关系如下：
$$
页面大小\Longleftrightarrow页内偏移量位数\Longrightarrow逻辑地址结构
$$

### 4.1 基本分页存储管理

#### ==基本地址变换机构==

所谓的基本地址变换机构就是在基本分页存储管理当中，用于实现逻辑地址到物理地址转换的一组硬件机构。这里要掌握原理和流程。

在分页存储管理当中，如果要把逻辑地址转换成物理地址，需要知道逻辑地址对应的页号、逻辑地址对应的页内偏移量、逻辑地址对应的页面在内存中存放的位置、最后根据页面在内存当中的起始位置和页内偏移量就可以得到最终的物理地址。

为了实现这个地址转换的功能，系统中会设置一个**页表寄存器**，用来存放页表在内存中的起始地址$F$和页表长度$M$。进程未执行时，页表的起始地址和页表长度放在进程控制块(PEB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

设页面大小为$L$，逻辑地址$A$到物理地址$E$的变换过程如下：

1. 计算页号$P$和页内偏移量$W$(如果用十进制数手算，则$P=A/L$，$W=A\%L$。但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)。
2. 比较页号$P$和页表长度$M$，若$P\ge M$，则产生越界中断，否则继续执行。(注意：页号是从$0$开始的，而页表长度至少是$1$，因此$P=M$时也会越界)
3. 页表中页号$P$对应的页表项地址$=$页表起始地址$F+$页号$P*$页表项长度，取出该页表项内容$b$，即为内存块号。(注意区分页表项长度、 页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页。页表项长度指的是每个页表项占多大的存储空间。页面大小指的是一个页面占多大的存储空间)。
4. 计算$E=b*L+W$，用得到的物理地址E去访存。( 如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)

<img src="https://image.sybblogs.fun/img-common/202402081739658.png" alt="逻辑地址转换为物理地址过程" style="zoom: 33%;" />

例：若页面大小L为$1$K字节，页号$2$对应的内存块号$b=8$，将逻辑地址$A=2500$转换为物理地址$E$。

等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占$10$位(说明一个页面的大小为$2^{10}$B$=1$KB)，页号$2$对应的内存块号$b=8$，将逻辑地址$A=2500$转换为物理地址$E$。计算如下：

1. 计算页号、页内偏移量

   页号P$=\frac{A}{L}=\frac{2500}{1024}=2$；页内偏移量W$=A\%L=2500\%1024$$=452$

2. 根据题中条件可知，页号$2$没有越界，起存放的内存块号$b=8$

3. 物理地址$E=b*L+W=8*1024+425=8644$

在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

上小节知道每个页表项的长度是相同的，页号是"隐含"的。假设某系统物理内存大小为4GB，页面大小为4KB，内存总共会被分为$2^{32}/2^{12}=2^{20}$个内存块，因此内存块号的范围应该是$0\sim2^{20}-1$。因此至少要$20$个二进制位才能表示这么多的内存块号，所以至少要$3$个字节才够(每个字节$8$个二进制位，$3$个字节共$24$个二进制位)。

<img src="https://image.sybblogs.fun/img-common/202402081755997.png" alt="页表项的进一步探讨" style="zoom:50%;" />

各页表项会按顺序连续地存放在内存中。如果该页表在内存中存放的起始地址为$X$，则$M$号页对应的页表项是存放在内存地址为$X+3*M$。一个页面为$4$KB，则每个页框可以存放$4096/3=1365$个页表项，但是这个页框会剩余$4096\%3=1$B页内碎片。因此，$1365$号页表项存放的地址为$X+ 3*1365 +1$。

<img src="https://image.sybblogs.fun/img-common/202402081757074.png" alt="页表项的进一步探讨2" style="zoom:50%;" />

但如果每个页表项占$4$字节，则每个页框刚好可存放$1024$个页表项。1024号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用$X+4*1024$得出。因为这个页框中没有任何碎片。

<img src="https://image.sybblogs.fun/img-common/202402081800751.png" alt="页表项的进一步探讨3" style="zoom:50%;" />

结论：理论上，页表项长度为$3$B即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项。

上面例子也可以看出进程页表通常是装在连续的内存块中的。

基本地址变换结构总结：

<img src="https://image.sybblogs.fun/img-common/202402081807544.png" alt="基本地址变换结构总结" style="zoom:50%;" />

可以看出在根据逻辑地址计算出物理地址访问内存单元的整个过程中，总共需要两次访问内存的操作。第一次访问内存是在查询页表的时候，第二次访问内存是在是在实际访问内存单元的时候进行的。

#### 具有快表的地址变换机构

是基本地址变换机构的改进版本。在基本地址变换机构的基础上引入快表，就可以让地址变换的过程更快。

快表，又称联想寄存器(TLB，translation lookaside buffer )，是一种访问速度比内存快很多的高速缓存(TLB不是内存)，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。

引入快表后，地址的变换过程：

1. CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存(注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)

<img src="https://image.sybblogs.fun/img-common/202402081825879.png" alt="基本地址快表变换机构" style="zoom: 33%;" />

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为缓存的局部性原理，一般来说快表的命中率可以达到$90$%以上。

例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时$1$us，访问一次内存耗时$100$us。若快表的命中率为$90$%，那么访问一个逻辑地址的平均耗时是多少?

访问依次命中后还需要花$100$us时间访存，且这样情况概率为$90\%$。但如果没有缓存命中，则需要访问两次缓存再加上一次快表时间，这样情况概率为$10\%$。故访问一个逻辑地址的平均耗时是$(1+100)*0.9+(1+100+100)*0.1=111us$。

而有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是$(1+100) * 0.9+(100+100)*0.1=110.9$us。

快表慢表同时查找的甘特图如下：

<img src="https://image.sybblogs.fun/img-common/202402081913942.png" alt="快表慢表一起查找" style="zoom: 33%;" />

可以很直观看到，当快表查询同时，慢表也在查询，经过$1$us时间后，如果快表缓存没有命中，那么此时慢表已经查了$1$us。再接着查慢表即可。

具有快表的地址变换机构与基本地址变换机构对比：

<img src="https://image.sybblogs.fun/img-common/202402081916883.png" alt="具有快表的地址变换机构与基本地址变换机构对比" style="zoom: 33%;" />

TLB和普通Cache的区别：TLB中只有页表项的副本，而普通Cache中可能会有其他各种数据的副本。

### 4.2 两级页表

某计算机系统按字节寻址，支持$32$位的逻辑地址，采用分页存储管理，页面大小为$4$KB，页表项长度为$4$B。

$4$KB$=2^{12}$B，因此页内地址要用$12$位表示，剩余$20$位表示页号。因此，该系统中用户进程最多有$2^{20}$页。相应的，一个进程的页表中，最多会有$2^{20}=1M=1048576$个页表项，所以一个页表最大需要$2^{20}*4B=2^{22}$B，共需要$2^{22}/2^{12}=2^{10}$个页框存储该页表。

根据页号查询页表的方法：$K$号页对应的页表项存放位置$=$页表始址$+$K$*4$，要在所有的页表项都连续存放的基础上才能用这种方法找到页表项。所以需要专门给进程分配$2^{10}=1024$个连续的框来存放它的页表。

根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。

所以单级页表页表有以下问题：

1. 问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。
2. 问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

#### 解决单级页表第一个问题

问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。

解决第一个问题可以参考解决进程在内存中必须连续存储的问题，做法是将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置。同样的思路也可用于解决"页表必须连续存放"的问题，把必须连续存放的页表再分页。

具体的做法是：

可将长长的页表进行分组，使每个内存块刚好可以放入一个分组(比如上个例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组， 每组刚好占一个内存块，再将各组离散地放到各个内存块中)另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表。

假如：某计算机系统按字节寻址，支持$32$位的逻辑地址，采用分页存储管理，页面大小为$4$KB，页表项长度为$4$B。

<img src="https://image.sybblogs.fun/img-common/202402081937919.png" alt="两级页表" style="zoom:50%;" />

由于单级页表的长度过大，所以可以将这个页表拆分成一个个的小分组，每个小分组的大小刚好可以装入一个内存块。由于每个页面的大小是$4$KB，每个页表项的大小是$4$B，所以一个页面可以存放$4K/4=2^{10}=1024$个页表项。因此可以将该页表拆分成一个个的小分组，每个分组页表项有$1024$个。

<img src="https://image.sybblogs.fun/img-common/202402081938256.png" alt="两级页表2" style="zoom:50%;" />

另外可以对这些小页表进行编号(如$0\#$号页表)，进行这样的拆分后，最后就会形成$1024$个小页表。

在把大页表拆分成小页表之后，由于每一个页表的大小都是$4$KB，因此每个小页表都可以依次放入不同的内存块中。

<img src="https://image.sybblogs.fun/img-common/202402081942613.png" alt="两级页表3" style="zoom: 33%;" />

为了记录这些小页表之间的相对顺序，以及在内存中存放的块号位置，需要为这些小页表再建立更上一级的页表，及**页目录表**(或者叫顶级页表、处层页表)。相应的这层小页表可以统称为二级页表。

<img src="https://image.sybblogs.fun/img-common/202402081952064.png" alt="页目录表" style="zoom:50%;" />

从这个图中可以直观看出，页目录表其实是建立了，二级页表的页号，及二级页表在内存中存放的块号之间的映射关系。

<img src="https://image.sybblogs.fun/img-common/202402081954102.png" alt="页目录表2" style="zoom: 33%;" />

所以此时如果想找$0$号页表可以通过页目录表就可以知道，$0$号页表存放在$3$号内存卡中，只需要在主存$3$号内存块中找$0$号页表即可。

采用这样的两级页表结构后逻辑地址的结构也需要发生变化。可以把以前$20$位的页号拆分成两个部分，第一个部分是$10$位的二进制用来表示一级页号。第二部分也是$10$位二进制用来表示二级页号。$10$位一级页号刚好可以表示$0\sim1023$这样的范围。相应的二级页号用来表示二级页表的页号。

<img src="https://image.sybblogs.fun/img-common/202402082007352.png" alt="两级页表的逻辑地址结构" style="zoom: 50%;" />

例：将逻辑地址$0000000000,0000000001,1111111111$转换为物理地址(用十进制表示)。

1. 按照地址结构将逻辑地址拆分成三部分

2. 从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置

   假设页目录表如下所示：

   <img src="https://image.sybblogs.fun/img-common/202402082011436.png" alt="页目录表的位置" style="zoom:50%;" />

   则其一级页号转化为十进制是$0$，所以对应内存块号是$3$

   <img src="https://image.sybblogs.fun/img-common/202402082012495.png" alt="页目录表的位置2" style="zoom: 50%;" />

3. 根据二级页号查表，找到最终想访问的内存块号

   可以从这个位置读出二级页表，再用二级页号进行查询。

   <img src="https://image.sybblogs.fun/img-common/202402082012397.png" alt="页目录表的位置3" style="zoom:50%;" />

   二级页号转换为十进制是$1$，所以对应的内存块号是$4$，即要访问的地址是在$4$号内存块中。

   <img src="https://image.sybblogs.fun/img-common/202402082014104.png" alt="页目录表的位置4" style="zoom:50%;" />

4. 结合页内偏移量得到物理地址

   最终要访问的内存块号为$4$，并且每个内存块大小是$1$KB，所以该内存块的起始地址为$4* 4096=16384$。且逻辑地址页内偏移量转换为十进制是$1023$，故最终的物理地址为$16384+1023=17407$。

#### 解决单级页表第二个问题

问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

可以在需要访问页面时才把页面调入内存(虚拟存储技术)。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。

<img src="https://image.sybblogs.fun/img-common/202402082020367.png" alt="虚拟存储" style="zoom:50%;" />

若想访问的页面不在内存中，则产生缺页中断(内中断)，然后将目标页面从外存调入内存。之后会有更详细介绍。

需要注意的细节：

1. 若采用多级页表机制，则**各级页表的大小不能超过一个页面**

   例：某系统按字节编址，采用$40$位逻辑地址，页面大小为$4$KB，页表项大小为$4$B，假设采用纯页式存储，则要采用()级页表，页内偏移量为多少位?

   页面大小$=4$KB$=2^{12}$B，按字节编址，因此页内偏移量为$12$位。所以页号$=40-12=28$位。

   页面大小$=2^{12}$B，页表项大小$=4$B，则每个页面可存放$2^{12}/4 =2^{10}$个页表项。因此各级页表最多包含$2^{10}$个页表项，需要$10$位二进制位才能映射到$2^{10}$个页表项，因此每一级的页表对应页号应为$10$位。总共$28$位的页号至少要分为三级。

   <img src="https://image.sybblogs.fun/img-common/202402082027828.png" alt="页表大小不能超过一个页面" style="zoom:50%;" />

   如果只分为两级页表，则一级页号占$18$位，也就是说页目录表中最多可能有$2^{18}$个页表项，显然，一个页面是放不下这么多页表项的。

2. 两级页表的访存次数分析(假设没有快表机构)

   第一次访存：访问内存中的页目录表

   第二次访存：访问内存中的二级页表

   第三次访存：访问目标内存单元

   在没有快表机构的情况下，$n$级页表在访问逻辑地址的时候，访存次数是$n+1$次。

两级页表总结：

<img src="https://image.sybblogs.fun/img-common/202402082031101.png" alt="两级页表总结" style="zoom: 33%;" />

### 4.3 基本分段存储管理方式

与"分页存储"最大的区别就是，离散分配时所分配地址空间的基本单位不同。

#### 分段概念

进程的地址空间会按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从$0$开始编址。

假如一个进程是$16$KB，可以按照自身的逻辑关系可以分为若干个段，每个段代表一个完整的逻辑模块。

<img src="https://image.sybblogs.fun/img-common/202402082040514.png" alt="分段" style="zoom:50%;" />

可以看到每一个段都会有一个段名，是开发人员在编程的时候使用，另外每个段的地址都是从$0$开始编址的。

<img src="https://image.sybblogs.fun/img-common/202402082042897.png" alt="分段2" style="zoom:50%;" />

操作系统为用户进程分配内存规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

<img src="https://image.sybblogs.fun/img-common/202402082043247.png" alt="分段3" style="zoom:50%;" />

由于分段存储管理当中是按逻辑功能模块划分，用户编程更方便，程序的可读性更高。

~~~c
LOAD 1, [D] | <A>;//将分段D中A单元内的值读入寄存器1
STORE 1, [X]| <B>;//将寄存器1的内容存入x分段的B单元中
~~~

由于各个分段按逻辑功能模块划分，并且上面的段名也是用户自己定义的，所以用户在读这段程序的时候可读性很高。

在用户编程的时候使用段名表示，而编译程序会将段名转换为与之对应的段号。CPU根据这些段号来区分各个段。

采用这种分段机制后逻辑地址变为：段号(段名)和段内地址(段内偏移量)所组成。

<img src="https://image.sybblogs.fun/img-common/202402082048384.png" alt="分段逻辑地址" style="zoom:50%;" />

==注意==：段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少

在上图中，若系统是按字节寻址的，则段号占$16$位，因此在该系统中，每个进程最多有$2^{16}=64$K个段。段内地址占$16$位，因此每个段的最大长度是$2^{16}=64$KB。

而上面的汇编代码，在写程序时使用的段名[D]、[X] 会被编译程序翻译成对应段号。而像`<A>`单元、`<B>`单元会被编译程序翻译成段内地址。

<img src="https://image.sybblogs.fun/img-common/202402082052754.png" alt="分段地址" style="zoom:50%;" />

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称"段表"。段表和之前的页表作用类似。

<img src="https://image.sybblogs.fun/img-common/202402082054017.png" alt="段表" style="zoom: 33%;" />

之前学习的页表是建立了各个逻辑页面到实际的物理页框之间的映射关系。而段表是记录了各个逻辑段到实际的五路内存存放位置之间的映射关系。可以看到每个段表由段号、段长、基址组成。

每个段对应一个段表项，其中记录了该段在内存中的起始位置(又称基址)和段的长度。

需要注意的是各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为(段号$16$位，段内地址$16$位)，因此**用$16$位即可表示最大段长**。如果某个内存物理大小为$4$GB (可用$32$位表示整个物理内存地址空间)，因此，可以让每个段表项占$16+32=48$位，即$6$B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址为$M$，则$K号$段对应的段表项存放的地址为$M+K*6$。

#### 地址表示

有以下一段汇编代码：

~~~c
LOAD 1,[D]| <A>;//将分段D中A单元内的值读入寄存器1
~~~

经过编译程序编译后，形成等价的机器指令：取出段号为$2$，段内地址为$1024$的内存单元中的内容，放到寄存器$1$中。

CPU执行指令时需要将逻辑地址变换为物理地址。上面逻辑地址机器指令用二进制表示：
$0000000000000010\quad0000000100000000$

逻辑地址转换为物理地址详细过程：

在内存的系统区当中存放着很多用于管理系统当中软硬件的数据结构，包括进程控制模块PCB也在系统区当中。当一个进程要上处理机运行之前，进程切换相关的内核程序负责恢复进程运行环境，其中包括一个很重要的段表寄存器硬件。其值是进程的段表在进程当中的起始地址和段表长度。因此当进程还没有运行时，段表起始地址和段表长度是存放在进程的PCB当中，当进程上处理机运行时，这两个信息会放到速度很快的段表寄存器当中。

<img src="https://image.sybblogs.fun/img-common/202402091241943.png" alt="逻辑地址转换为物理地址" style="zoom: 33%;" />

当知道段表的起始地址后，就可以知道段表存放在内存中哪个位置。接下来这个进程在运行过程中避免不了要访问一些逻辑地址，如访问逻辑地址$A$，系统会根据逻辑地址得到段号$S$和段内地址$W$，知道了段号之后需要和段表长度做一个对比判断段号是否越界。如果段号$\ge$段表长度，就会产生越界中断。之后会由中断程序负责处理中断。这里需要特别注意段表长度至少是$1$，而段号从$0$开始。

<img src="https://image.sybblogs.fun/img-common/202402091247864.png" alt="逻辑地址转换为物理地址2" style="zoom:33%;" />

确定段号是合法的没有越界之后，就会根据段号$S$和段表起始地址$F$来查询段表，找到段号对应的段表项。之前提到过由于各个段表项的大小相同，所以用段表起始地址$+$段号$*$段表项长度，就可以找到要找的目标段对应的段表项在内存当中的位置。接着就可以读出这个段表项的内容。

<img src="https://image.sybblogs.fun/img-common/202402091253866.png" alt="逻辑地址转换为物理地址3" style="zoom:33%;" />

在找到了段号对应的段表项之后，系统还会对逻辑地址当中的段内地址$W$进行检查，看看是否已经超过了这个段的最大段长。如果段内地址$\ge$段长，则会产生越界中断，否则继续执行。这要是与页式段长区别最大的一步，因为在页式管理当中每个页面的页长是一样的，所以系统并不需要检查页内偏移量是否超过了页面长度。但是在分段存储管理方式当中，各个段的长度不一样，所以一定需要对段内地址进行越界检查。

此时已经找到目标段的段表项，所以就知道目标段在内存中存放的位置了。最后根据这个段基址$b+$段内地址$W$，就可以得到最终的物理地址$E$。

<img src="https://image.sybblogs.fun/img-common/202402091302868.png" alt="逻辑地址转换为物理地址4" style="zoom:33%;" />

假设逻辑地址$A$是$(2,1024)$，首先需要用段号$2$和段表长度$M$进行检查。显然此时这个进程的段表长度是$3$，因为有三个段表项。所以段号$\le$段表长度的。因此段号合法。继续下一步，用段号和段表起始地址查到对应的段表项，即$2$号段表项。接着需要对段内地址的合法性进行检查。段内地址和段长对比，$2$号段长是$6$K，而段内地址是$1024=1$K。显然不会产生越界中断，可以继续执行下去。接着通过段表项知道这个段在内存当中的存放起始地址是$40$K，所以用段的起始地址$40$K$+$段内地址$1024$，这样就得到最终要访问的目标内存单元。也就是内存变量`<A>`存放的位置。

#### 分段与分页管理的对比

页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的**。

段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式地给出段名。

**页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。**

从地址空间的角度来说，**分页的用户进程地址空间是一维的**，程序员只需给出一个记忆符即可表示一个地址。

<img src="https://image.sybblogs.fun/img-common/202402091313504.png" alt="分段分页管理的对比" style="zoom:50%;" />

如上图所示，用户可以用记忆符`<A>`来表示某个页面当中的内存单元。

而用**分段的用户进程地址空间是二维的**，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

<img src="https://image.sybblogs.fun/img-common/202402091315138.png" alt="分段分页管理的对比2" style="zoom:50%;" />

如上图所示，用户需要显示给出段名`[D]`和段内地址`<A>`。因此在分页管理当中，在用户自己看来的进程地址空间是连续的。但是在分段存储管理当中用户知道自己的进程地址空间是被分为一个个段，并且每个段会占据一连串的连续地址空间。

**分段比分页更容易实现信息的共享和保护**。

假如有一个生产者进程($16$KB)，将其分为三段，其中的一号段该功能段用来判断缓冲区此时是否可访问。除了这个生产者进程之外，其他所有生产者、消费者进程也需要判断缓冲区此时是否需要访问，因此$1$号段中的代码允许所有的生产者进程和消费者进程共享访问。

<img src="https://image.sybblogs.fun/img-common/202402091515430.png" alt="分段分页管理的对比3" style="zoom:50%;" />

假设当前的这个生产者进程有一个段表，它的$1$号段，即判断缓冲区的段是是存放在内存的$120$K这个地址开始的内存空间当中。

<img src="https://image.sybblogs.fun/img-common/202402091517949.png" alt="分段分页管理的对比4" style="zoom: 33%;" />

如果此时有一个消费者进程想要和生产者进程共享使用一号段，可以让消费者进程的段表项同样指向$120$K起始地址即可。

<img src="https://image.sybblogs.fun/img-common/202402091520051.png" alt="分段分页管理的对比5" style="zoom: 33%;" />

所以，如果要实现共享，只需要让进程的某一个段表项指向同一个内存段即可。

而不能被修改的代码称为**纯代码或可重入代码**(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的(比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)。假如，有一个代码段只是简单的输出"Hello World !"，那么所有进程并发访问这段代码并没有问题。

而如果采用分页管理方式：

<img src="https://image.sybblogs.fun/img-common/202402091524463.png" alt="分段分页管理的对比6" style="zoom:33%;" />

如果让消费者进程的某个页表项指向这个页面，显然不合理，因为这个页面中的橙色部分是不允许共享的，只有绿色部分可以。可以看出由于分页管理方式的页面不是按逻辑模块划分的。这就很难实现共享。

保护的原理也类似，对于分段式存储方式，可以在段表中增加一个"是否允许其他进程访问"的标记列即可。

<img src="https://image.sybblogs.fun/img-common/202402091526682.png" alt="分段分页管理的对比7" style="zoom: 50%;" />

而对于分页式管理，一块的内存块中有的可以被访问，有的不能被访问，这要是由于各个页面不是按逻辑划分造成的。因此很难用页表实现信息保护。

**再来看看访问一个逻辑地址需要几次访存**：

对于分页(单级页表)：第一次访存，要查内存中的页表。第二次访存，访问目标内存单元。总共两次访存

分段：第一次访存，查内存中的段表。第二次访存，访问目标内存单元。总共两次访存。同时与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。

基本分段式存储管理总结：

<img src="https://image.sybblogs.fun/img-common/202402091533583.png" alt="基本分段式存储管理总结" style="zoom:50%;" />

### 4.4 段页式管理方式

段页式管理方式是分段、分页这两种管理方式的结合。

分页、分段的优缺点分析：

<img src="https://image.sybblogs.fun/img-common/202402091536943.png" alt="分页、分段的优缺点分析" style="zoom:50%;" />

分段管理中产生的外部碎片同样可以参考动态分区分配解决，所以也可以用"紧凑"来解决，只是需要付出较大的时间代价

为了解决上述缺点，可以采用段页式管理方式。

在采用段页式管理方式的系统当中，一个进程会按照逻辑模块进行分段，再将各段分页(如每个页面$4$KB)。

<img src="https://image.sybblogs.fun/img-common/202402091547504.png" alt="段页式管理" style="zoom: 33%;" />

对于内存来说，内存空间可以分为大小相同的内存块。每个内存块的大小和系统当中页面的大小是一样的，也就是$4$KB。最后进程的这些页面会被依次放到各个内存块当中。

<img src="https://image.sybblogs.fun/img-common/202402091550831.png" alt="段页式管理2" style="zoom:33%;" />

段页式系统的逻辑地址结构由段号、页号、页内地址(页内偏移量)组成。如：

<img src="https://image.sybblogs.fun/img-common/202402091552309.png" alt="段页式系统的逻辑地址结构" style="zoom:50%;" />

这个地方的页号和页内偏移量就是，分段管理当中的段内地址进行再拆分的一个结果。需要注意的是：段号的位数决定了每个进程最多可以分几个段；页号位数决定了每个段最大有多少页；页内偏移量决定了页面大小、内存块大小是多少。

在上述例子中，若系统是按字节寻址的，则段号占$16$位，因此在该系统中，每个进程最多有$2^{16}=64$K个段。页号占$4$位，因此每个段最多有$2^4=16$页。页内偏移量占$12$位，因此每个页面$/$每个内存块大小为$2^{12}=4096=4$KB。

"分段"过程对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段"分页"的过程对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。

#### 段表、页表

与之前的分页式和分段式管理类似，对进程分段再分页之后需要段表和页表。

所以进程先分段，分段后系统会为各个段建立一个段表。进程当中的各个段会对应段表中的各个段表项。而每个段表项由段号、页表长度、页表存放块号(页表起始地址)组成。每个段表项长度相等，段号是隐含的。

<img src="https://image.sybblogs.fun/img-common/202402091611736.png" alt="段表和页表" style="zoom:33%;" />

可以根据块号即可算出页表存放的内存地址。如$0$号段对应的页表存放块号式$1$。

<img src="https://image.sybblogs.fun/img-common/202402091612969.png" alt="段表和页表2" style="zoom:33%;" />

于是可以从$1$号内存块中读出$0$号段对应的页表。由于$0$号段是$7$KB，而每个页面的大小是$4$KB，所以会被分为两个页面。

<img src="https://image.sybblogs.fun/img-common/202402091614585.png" alt="段表和页表3" style="zoom:50%;" />

相应的这两个页面，会依次对应页表当中的一个页表项。每个页表项记录了每个页面存放的内存块号位置。

<img src="https://image.sybblogs.fun/img-common/202402091615754.png" alt="段表和页表4" style="zoom:50%;" />

可以通过两个页号查询对应页表找到内存中的位置。

<img src="https://image.sybblogs.fun/img-common/202402091616760.png" alt="段表和页表5" style="zoom: 33%;" />

所以可以看到，段式管理当中的段表记录的式段号、段长度、段的起始地址。而段页式管理当中记录的是段号、页表长度、页表存放块号，这三个信息，即后面两个不一样。而对于页表来说结构式相同的，都是记录了页号到物理块号的映射关系。

从上面分析当中可以知道，一个进程只会对应一个段表，而一个段表会对应多个页表。

#### 地址转换过程

首先需要知道的是系统中也会有一个段表寄存器这个硬件。在进程上处理机运行之前会从PCB当中读出段表起始地址和段表长度这些信息。之后放到段表寄存器当中。在进行地址转换的时候第一步需要根据逻辑地址得到段号、页号、页内偏移量。第二步需要将段号和段表长度进行一个对比，检查段号是否越界。如果段号合法，接下来可以根据段号和段表起始地址来计算出这个段号对应的段表项在内存当中的位置。这样就找到了想要找的段表项。

<img src="https://image.sybblogs.fun/img-common/202402091625578.png" alt="段页式存储地址转换" style="zoom: 33%;" />

接下里需要注意的是由于各个段的长度是不一样的，所以各个段分页之后可以分为数量不等的页面。所以这里需要对页号合法性进行检查，看是否越界。如果页号没有超出页表长度的话就可以继续往下执行。通过这个段表项知道页表存放的位置，于是就可以读出页表。之后就可以根据逻辑地址中的页号找到来找到相应的页表项。找到页表项之后就可以知道这个页面在内存中的存放位置。最后可以根据内存块号、页内偏移量得到最终的物理地址。

<img src="https://image.sybblogs.fun/img-common/202402091630584.png" alt="段页式存储地址转换2" style="zoom:33%;" />

因此在段页式管理当中，进行地址转换的过程总共需要三次访存。第一次访存是访问内存当中的段表，第二次访存是访问内存当中的页表。第三次访存才是访问最终的目标内存单元。同样的也可引入快表机制，用段号和页号作为查谢快表的关键字。若快表命中则仅需一次访存。

段式存储管理总结：

<img src="https://image.sybblogs.fun/img-common/202402091800557.png" alt="段式存储管理总结" style="zoom:50%;" />

## 5. 虚拟内存

在传统存储管理方式(连续分配$/$非连续分配)的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量。而虚拟内存技术也是内存空间的扩充技术，比交换技术和覆盖技术要先进一些。

虚拟内存是基于高速缓存技术的思想提出的内存管理方案。传统存储方式如下：

<img src="https://image.sybblogs.fun/img-common/202402091806539.png" alt="传统存储方式" style="zoom:50%;" />

系统使用的如果是上面的管理方案，很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。所以传统的存储管理方式有两个很明显的缺点：

- 一次性：

  作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：

  1. 作业很大时，不能全部装入内存，导致大作业无法运行
  2. 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

- 驻留性

  一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

这些缺点可以用虚拟存储技术解决问题。虚拟内存技术遵循局部性原理：

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行。如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)。

空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)。

基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。

虚拟内存是操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充。

<img src="https://image.sybblogs.fun/img-common/202402091820622.png" alt="计算机中存储器的层次结构" style="zoom:50%;" />

虚拟内存有一下三个主要特征：

多次性：无需在作业运行时-次性全部装入内存，而是允许被分成多次调入内存。

对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。

虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在**离散分配的内存管理方式基础上**，即传统的非连续分配存储管理技术：

<img src="https://image.sybblogs.fun/img-common/202402091823302.png" alt="传统的非连续分配存储管理技术" style="zoom:50%;" />

在传统的非连续分配存储的三种管理技术之上运用虚拟内存技术，就形成了与之相对应的请求分页存储管理、请求分段存储管理、请求段页式存储管理。

<img src="https://image.sybblogs.fun/img-common/202402091825329.png" alt="虚拟内存的实现" style="zoom:50%;" />

传统内存管理方式和虚拟内存的管理方式最主要区别是在采用虚拟内存技术，程序在执行的过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

所以为了满足这两个全新的需求，操作系统需要在基本的存储管理方式的基础上再增加两个主要的功能：

- 请求调页(请求调段)功能

  是指在请求分页存储管理当中，如果所需要的页面暂时还不在内存当中，那么操作系统需要负责把这个页面从外存调入内存，并且完善一系列的处理。

- 页面置换(或段置换)功能

  当内存空间不够时，操作系统需要通过置换功能把暂时用不到的分页(分段)先换出到外存当中。

虚拟内存的基本概念总结：

<img src="https://image.sybblogs.fun/img-common/202402091834648.png" alt="虚拟内存的基本概念总结" style="zoom: 50%;" />

### 5.1 请求分页管理方式

请求分页存储管理是在基本分页存储管理方式的基础上进行拓展，从而实现的一种虚拟内存管理技术。

程序在执行的过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

所以为了满足这两个全新的需求，操作系统需要在基本的存储管理方式的基础上再增加两个主要的功能：

- 请求调页(请求调段)功能

  是指在请求分页存储管理当中，如果所需要的页面暂时还不在内存当中，那么操作系统需要负责把这个页面从外存调入内存，并且完善一系列的处理。

- 页面置换(或段置换)功能

  当内存空间不够时，操作系统需要通过置换功能把暂时用不到的分页(分段)先换出到外存当中。

针对这两个功能如何实现会介绍请求管理方式中页表机制和基本分页存储管理方式种的区别。另外为了实现请求调页功能请求分页管理系统引入了**缺页中断机构**。

<img src="https://image.sybblogs.fun/img-common/202402091838121.png" alt="请求分页管理方式" style="zoom:50%;" />

#### 页表机制对比

与基本分页管理相比，请求分页管理中，为了实现"请求调页"，操作系统需要知道每个页面是否已经调入内存。如果还没调入，那么也需要知道该页面在外存中存放的位置。所以为了知道这些信息，肯定需要把这些信息记录在页表这种数据结构中。

另外当内存空间不够时，要实现"页面置换"，操作系统需要通过某些指标来决定到底换出哪个页面。有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。

所以相对于基本分页存储管理的页表来说，请求分页存储管理的页表增加了：

1. 状态位

   表示这个页面是不是已经调入内存了

2. 访问字段

   操作系统在置换页面的时候可以根据访问字段的数据来决定到底要换出哪个页面。所以可以在访问字段当中记录每个页面最近被访问过几次。可以选择把访问次数更少的换出外存。也可以记录上次访问时间，这样就可以换出很久没有访问的页面。

3. 修改位

   用来标记这个页面在调入内存后是否被修改过。如果没有修改，那么就不需要写回内存可以节省时间。

4. 外存地址

   各个页面在外存中存放的地址

<img src="https://image.sybblogs.fun/img-common/202402091855966.png" alt="页表机制" style="zoom: 33%;" />

#### 缺页中断机制

例子：假设此时要访问逻辑地址$=$(页号，页内偏移量)$=(0,1024)$。对应的页表如下：

<img src="https://image.sybblogs.fun/img-common/202402091903194.png" alt="缺页中断机制" style="zoom:50%;" />

为了访问这个逻辑地址需要查询页表，缺页中断机构会根据对应的页表项来判断此时这个页面是否已经在内存中。如果没有在内存当中，即状态位为$0$，此时会产生一个缺页中断信号。之后操作系统的缺页中断处理程序会负责处理这个中断。由于中断处理过程需要$I/O$操作把页面从外存调入内存，所以在等待$I/O$操作完成的过程当中，之前发生缺页的进程会阻塞，放入阻塞队列中。只有调页完成后再将其唤醒，放回就绪队列。

<img src="https://image.sybblogs.fun/img-common/202402091908805.png" alt="缺页中断机制2" style="zoom:50%;" />

如果内存中空闲块，如上图的$a$号块，就可以将这个空闲块分配给此时缺页的进程。再把目标页面从外存放入内存当中。相应的也需要修改页表项当中对应的一些数据。

<img src="https://image.sybblogs.fun/img-common/202402091909721.png" alt="缺页中断机制3" style="zoom:50%;" />

这是第一种情况，就是有空闲内存块的情况。下面是第二种情况，即无空闲内存块的情况：

如果内存无内存块，需要用页面置换算法，通过某种规则来选择要淘汰一个页面。如页面置换算法选中了要置换$2$号页面，可以看到页表中$2$号页的内容是被修改过的(修改为$1$)，所以$2$号页内容需要从内存写回外存。这样$2$号页面占用的$c$号块就可以空出来，让$0$号页面使用。于是可以把$0$号页面从外存调入到内存的$c$号块中。相应的需要更改页表数据：

<img src="https://image.sybblogs.fun/img-common/202402091913232.png" alt="缺页中断机制4" style="zoom:50%;" />

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。内外中断分类如下：

<img src="https://image.sybblogs.fun/img-common/202402091914207.png" alt="中断的分类" style="zoom:50%;" />

另外需要注意的是一条指令在执行期间，可能产生多次缺页中断。(如：`copy A to B`，即将逻辑地址$A$中的数据复制到逻辑地址$B$，而A、B属于不同的页面，且都没有放入内存，则有可能产生两次中断)

请求分页存储管理与基本分页存储管理的在地址变换时候需要新增哪些步骤：

1. 请求调页( 查到页表项时进行判断)

   在查找到页面对应的页表项时候，一定需要对页面是否在内存这个状态进行判断。

2. 页面置换(需要调入页面，但没有空闲内存块时进行)

   在地址变换过程中，如果发现此时想要访问的页面暂时没有调入到内存，但此时内存中没有空闲的内存块时，那么在这个地址变化的过程中也需要进行页面置换的工作。

3. 要修改请求页表中新增的表项

   当页面调入、调出或者被访问时，需要对与之对应的页表项进行数据修改。

请求分页管理方式执行过程与之前的基本分页管理类似：

<img src="https://image.sybblogs.fun/img-common/202402091922209.png" alt="请求分页管理方式执行过程" style="zoom: 33%;" />

需要注意的是：在找到对应页表项后，若对应页面未调入内存，则产生缺页中断，之后由操作系统的缺页中断处理程序进行处理。

另外快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面。

执行过程流程图如下：

<img src="https://image.sybblogs.fun/img-common/202402091939529.png" alt="请求分页中的地址变换过程2" style="zoom: 33%;" />

补充细节：

①中只有"写指令"才需要修改修改位。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。

②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。

③需要用某种"页面置换算法"来决定一个换出页面(下节内容)

④换入$/$换出页面都需要启动慢速的$I/O$操作，可见，如果换入$/$换出太频繁，会有很大的开销。

⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中

在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：

查快表(未命中)$\rightarrow$查慢表(发现未调入内存)$\rightarrow$调页(调入的页面对应的表项会直接加入快表)$\rightarrow$查快表(命中)$\rightarrow$访问呢目标内存单元。

请求分页管理方式总结：

<img src="https://image.sybblogs.fun/img-common/202402091948571.png" alt="请求分页管理方式总结" style="zoom:50%;" />

### 5.2 页面置换算法

通过之前的学习可以知道，在请求分页存储管理当中如果内存空间不够的话，操作系统会负责将内存中用不到信息换出到外存。

而页面置换算法就是由于选择到底要把哪个页面换出到外存。通过之前的学习知道页面的换入、换出需要磁盘$I/O$，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率。

页面置换算法有五种：最佳置换算法(OPT)、先进先出置换算法(FIFO)、最近最久未使用置换算法(LRU)、时钟置换算法(CLOCK)、改进型的时钟置换算法。

#### 最佳置换算法(OPT)

最佳置换算法(OPT，Optimal)：即每次选择淘汰的页面将是**以后永不使用**，或者在**最长时间内不再被访问**的页面，这样可以保证最低的缺页率。

例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串(会依次访问这些页面)：$7,0,1,2,0,3,0, 4,2,3,0,3,2,1,2,0,1,7,0,1$

<img src="https://image.sybblogs.fun/img-common/202402101157509.png" alt="最佳置换算法" style="zoom:50%;" />

由于有三个内存块，所以前三次访问直接将不同的页面放入内存块即可。第四次访问$2$号页面，此时由于内存块已经满了，所以要调用页面置换算法替换掉一个内存块。可以看出后面的访问页面顺序中$7$号页面一直到倒数第三次才会访问，所以可以认为这个$7$号页面是**最长时间不再被访问**的页面，所以将内存块$1$的$7$号页面替换为当前要访问的$2$号页面。后面的原理类似。

所以整个过程缺页中断发生了$9$次，页面置换发生了$6$次。即缺页率$=\frac{9}{20}=45\%$

注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。

综上所述最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。

#### 先进先出置换算法(FIFO)

先进先出置换算法(FIFO)：每次选择淘汰的页面是最早进入内存的页面。

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。

例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：$3,2,1,0,3,2,4,3,2,1,0,4$

<img src="https://image.sybblogs.fun/img-common/202402101207008.png" alt="先进先出置换算法(FIFO)" style="zoom:50%;" />

由于有三个内存块，所以前三次访问直接将不同的页面放入内存块即可，同时将放入内存块的页面放在队列的队尾。

<img src="https://image.sybblogs.fun/img-common/202402101212521.png" alt="先进先出置换算法(FIFO)2" style="zoom:50%;" />

第四次访问$0$号页面，由于内存块已经满了，所以要调用页面置换算法替换掉一个内存块。可以看到$3$号页面进入内存块时间最早，所以将$3$号页码替换为要被访问的$0$号页面。相应的$0$号页面放入队列的队尾，$3$号页面出队。

<img src="https://image.sybblogs.fun/img-common/202402101214696.png" alt="先进先出置换算法(FIFO)3" style="zoom:50%;" />

之后要访问的页面替换原理类似。可以看出分配三个内存块时，缺页次数为$9$次。

如果修改一下题目，加入系统为某个进程分配的是四个内存块。则访问情况如下：

<img src="https://image.sybblogs.fun/img-common/202402101330406.png" alt="先进先出置换算法(FIFO)4" style="zoom:50%;" />

可以看出分配三个内存块时，缺页次数为$10$次。正常情况下分配的内存块越多，缺页的次数应该越少，但使用FIFO算法不减反增。这种现象称为Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

只有FIFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。

#### 最近最久未使用置换算法(LRU)

最近最久未使用置换算法(LRU，leastrecentlyused)：每次淘汰的页面是最近最久未使用的页面。

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间$t$。当需要淘汰一个页面时，选择现有页面中$t$值最大的，即最近最久未使用的页面。

<img src="https://image.sybblogs.fun/img-common/202402101339910.png" alt="最近最久未使用置换算法(LRU)" style="zoom:50%;" />

例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串$1,8,1,7,8,2,7,2,1,8,3,8,2,1,3,1,7,1,3, 7$

<img src="https://image.sybblogs.fun/img-common/202402101342741.png" alt="最近最久未使用置换算法(LRU)2" style="zoom:50%;" />

由于有四个内存块，所以前几次访问直接将不同的页面放入内存块即可。直到访问$3$号页面，此时由于内存块已经满了，所以要调用页面置换算法替换掉一个内存块。此时可以逆向往前检查在内存中出现的最后一个页数，并替换这个页。这里$8$号页最先出现，接着是$1,2$号页，最后出现的是$7$号页，所以$7$号页是最近最久未使用的页面。将被访问$3$号页面替换掉$7$号页面。

<img src="https://image.sybblogs.fun/img-common/202402101345828.png" alt="最近最久未使用置换算法(LRU)3" style="zoom:50%;" />

后面的$7$号页置换原理类似。所以在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在**逆向扫描过程中最后**
**一个出现的页号就是要淘汰的页面**。

该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

#### 时钟置换算法(CLOCK)

最佳置换算法性能最好，但无法实现。先进先出置换算法实现简单，但算法性能差，会出现Belady异常。最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。

时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)。

简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为$1$。当需要淘汰一个页面时，只需检查页的访问位。如果是$0$，就选择该页换出；如果是$1$，则将它置为$0$，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是$1$，则将这些页面的访问位依次置为$0$后，再进行第二轮扫描(第二轮扫描中一定会有访问位为$0$的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)。

<img src="https://image.sybblogs.fun/img-common/202402101400551.png" alt="时钟置换算法" style="zoom:50%;" />

例：假设系统为某进程分配了五个内存块，并考虑到有以下页面号引用串：$1,3,4,2,5,6,3,4,7$

由于有五个内存块，所以前五个访问的页号$1,3,4,2,5$都会装入内存块中，并且装入时的访问位都会置为$1$。内存中五个页面会通过链接指针的方式链接成一个循环队列。

<img src="https://image.sybblogs.fun/img-common/202402101406289.png" alt="时钟置换算法(CLOCK)" style="zoom:50%;" />

在访问到$6$号页面的时候才会考虑页面置换。于是会从循环队列的队首($1$号页)开始扫描，尝试找到一个访问位为$0$的页面，并且被扫描过的页面访问位会置为$0$。所以在经过第一轮扫描后所有的访问位都置为$0$

<img src="https://image.sybblogs.fun/img-common/202402101411284.png" alt="时钟置换算法(CLOCK)2" style="zoom:50%;" />

进行第二轮扫描时，$1$号页面的访问位为$0$，所以会选择淘汰$1$号页面。所以$6$号页会装入$1$号页以前占有的内存块当中，并且$6$号页的访问位会置为$1$，扫描的指针会指向下一个页面，即$3$号页面的位置。接着会访问$3$号页面，该页面在内存块中所以将$3$号页的访问位修改为$1$。

<img src="https://image.sybblogs.fun/img-common/202402101413160.png" alt="时钟置换算法(CLOCK)3" style="zoom:50%;" />

之后的访问的替换原理类似。

#### 改进型的时钟置换算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行$I/O$操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免$I/O$操作。这就是改进型的时钟置换算法的思想。

实现方法：增加一个修改位。修改位$=0$，表示页面没有被修改过；修改位$=1$，表示页面被修改过。其他与之前一样将所有可能被置换的页面排成一个循环队列。

为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1，1)表示一个页面近期被访问过，且被修改过。

规则：

第一轮：从当前位置开始扫描到第一个$(0,0)$的帧用于替换。本轮扫描不修改任何标志位

第二轮：若第一轮扫描失败，则重新扫描，查找第一个$(0, 1)$的帧用于替换。本轮将所有扫描过的帧访问位设为$0$

第三轮：若第二轮扫描失败，则重新扫描，查找第一个$(0,0)$的帧用于替换。本轮扫描不修改任何标志位。

第四轮：若第三轮扫描失败，则重新扫描，查找第一个$(0,1)$的帧用于替换。

由于第二轮已将所有帧的访问位设为$0$，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。

例：假设系统为某进程分配了五个内存块。内存中五个页面会通过链接指针的方式链接成一个循环队列。

<img src="https://image.sybblogs.fun/img-common/202402101429655.png" alt="改进型的时钟置换算法" style="zoom:50%;" />

此时如果要淘汰一个页面，需要从队列的队头位置$(0,1)$开始依次的扫描。

<img src="https://image.sybblogs.fun/img-common/202402101430446.png" alt="改进型的时钟置换算法2" style="zoom: 50%;" />

根据算法规则，第一轮扫描只需要找到访问位和修改位都为$0$的页面。所以往后可以找到，因此会淘汰这个页面。

<img src="https://image.sybblogs.fun/img-common/202402101431285.png" alt="改进型的时钟置换算法3" style="zoom:50%;" />

接着假设循环队列如下所示

<img src="https://image.sybblogs.fun/img-common/202402101432113.png" alt="改进型的时钟置换算法4" style="zoom:50%;" />

如果要淘汰一个页面，需要从队列的队头位置$(1,1)$开始依次的扫描。根据算法规则，第一轮扫描只需要找到访问位和修改位都为$0$的页面。第一轮查找下来并没有。

所以进行第二轮查找。第二轮查找第一个$(0, 1)$的帧用于替换。本轮将所有扫描过的帧访问位设为$0$。可以找到该页面：

<img src="https://image.sybblogs.fun/img-common/202402101434170.png" alt="改进型的时钟置换算法5" style="zoom:50%;" />

综上所述，替换的优先级是：

第一优先级：最近没访问，且没修改的页面

第二优先级：最近没访问，但修改过的页面

第三优先级：最近访问过，但没修改的页面

第四优先级：最近访问过，且修改过的页面

页面置换算法总结：

<img src="https://image.sybblogs.fun/img-common/202402101439124.png" alt="页面置换算法总结" style="zoom:50%;" />

### 5.3 页面分配策略

首先要了解驻留集：指请求分页存储管理中给进程分配的物理块的集合。

#### 页面分配、置换策略

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。考虑一个极端情况，若某进程共有$100$个页面，则该进程的驻留集大小为$100$时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为$1$，则进程运行期间必定会极频繁地缺页。

所以若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少。而驻留集太大，权会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。

针对驻留集大小是否可变问题，提出了两种分配策略：

- 固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。
- 可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。

另外当页面置换的时候，页面置换的范围是什么，根据这个问题提出了置换范围策略：

- 局部置换：发生缺页时只能选进程自己的物理块进行置换。

- 全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

将两种分配和置换策略两两结合，可以得到：固定分配局部置换、可变分配局部置换和可变分配全局置换。

没有固定分配全局置换的概念。因为全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配。

三种策略介绍：

1. 固定分配局部置换

   系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一-页换出，然后再调入需要的页面。

   这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)。因此灵活性差。

2. 可变分配全局置换

   刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。

   可以看出采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。

   上面未锁定的页面是指系统会锁定一些页面，这些页面中的内容不能置换出外存(如：重要的内核数据可以设为"锁定")

   显然只要进程缺页就分配一个新的物理块，这种方式也不太合理。

3. 可变分配局部置换

   刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度。反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

   这样就可以让系统的多道程序并发度，也保持在一个相对理想的位置。

所以可变分配全局置换：只要缺页就给分配新物理块。可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块。

#### 调入页面时机及何处调入

在什么要调入所需要的页面：

1. 预调页策略

   根据局部性原理(特别是空间局部性)，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有$50\%$左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。

   所以该策略是在运行前就进行调入的。

2. 请求调页策略

   进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘$I/O$操作，因此$I/O$开销较大。

   所以该策略是在运行时就进行调入的。

从什么地方调入页面：

之前介绍过磁盘中存储区域分为对换区和文件区两个部分。其中对换区采用连续分配的方式，读写速度更快。而文件区采用的是离散分配方式，读写速度较慢。

<img src="https://image.sybblogs.fun/img-common/202402101535730.png" alt="从何处调入页面" style="zoom:50%;" />

方式一：由于对换区读写速度更快，如果系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。之后再调入内存中，如果内存已满，会将内存中的页面调出到对换区。

<img src="https://image.sybblogs.fun/img-common/202402101544689.png" alt="页面调出" style="zoom:50%;" />

方式二：如果系统中缺少足够的对换区空间，凡是不会被修改的数据都直接从文件区调入内存，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。

<img src="https://image.sybblogs.fun/img-common/202402101545402.png" alt="页面调出2" style="zoom:50%;" />

方式三：UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，第一次都会从文件区调入内存。若内存不够，使用过的页面需要换出，则写回对换区，下次需要时再从对换区调入。

<img src="https://image.sybblogs.fun/img-common/202402101548382.png" alt="页面调出3" style="zoom:50%;" />

#### 抖动现象与工作集

又称颠簸现象。指刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)。

所以如果为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。所以为进程分配多少物理块是值得思考的问题。

为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程"工作集"的概念。

工作集：指在某段时间间隔里，进程实际访问页面的集合。

操作系统会根据"窗口尺寸"来算出工作集。例：某进程的页面访问序列如下，窗口尺寸为$4$，各时刻的工作集为?

<img src="https://image.sybblogs.fun/img-common/202402101554576.png" alt="工作集" style="zoom:50%;" />

由于窗口尺寸的大小是$4$。所以当访问到$23$页面时，其工作集是$24,15,18,23$。访问到$17$号页面时，其工作集是$18,24,17$。

<img src="https://image.sybblogs.fun/img-common/202402101555090.png" alt="工作集2" style="zoom:50%;" />

所以可以看出工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为$5$， 经过一段时间的监测发现某进程的工作集最大为$3$，那么说明该进程有很好的局部性，可以给这个进程分配$3$个以上的内存块即可满足进程的运行需要。即系统可以根据工作集的大小来确定驻留级的大小。

一般来说， 驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。

拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合(工作集)来设计一种页面置换算法：如果一个进程需要置换出某个页面，可以选择一个不在工作集中的页面进行淘汰。

页面分配策略总结：

<img src="https://image.sybblogs.fun/img-common/202402101601487.png" alt="页面分配策略总结" style="zoom:50%;" />

## 6. 内存映射文件

内存映射文件指的是操作系统向上层程序员提供的功能(系统调用)。通过这个功能好处：

- 开发人员可以很方便访问文件数据。

  传统的访问方式是：如果当前有一个文件需要被放入内存，这个文件会被拆分成几个大小相等的块，每个块刚好可以放入磁盘块中。这些块有可能被离散存放再磁盘的各个位置。

  <img src="https://image.sybblogs.fun/img-common/202402101606856.png" alt="传统文件访问方式" style="zoom: 33%;" />

  如果一个进程想要访问数据，传统做法是首先每个进程都有自己的虚拟地址空间，如果一个进程想要访问这个文件的数据：

  1. 首先需要使用open系统调用，来指明打开这个文件
  2. 接着使用seek系统调用，指明想要读取文件的哪部分数据。操作系统会用一个读写指针记录位置。
  3. 接下来进程会使用read系统调用，从读写指针指向的位置往后读若干个数据(从磁盘读入内存)。读入内存后进程可以访问这个数据，同时也可以修改这个数据。
  4. 入过进程修改了数据，那么进程还需要使用write系统调用，将内存中的指定数据，写回磁盘(根据读写指针确定要写回什么位置)。

  而采用内存映射方式，那么一个进程访问文件的方式将变得简单：

  1. 首先使用open系统调用，指明打开这个文件

  2. 接着使用mmap系统调用，让操作系统把文件映射到进程的虚拟地址空间当中。

     <img src="https://image.sybblogs.fun/img-common/202402101617909.png" alt="mmap系统调用" style="zoom: 33%;" />

     这个系统调用会返回一个指针，这个指针会指向刚才映射区域的起始地址。

  3. 接着就可以以访问内存的方式访问文件数据

     如C语言中给一个指针，可以通过指针再加上某一个地址的偏移量，去访问这个指针后面的某些区域。所以只要mmap返回一个指针，那么就可以访问这个文件的任何数据。

     注意这里操作系统只是建立了文件数据和内存间的一个映射关系，但并没有把文件数据直接读入内存。这就相当于一个缺页的状态。

     如果要访问第一块数据，那么操作系统会发现这块数据还没有调入主存(缺页)，此时操作系统会自动把这一块的数据读入内存中。所以开发人员不需要再主动调用read函数，读入数据的过程由操作系统自动完成。

  4. 加入此时要修改$1$块内存的数据。那么如果进程不再需要被使用时，进程可以使用close系统调用，来关闭文件，当关闭文件之后，操作系统会自动把文件当中被修改的数据($1$号内存块)写回磁盘。

     因此可以看到采用内存映射文件之后开发人员对文件数据的访问都方便多了。只需要直到文件在内存当中的起始地址，接着按照访问内存的方式去访问这个文件当中的数据即可。文件数据的读入和写出都是由操作系统自动完成的。

- 方便多个进程共享同一个文件

  通过上面介绍可以直到，一个文件可以通过系统调用方式映射到自己的虚拟地址空间中。同样的道理，另一个进程也可以把这个文件映射到自己的虚拟地址空间中。此时两个进程的虚拟地址空间是相互独立的，但是操作系统会把这两块虚拟地址空间映射到相同的物理内存上。

  <img src="https://image.sybblogs.fun/img-common/202402101630685.png" alt="内存映射文件" style="zoom: 33%;" />

  在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时,另一个进程可以立马"看到"。

  内存映射文件总结：

  <img src="https://image.sybblogs.fun/img-common/202402101631599.png" alt="内存映射文件总结" style="zoom:50%;" />

# 四. 文件管理

文件就是一组有意义的信息$/$数据集合。

一个文件有以下属性：

- 文件名

  由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。

- 标识符

  文件并不能确定唯一文件。所以一个系统内的各文件标识符是唯一确定的，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。

- 类型

  指明文件的类型。指明文件的类型有很多好处，如操作系统可以为不同类型的文件设置默认打开方式。

- 位置

  文件存放的路径(让用户使用)、同时操作系统还需要关心在外存中的地址(操作系统使用，对用户不可见)

- 大小

  指明文件大小

- 创建时间

  上次修改时间及文件所有者信息

- 保护信息

  对文件进行保护的访问控制信息(如：可读可写等操作)

文件内部的数据组织方式：

1. 无结构文件(如文本文件)

   由一些二进制或字符流组成，又称"流式文件"。

2. 有结构文件(如数据库表)：

   由一组相似的记录组成，又称"记录式文件"。

   记录是一组相干的数据项集合。

   <img src="https://image.sybblogs.fun/img-common/202402101700278.png" alt="文件组织" style="zoom: 33%;" />

文件组织结构：

<img src="https://image.sybblogs.fun/img-common/202402101701711.png" alt="文件组织结构" style="zoom: 33%;" />

这些记录如何组织的问题，如：应该使用顺序存放、还是索引表来表示记录间的顺序。这是文件的逻辑结构重点要探讨的问题。所以文件的逻辑结构要探讨的问题其实就是文件内部这些记录，这些数据应该被怎么组织起来的问题。

文件之间的组织方式：

<img src="https://image.sybblogs.fun/img-common/202402101706823.png" alt="文件组织形式" style="zoom: 33%;" />

这种平时常见的文件组织形式是树状的组织形式。这里所谓的目录就是文件夹。用户可以自己创建一层层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了。目录其实也是一种特殊的有结构文件(由记录组成)，如何实现文件目录是之后会重点探讨的问题。

操作系统向上提供的功能：

- 创建文件

  可以"创建文件"，(点击新建后，图形化交互进程在背后调用了create系统调用。

- 读文件

  可以"读文件"，将文件数据读入内存，才能让CPU处理(双击后，"记事本"应用程序通过操作系统提供的"读文件"功能，即read系统调用，将文件数据从外存读入内存，并显示在屏幕上)。

- 写文件

  可以"写文件"，将更改过的文件数据写回外存(我们在"记事本"应用程序中编辑文件内容，点击"保存"后，"记事本"应用程序通过操作系统提供的"写文件"功能，即write系统调用，将文件数据从内存写回外存)

- 删除文件

  可以"删除文件"(点了"删除"之后，图形化交互进程通过操作系统提供的"删除文件"功能，即delete系统调用，将文件数据从外存中删除)

<img src="https://image.sybblogs.fun/img-common/202402101727711.png" alt="操作系统向上提供的文件功能" style="zoom:33%;" />

可用几个基本操作完成更复杂的操作，比如："复制文件"，可以先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。

文件如何存放在外存：

与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据(如$1$B)。每个存储单元对应一个物理地址。

类似于内存分为一个个"内存块"，外存会分为一个个"块$/$磁盘块$/$物理块"。每个磁盘块的大小是相等的，每块一般包含$2$的整数幂个地址(如本例中，一块包含$2^{10}$个地址，即$1$KB)。同样类似的是，文件的逻辑地址也可以分为(逻辑块号，块内地址)，操作系统同样需要将逻辑地址转换为外存的物理地址(物理块号，块内地址)的形式。块内地址的位数取决于磁盘块的大小。

操作系统以"块"为单位为文件分配存储空间，因此即使一个文件大小只有$10$B，但它依然需要占用$1$KB的磁盘块。外存中的数据读入内存时同样以块为单位。

所以其实文件的物理结构探讨的是文件这些数据在物理上应该是怎么存放怎么组织的问题。而上面提到的文件的逻辑结构是文件的各个记录在逻辑上应该是什么样的组织关系问题。

其他需要由操作系统实现的文件管理功能：

- 文件共享：使多个用户可以共享使用一个文件
- 文件保护：如何保证不同的用户对文件有不同的操作权限

初始文件管理总结：

<img src="https://image.sybblogs.fun/img-common/202402101736441.png" alt="初始文件管理总结" style="zoom:50%;" />

## 1. 文件的逻辑结构

所谓的"逻辑结构"就是指在用户看来，文件内部的数据应该是如何组织起来的。而"物理结构"指的是在操作系统看来，文件的数据是如何存放在外存中的。文件逻辑结构可以分为无结构文件和**有结构文件**。有结构文件逻辑结构是：顺序文件、索引文件和索引顺序文件。

<img src="https://image.sybblogs.fun/img-common/202402101738336.png" alt="文件逻辑结构" style="zoom: 33%;" />

算法的具体实现与逻辑结构、物理结构都有关(文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关)

无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称"流式文件"。如：Windows操作系统中的`.txt`文件。

文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的"逻辑结构"问题。所以重点探讨有结构文件。

有结构文件：由一组相似的记录组成，又称"记录式文件"。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字(作为识别不同记录的ID)。

<img src="https://image.sybblogs.fun/img-common/202402101744624.png" alt="有结构文件" style="zoom:33%;" />

上面例子中，"学号"即可作为各个记录的关键字。每个学生对应一条记录，每条记录由若干个数据项组成。而根据各条记录的长度(占用的存储空间)是否相等，又可分为定长记录和可变长记录两种。

<img src="https://image.sybblogs.fun/img-common/202402101747408.png" alt="有结构文件定长记录和可变长记录" style="zoom:50%;" />

如上图所示，学号、姓名和性别都是定长记录。而特长长度不确定，所以是可变长记录。

之前例子中专业可以给$60$字节存储空间也不会造成多大的浪费。而这里学生的特长有的人可能很多，所需要的空间就会很大，而有的学生没有特长，显然对这个数据项的存储空间利用很不充分。这样就会导致空间利用率极低的问题。所以最好让这个特长记录是可变长的记录组成。

接下来会讨论这些记录应该在逻辑上怎么被组织起来的问题。根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件和索引顺序文件。

### 1.1 顺序文件

顺序文件：文件中的记录一个接一个地顺序排列(逻辑上)，记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

如果是顺序存储，那么逻辑上相邻的记录物理上也相邻(类似于顺序表)

<img src="https://image.sybblogs.fun/img-common/202402101753951.png" alt="顺序存储" style="zoom:50%;" />

而如果采用链式存储结构，逻辑上相邻的记录物理上不一定相邻(类似于链表)

<img src="https://image.sybblogs.fun/img-common/202402101754123.png" alt="顺序文件的链式存储" style="zoom:50%;" />

根据记录是否按照关键字顺序排列，又可以把顺序文件分为：串结构和顺序结构。

- 串结构

  记录之间的顺序与关键字无关。通常按照记录存入的时间决定记录的顺序。

- 顺序结构

  记录之间的顺序按关键字顺序排列

显然记录是定长的还是可变长的，记录是否按照关键字有序排列，另外这些记录在物理上是顺序存储还是链式存储，所有的区别都能影响顺序文件能不能实现一些操作的功能。

假设：已经知道了文件的起始地址(也就是第一个记录存放的位置)

思考一：能否快速找到第$i$个记录对应的地址?(即能否实现随机存取)

思考二：能否快速找到某个关键字对应的记录存放的位置?

- 如果一个顺序文件采用链式存储方式，那么无论是定长$/$可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找。与链表类似，要查找链表中的一个元素，必须要从链头位置开始查找。因为各个元素之间的存储位置都是离散的。

- 如果采用顺序存储方式，且是可变长记录，无法实现随机存取。每次只能从第一个记录开始依次往后查找。

  由于文件的记录是可变长的，所以必须要在每个记录之前用一定的存储空间来表示这个记录的长度。假设用$1$个字节来记录长度。

  <img src="https://image.sybblogs.fun/img-common/202402101842742.png" alt="顺序文件的可变长记录" style="zoom:50%;" />

  由于记录长度不同，所以并不会呈现出规律性，所以只能从第一条开始往后找。

- 如果采用顺序存储方式，且是定长记录，则可实现随机存取。记录长度为$L$，则第$i$个记录存放的相对位置是$i*L$。若采用串结构，无法快速找到某关键字对应的记录。若采用顺序结构，可以快速找到某关键字对应的记录(如折半查找)。

结论：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取。若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录)。

注意：一般来说，考试题目中所说的"顺序文件"指的是物理上**顺序存储的顺序文件**，而不是链式存储。之后的讲解中提到的顺序文件也默认如此。并且顺序文件的缺点是：增加$/$删除一个记录比较困难(如果是串结构则相对简单，因为不需要按关键字顺序排列)。

在实际应用过程中，为了减少$I/O$次数，一般来说操作系统会管理一个日志文件，用这个日志文件来管理记录对某个文件中的记录进行修改的信息。之后每隔一段比较长的时间再把这些信息统一合并到外存中对应的文件。

### 1.2 索引文件

对于可变长记录文件，要找到第$i$个记录，必须先顺序第查找前$i-1$个记录，但是很多应用场景中又必须使用可变长记录。如何解决这个问题?

基于这种需求提出索引文件这种逻辑结构。每个文件会建立一张索引表，并且索引表的表项会对应文件的一条记录。文件的记录在物理内存中可以离散存放，但是索引表的表项在物理上需要连续存放。

<img src="https://image.sybblogs.fun/img-common/202402101858799.png" alt="索引文件" style="zoom:50%;" />

另外每一个索引表的表项大小都是相等的。如：索引号、长度、指针都占$4$个字节，那么一个索引表的表项就是$12$个字节的长度。

所以索引表本身是定长记录的顺序文件。因此可以快速找到第$i$个记录对应的索引项。

可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加$/$删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此**主要用于对信息处理的及时性要求比较高的场合**。

另外，可以用不同的数据项建立多个索引表。如：学生信息表中，可用关键字"学号"建立一张索引表。也可用"姓名"建立一张索引表。这样就可以根据"姓名"快速地检索文件了。(如：SQL就支持根据某个数据项建立索引的功能)

### 1.3 索引顺序文件

索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占$8$B，而每个索引表项占$32$个字节，那么索引表都要比文件内容本身大$4$倍，这样对存储空间的利用率就太低了。

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。

<img src="https://image.sybblogs.fun/img-common/202402101905385.png" alt="索引顺序文件" style="zoom:50%;" />

在上图中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，且每一个分组对应一个索引顺序文件的索引项，分组内的记录不需要按关键字排序。

<img src="https://image.sybblogs.fun/img-common/202402101907567.png" alt="索引顺序文件2" style="zoom: 33%;" />

每个索引项记录了名字和存放的位置。索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。

也就是说索引顺序文件的索引表其实是一个定长记录的串结构的顺序文件。可以看到索引表的表项少了很多。

若一个顺序文件有$10000$个记录，则根据关键字检索文件，只能从头开始顺序查找(这里指的并不是定长记录、顺序结构的顺序文件)，平均须查找$5000$个记录。

若采用索引顺序文件结构，可把$10000$个记录分为$10000=100$组，每组$100$个记录。则需要先顺序查找索引表找到分组(共$100$个分组，因此索引表长度为$100$，平均需要查$50$次)，找到分组后，再在分组中顺序查找记录(每个分组$100$个记录，因此平均需要查$50$次)。可见，采用索引顺序文件结构后，平均查找次数减少为$50+50=100$次。

同理，若文件共有$10^6$个记录，则可分为$1000$个分组，每个分组$1000$个记录。根据关键字检索一个记录平均需要查找$500+500=1000$次。这个查找次数依然很多，解决方式是可以建立多级索引：

为了进一步提高检索效率，可以为顺序文件建立多级索引表。例如，对于一个含$10^6$个记录的文件，可先为该文件建立一张低级索引表，每$100$个记录为一组，故低级索引表中共有$10000$个表项(即$10000$个定长记录)，再把这$10000$个定长记录分组，每组$100$个，为其建立顶级索引表，故顶级索引表中共有$100$个表项。

<img src="https://image.sybblogs.fun/img-common/202402101915405.png" alt="多级索引顺序文件" style="zoom:50%;" />

此时，检索一个记录，平均检索顶级索引表$50$次，低级索引表$50$次，最后的分组$50$次，所以平均需要查找$50+50+50=150$次。

有结构文件总结：

<img src="https://image.sybblogs.fun/img-common/202402101923492.png" alt="有结构文件总结" style="zoom:50%;" />

## ==2. 文件目录==

层级目录结构(Windows资源管理器)，文件之间的组织结构清晰，易于查找。编程时也可以很方便的用文件路径找到一个文件。如：`FILE *fp;fp=fopen("F:\data\myfile.dat");`用户可以轻松实现"按名存取"。

从操作系统角度来探讨这些目录结构应该如何实现。所谓的文件目录就是熟悉的Windows操作系统的文件夹。要实现文件目录的功能需要有很关键的数据结构"文件控制块"。另外随着计算机的发展，目录的结构也出现了不同的变化。对文件控制块的优化也很重要，所以还要了解索引结点知识。

<img src="https://image.sybblogs.fun/img-common/202402111126710.png" alt="文件目录" style="zoom: 33%;" />

### 2.1 文件控制块

对于某个根目录来说，对应的目录文件如下：

<img src="https://image.sybblogs.fun/img-common/202402111245234.png" alt="文件控制块" style="zoom: 33%;" />

其实就是用上图的目录表来表示根目录下存放哪些文件。所以每一个文件夹，每一个文件都会对应一个表项。故目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。

注意上图目录表中还保存了文件的物理位置。假如当我们双击"照片"后，操作系统会在这个目录表中找到关键字"照片"对应的目录项(也就是记录)，然后从外存中将"照片"目录的信息读入内存，于是，"照片"目录中的内容就可以显示出来了。

目录文件中的一条记录就是一个"**文件控制块(FCB)**"。FCB的有序集合称为"文件目录"，一个FCB就是一个文件目录项。同时由上图还可以知道FCB中包含了文件的基本信息(文件名、物理地址、逻辑结构、物理结构等)，存取控制信息( 是否可读$/$可写、禁止访问的用户名单等)，使用信息(如文件的建立时间、修改时间等)。其中最重要，最基本的还是文件名、文件存放的物理地址，因为FCB实现了文件名和文件之间的映射。使用户(用户程序)可以实现"按名存取"。

对文件控制块的操作：

1. 搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项

2. 创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项
3. 删除文件：当删除一个文件时，需要在目录中删除相应的目录项
4. 显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性
5. 修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项(如：文件重命名)

### 2.2 文件的目录结构

文件控制块的有序集合就组成了文件的目录。

#### 单级目录结构

早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。

<img src="https://image.sybblogs.fun/img-common/202402111300818.png" alt="单级目录结构" style="zoom: 50%;" />

单级目录实现了"按名存取"，但是不允许文件重名。

在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中，显然，单级目录结构不适用于多用户操作系统。

#### 两级目录结构

为了解决单级目录结构不适用于多用户操作系统的问题，后来提出了两级目录结构。

早期的多用户操作系统，采用两级目录结构。分为主文件目录(MFD,Master File Directory)和用户文件目录(UFD，User Flie Directory)。

一个主文件目录记录用户名及相应用户文件目录的存放位置，而用户文件目录由该用户的文件FCB组成。

<img src="https://image.sybblogs.fun/img-common/202402111332911.png" alt="两级目录结构" style="zoom: 33%;" />

由于不同的用户文件是存放在不同的用户文件目录下，所以允许不同用户的文件重名。文件名虽然相同，但是对应的其实是不同的文件。

两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制(检查此时登录的用户名是否匹配，用户$A$不能访问用户$B$目录，反之一样)。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。

但是这种结构缺点就是不可以把自己的文件进行分类。

#### 多级目录结构

多级目录结构又称树形目录结构。这是现在常用的目录结构。

<img src="https://image.sybblogs.fun/img-common/202402111414981.png" alt="树形目录结构" style="zoom:50%;" />

每个目录下可以有更低一级别的目录，同时在各个目录下面还有一些文件。并且不同目录下的文件是可以重名的。

用户(或用户进程)要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用"1"隔开。从根目录出发的路径称为绝对路径。例如：`自拍.jpg`的绝对路径是`/照片/2015-08/自拍jpg`。

系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表。找到"照片"目录的存放位置后，从外存读入对应的目录表。再找到"2015-08"目录的存放位置，再从外存读入对应目录表。最后才找到文件"自拍.jpg"的存放位置。整个过程需要$3$次读磁盘$I/O$操作。

很多时候，用户会连续访问同一目录内的多个文件(比如：接连查看`2015-08`目录内的多个照片文件)，显然，每次都从根目录开始查找，是很低效的。因此可以设置一个"当前目录"。例如：此时已经打开了`照片`的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为`当前目录`。当用户想要访问某个文件时，可以使用从当前目录出发的相对路径。

在Linux中，"."表示当前目录，因此如果`照片`是当前目录，则`自拍.jpg`的相对路径为：`./2015-08/自拍.jpg`。从当前路径出发，只需要查询内存中的`照片`目录表，即可知道`2015-08`目录表的存放位置，从外存调入该目录，即可知道`自拍.jpg`存放的位置了。所以只用访存一次$I/O$即可。

可见，引入"当前目录"和"相对路径"后，磁盘$I/O$的次数减少了。这就提升了访问文件的效率。所以树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构**不便于实现文件的共享**。为此，提出了"无环图目录结构"。

#### 无环图目录结构

无环图目录结构在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图。可以更方便地实现多个用户间的文件共享。

<img src="https://image.sybblogs.fun/img-common/202402111507817.png" alt="无环图目录结构" style="zoom: 33%;" />

可以用不同的文件名指向同一个文件，甚至可以指向同一个目录(共享同一目录下的所有内容)。在引入共享目录之后对于文件的删除就不能向之前一样简答，只要一个文件有可能是被多个用户同时使用。当一个用户提出删除文件时候还需要判断这个文件当前是否有其他用户正在访问。所以需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减$1$，并不会直接删除共享结点。

如上图所示两个用户`User1`和`User2`同时访问一个文件，所以当前这个文件的共享计数器$=2$。此时`User1`用户提出删除该文件，操作系统会把该文件的目录项删除，并让共享计数器$-1$，而并不会直接删除该文件。

<img src="https://image.sybblogs.fun/img-common/202402111518167.png" alt="无环图目录结构共享删除文件" style="zoom: 33%;" />

只有共享计数器减为$0$时，才会删除这个共享文件。

注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。如果是某个用户复制的共享文件，那么该用户修改副本文件，并不会影响原本的共享文件。

#### 索引结点

是对FCB的改进。通过之前的学习知道，由一些列的文件控制块组成了一个一个文件目录，但是操作系统在查找各级目录的过程中只需要使用文件名这个信息就可以，其他信息就暂时不需要。只有当文件匹配的时候才会去关心文件的存放位置。所以可以对目录表进行一个简化，来提升搜索的效率。

因为按照文件名来搜索目录的时候，并不需要关心除了文件名之外其他的信息，因此可以把其他信息放到索引结点当中。即除了文件名
之外的文件描述信息都放到索引结点中。每一个文件都会有一个唯一的索引结点。

<img src="https://image.sybblogs.fun/img-common/202402111527054.png" alt="索引结点" style="zoom:50%;" />

而采用了索引结点机制后目录中只包含文件名和索引结点指针，这个目录表所需要占用的空间会小很多。

假设一个FCB是$64$B，磁盘块的大小为$1$KB，则每个盘块中只能存放$16$个FCB。若一个文件目录中共有$640$个目录项，则共需要占用$640/16=40$个盘块。因此按照某文件名检索该目录，平均需要查询$320$个目录项，平均需要启动磁盘$20$次(每次磁盘$I/O$读入一块)。

但若使用索引结点机制，文件名占$14$B，索引结点指针站$2$B，则每个盘块可存放$64$个目录项，那么按文件名检索目录平均只需要读入$320/64=5$个磁盘块。显然，这将大大提升文件检索速度。

当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据"存放位置"即可找到文件。而存放在外存中的索引结点称为"磁盘索引结点"，当索引结点放入内存后称为"内存索引结点"。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。

文件目录总结：

<img src="https://image.sybblogs.fun/img-common/202402111551559.png" alt="文件目录总结" style="zoom:50%;" />

## ==3. 文件的物理结构==

由之前的学习知道操作系统作为最接近硬件的软件层次，需要对硬件进行管理，包括外存(磁盘)。操作系统对磁盘的管理主要是对非空闲磁盘块进行管理(存放文件数据的磁盘块)、对空闲磁盘块的管理。对非空闲磁盘块的管理是探讨文件的物理结构$/$文件分配方式。对空闲磁盘块的管理是探讨文件存储空间管理的问题。

这里重点介绍文件的物理结构(文件分配方式)。也即文件数据应该怎样存放在外存中。分为三种方式：连续分配、链接分配(进一步细分为：隐式链接、显式链接)、索引分配。

<img src="https://image.sybblogs.fun/img-common/202402111615306.png" alt="文件分配方式" style="zoom:33%;" />

补充：在内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件"块"。于是文件的逻辑地址也可以表示为(逻辑块号，块内地址)的形式。若块的大小是$1$KB，则$1$MB大小的文件可以被分为$1$K个块。同样操作系统为文件分配存储空间都是以块为单位的。用户通过逻辑地址来操作自己的文件，操作系统要负责实现**从逻辑地址到物理地址的映射**。

### 3.1 连续分配方式

文件的连续分配方式要求每个文件在磁盘上占有一组连续的块。

<img src="https://image.sybblogs.fun/img-common/202402111622101.png" alt="连续分配方式" style="zoom: 33%;" />

如上图所示，文件`aaa`被分为$3$个相同的逻辑块。这个三个相同的逻辑块在被放到物理内存时，需要占有一组连续的块($4,5,6$号块)。

用户通过逻辑地址来操作自己的文件，操作系统负责实现从逻辑地址转换为物理地址的映射方式。为了实现这个地址映射的功能，在文件的目录表中必须记录两个文件属性：文件的起始块号和文件的长度。

<img src="https://image.sybblogs.fun/img-common/202402111625043.png" alt="连续分配方式例子" style="zoom:50%;" />

如文件`aaa`，它的起始块号是物理内存中的$4$号存储单元，长度是$3$，所以$4,5,6$号内存单元共同组成`aaa`文件。

所以用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项(FCB)，之后物理块号$=$起始块号$+$逻辑块号。如用户要访问`aaa`文件逻辑块号为$2$的块，那么只要用逻辑块号$2+$`aaa`文件的起始地址$4=6$。所以物理块号$6$就是要访问的真实地址。当然，还需要检查用户提供的逻辑块号是否合法(逻辑块号$\ge$长度就不合法)。

可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问(即随机访问)。

另外磁盘读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。而采用连续分配方式，文件的块在物理内存上是连续存放的，所以访问一个文件移动的磁头所需时间就很短。

结论：连续分配的文件在顺序读$/$写时速度最快。

<img src="https://image.sybblogs.fun/img-common/202402111634783.png" alt="连续分配方式例子2" style="zoom:33%;" />

如上图，若此时文件$A$要拓展，需要再增加一个磁盘块(总共需要连续的$4$个磁盘块)。由于采用连续结构，因此文件$A$占用的磁盘块必须是
连续的，而文件$A$最后一个块(黄色部分)后面的块已经被占用了。所以不得不把整个文件$A$迁移到下面绿色区域的位置。

<img src="https://image.sybblogs.fun/img-common/202402111637383.png" alt="连续分配方式例子3" style="zoom:33%;" />

结论：物理上采用连续分配的文件不方便拓展。

若橙色区域为非空闲块，绿色区域为空闲磁盘块。

<img src="https://image.sybblogs.fun/img-common/202402111638435.png" alt="连续分配方式例子4" style="zoom:33%;" />

若此时创建的新文件大小为$3$个块，那么无法为其分配足够的存储空间。

结论：物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片可以用紧凑来处理碎片，但是需要耗费很大的时间代价。

总结：

1. 连续分配方式要求每个文件在磁盘上占有一组连续的块。

2. 优点：支持顺序访问和直接访问( 即随机访问)。连续分配的文件在顺序访问时速度最快。

3. 缺点：不方便文件拓展。存储空间利用率低，会产生磁盘碎片。

### 3.2 链接分配方式

文件的链接分配采取离散分配的方式，可以为文件分配离徽的磁盘块。分为隐式链接和显式链接两种。

#### 隐式链接

如果采用这种方式，在文件的目录项，也就是文件对应的FCB中需要记录这个文件的起始块号和结束块号。另外各个块之间都会一定的存储空间存储指向下一块的链接指针，当然最后一个块是没有链接指针的。

<img src="https://image.sybblogs.fun/img-common/202402111700379.png" alt="隐式链接" style="zoom:33%;" />

这些链接对于用户来说是透明的。采用这种方式实现文件的逻辑块号到物理块号的转变方法如下：

用户给出要访问的逻辑块号$i$，操作系统找到该文件对应的目录项(FCB)，找到这个文件的起始块号。于是操作系统可以先读入这个文件的起始块，而这个起始块就是逻辑上的$0$号块。只有将这个起始块读入内存后才能知道下一个块的位置(链接指针指向下一块)。因此，读入$i$号逻辑块，需要先依次读入$0\sim n-1$号逻辑块，才能找到$i$号块存放的位置，所以总共需要$i+1$次磁盘$I/O$。

结论：采用链式分配(隐式链接)方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。

采用这种方式很适合拓展文件：

<img src="https://image.sybblogs.fun/img-common/202402111700379.png" alt="隐式链接" style="zoom:33%;" />

假设此时这个文件`aaa`需要拓展，也就是需要再分一个新的磁盘块，由于这些文件的块是离散分配的，因此只需要从文件空闲地方随便找一个空闲的位置，再将这个空闲块写入数据后挂到`aaa`文件链尾即可。假如这里挑选空闲块号是$8$号块，之后还需要把结束块号设置为$8$。

<img src="https://image.sybblogs.fun/img-common/202402111723178.png" alt="隐式链接2" style="zoom:33%;" />

结论：采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。

总结：

1. 隐式链接，即除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。
2. 优点：很方便文件拓展，不会有碎片问题，外存利用率高。
3. 缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。

#### 显示连接

把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表(FAT，File Allocntion Table)。

磁盘当中的各个块的先后顺序都是统一记录在文件分配表当中的。所以一个磁盘有多少个块在文件分配表(FAT)中就相对应的有多少个表项。

假设某个新创建的文件`aaa`依次存放在磁盘块$2\rightarrow5\rightarrow0\rightarrow1$。

在`aaa`的FCB，也就是目录项当中，需要记录文件`aaa`存放的起始块号。另外在文件分配表中会显示的记录，文件`aaa`这几个物理块的链接关系。由于$2$号块是起始块，所以FAT中$2$号块表项的下一块会记录$5$。

<img src="https://image.sybblogs.fun/img-common/202402111748269.png" alt="显示链接" style="zoom:33%;" />

接着依次将FAT对应块号的下一块设置为对应的值。当最后一个$0$号物理块项的下一块记录是$1$，而$1$号物理块作为最后一个块，所以$1$号块的下一块记录值可以设置为一个特殊的值，如：$-1$。

<img src="https://image.sybblogs.fun/img-common/202402111752005.png" alt="显示链接2" style="zoom:33%;" />

注意：一个磁盘仅设置一张FAT。在开机时，将FAT读入内存，并常驻内存。FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此"物理块号"字段可以是隐含的。

实现文件逻辑块号到物理块号的转换：

用户给出要访问的逻辑块号$i$，操作系统找到该文件对应的目录项(FCB)。可以从目录项中找到起始块号，若$i>0$， 则查询内存中的文件分配表FAT，往后找到$i$号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。

如要找到文件`aaa`的$1$号逻辑块号，需要先找到起始块号$1$，再根据FAT找到$1$号逻辑块即可。

<img src="https://image.sybblogs.fun/img-common/202402111757810.png" alt="显示链接3" style="zoom:33%;" />

这里文件`aaa`的$1$号逻辑块号是$0$。

结论：采用链式分配(显式链接)方式的文件，支持顺序访问，也支持随机访问(想访问$i$号逻辑块时，并不需要依次访问之前的$0\sim i-1$(号逻辑块)，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。

显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。

总结：

1. 显式链接，即把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT， FileAllocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。
2. 优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。
3. 缺点：文件分配表的需要占用一定的存储空间。

考试题目中遇到未指明隐式$/$显式的"链接分配"，默认指的是隐式链接的链接分配。

### 3.3 索引分配

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表。建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。

假设某个新创建的文件`aaa`的数据依次存放在磁盘块$2\rightarrow5\rightarrow13\rightarrow9$。采用所以分配方式，系统会为`aaa`，这个文件建立一张索引表。这个索引表记录了`aaa`这些逻辑块和物理块之间一一对应的映射关系。

<img src="https://image.sybblogs.fun/img-common/202402111810382.png" alt="索引分配" style="zoom: 50%;" />

如果`aaa`文件的索引表是存放在$7$号磁盘块当中的，那么$7$号磁盘块就是`aaa`的索引块。而$2,5,13,9$这几个磁盘块是`aaa`文件的数据块。采用索引分配方式的文件，需要在自己的目录项FCB中记录自己的索引块到底是哪一块。而索引块中存放的是索引表。因此系统可以根据索引块的块号找到对应的索引表，接着就可以找到各个逻辑块对应的块号了。

<img src="https://image.sybblogs.fun/img-common/202402111818792.png" alt="索引分配方式" style="zoom:33%;" />

如上图，`aaa`文件的索引表存放在$7$号存储单元，实际数据是依次存放在$2,5,13,9$这几个块中。

注：在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。

可以用固定的长度表示物理块号( 如：假设磁盘总容量为$1$TB$=240$B，磁盘块大小为$1$KB，则共有$2^{30}$个磁盘块，则可用$4$B表示磁盘块号)，因此，索引表中的"逻辑块号"可以是隐含的。

采用索引分配方式，如何实现文件的逻辑地址到物理地址的转换：

假如用户给出要访问的逻辑块号$i$，操作系统找到该文件对应的目录项(FCB)，从中找到这个文件索引块的块号，再从索引块中读出这个文件索引表的内容。接着只需要通过逻辑块号来查询这个索引表即可。

<img src="https://image.sybblogs.fun/img-common/202402111824020.png" alt="索引分配方式2" style="zoom:33%;" />

可见，索引分配方式可以支持随机访问。文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)。但是索引表需要占用一定的存储空间。

假设每个磁盘块$1$KB，一个索引表项$4$B，则一个磁盘块只能存放$1K/4B=256$个索引项。如果一个文件的大小超过了$256$块，那么一个磁盘块是装不下文件的整张索引表的，解决这个问题方法如下：

- 链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

  如果一个文件的大小超过了$256$块的话，就意味着这个文件的索引表的索引项肯定也超过$256$。因此可以将这个索引表拆分，为这个文件分配多个索引块，每个索引块中存放$256$个索引项，并且在每个索引项中，用一定的空间存储指向下一个索引块的指针。这样就可以将一个很长的索引表拆分成不同的部分，并且用链接的方式将这些索引表链接起来。

  <img src="https://image.sybblogs.fun/img-common/202402111911472.png" alt="索引分配方式3" style="zoom:33%;" />

  假设要找到`aaa`的逻辑块号为$256$的逻辑块，为了查到$256$号逻辑块对应的物理块号，就肯定需要找到`aaa`的第二个索引块，而各个索引块之间是用链接的方式连起来的，所以为了找到第二个索引块的块号，操作系统首先需要把第一个索引块读入内存，然后才能根据这个索引块中的指针，找到第二个索引块块号，并且把第二个索引块读入内存。只有这样才能找到$256$对应的物理块号是多少。

  若一个文件大小为$256*256$KB$=65,536$KB$=64$MB。该文件共有$256*256$个块，也就对应$256*256$个索引项，也就需要$256$个索引块来存储，这些索引块用链接方案连起来。若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块(第$256$个索引块)，而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前$255$个索引块。

  这显然是很低效的。为了解决这个问题，提出了多级索引的方案。

- 多层索引

  建立多层索引(原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。

  同样若一个文件大小为$256*256$KB$=65,536$KB$=64$MB。若某文件采用两层索引，则该文件的最大长度可以到
  $256*256*1$KB$=65,536$KB$=64$MB。

  <img src="https://image.sybblogs.fun/img-common/202402111923320.png" alt="多层索引" style="zoom:33%;" />

  若采用多层索引，则各层索引表大小不能超过一个磁盘块。可根据逻辑块号算出应该查找索引表中的哪个表项。
  如：要访问$1026$号逻辑块，则$1026/256= 4$，$1026\%256=2$。也就是说，$1026$号块存放的位置对应二级索引的$4$号表项的位置，可以通过以及索引表查到$4$号块的位置，再通过取余可以知道存放在$4$号二级索引表当中的$2$号表项。所以访问目标数据块，需要$3$次磁盘$I/O$。

  若采用三层索引，则文件的最大长度为$256*256*256*1$KB$=16$GB。类似的，访问目标数据块，需要$4$次磁盘$I/O$。

  故采用$K$层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要$K+1$次读磁盘操作。

  这种方式也存在问题，假如一个文件本来很小，数据块只有$1$KB，但是这个文件如果采用两层索引，读入$1$KB的内容需要三次读磁盘操作。显然没有必要。为了解决这个问题提出了混合索引。

- 混合索引

  多种索引分配方式的结合。

  例如，一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块)，又包含一级间接索引(指向单层索引表)、还包含两级间接索引(指向两层索引表)。

  <img src="https://image.sybblogs.fun/img-common/202402111934540.png" alt="混合索引" style="zoom:33%;" />

  如上图，如果直接地址有$8$块，一级简介索引有$256$块，而二级简介索引有$256*256$块，每块大小是$1$KB，则这种结构的索引支持的最大文件长度为$65800$KB

  若顶级索引表还没读入内存，则访问$0\sim 7$号逻辑块需要两次读磁盘：第一次将索引表放入内存，第二次是读取数据块。若访问$8\sim263$则需要三次读磁盘。相应的访问$264\sim65799$需要四次读磁盘。

  所以采用混合索引方式好处是对于小文件，只需较少的读磁盘次数就可以访问目标数据块(一般计算机中小文件更多)。

总结：

1. 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表， 索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表。建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。但若文件太大，索引表项太多，可以采取以下三种方法解决：

2. 链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

   缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到$i$号索引块，必须先依次读入$0\sim i-1$号索引块，这就导致磁盘$I/O$次数过多，查找效率低下。

3. 多层索引：建立多层索引(原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要$K+1$次读磁盘操作。

   缺点：即使是小文件，访问一个数据块依然需要$K+1$次读磁盘。

3. 混合索引：多种索引分配方式的结合。

   例如，一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块)，又包含一级间接索引(指向单层索引表)、还包含两级间接索引(指向两层索引表)。

   优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。

重要考点：

①要会根据多层索引、混合索引的结构计算出文件的最大长度(注意：各级索引表最大不能超过一个块)。

②要能自己分析访问某个数据块所需要的读磁盘次数(注意：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件，即顶级索引块是否已调入内存)。

文件的物理结构总结：

<img src="https://image.sybblogs.fun/img-common/202402111946234.png" alt="文件的物理结构总结" style="zoom: 50%;" />

## 4. 文件的逻辑结构和物理结构区别

所谓的"逻辑结构"就是指在用户看来，文件内部的数据应该是如何组织起来的。而"物理结构"指的是在操作系统看来，文件的数据是如何存放在外存中的。

<img src="https://image.sybblogs.fun/img-common/202402111948965.png" alt="逻辑结构和物理结构" style="zoom:33%;" />

### 4.1 无结构文件

例子：用C语言创建一个无结构文件

~~~c
FILE *fp = lfopen("test.txt", "W"); //打开文件
if( fp == NULL ){
    printf("打开文件失败!");
    exit(0) ;
}

//写入1W个Hello world
for (int i=0; i<10000; i++)
    fputs("Hello world!",fp);
fclose(fp);//关闭文件
~~~

执行这段代码后会创建一个文本文件(无结构文件)，里面会写入一万个"Hello world!"。

<img src="https://image.sybblogs.fun/img-common/202402111952034.png" alt="test" style="zoom: 33%;" />

每个字符$1$B。在用户看来，整个文件占用一片连续的逻辑地址空间。

<img src="https://image.sybblogs.fun/img-common/202402111955763.png" alt="逻辑地址空间" style="zoom:50%;" />

如果此时想读入第$17$个字符：

~~~c
FILE *fp = fopen("test.txt","r"); //以"读"方式打开文件
if( fp == NULL ){
    puts("Fail to open file!") ;
    exit(0) ;
}
fseek(fp,16,SEEK_SET);//读写指针指向16
char C = fgetc(fp);//从读写指针所指位置读出1个字符
printf("字符: %C",c);//打印从文件读出的字符
fclose(fp);//关闭文件
~~~

运行结果是`o`。总之在用户看来，似乎所有的字符都是连续存放的，所以只需要提供想访问那个字符在文件中的逻辑地址($17$)，就可以顺序找到想要找的任何一个数据。这种从用户的视角来说，但是从操作系统视角来说，这些字符就是一堆二进制数据，每个磁盘块可存储$1$KB，所以这些字符会被拆分为一块一块。

<img src="https://image.sybblogs.fun/img-common/202402111959085.png" alt="系统拆分" style="zoom:50%;" />

接着操作系统会根据文件管理的策略来决定是用连续分配还是连接分配或者是索引分配方式来存放在磁盘中。

<img src="https://image.sybblogs.fun/img-common/202402112003961.png" alt="采用连续分配方式" style="zoom:33%;" />

<img src="https://image.sybblogs.fun/img-common/202402112004278.png" alt="采用连接分配方式" style="zoom:33%;" />

<img src="https://image.sybblogs.fun/img-common/202402112004911.png" alt="采用索引分配方式" style="zoom: 33%;" />

所以从用户角度看就做了以下事情：

1. 使用C语言库函数`fseek`，将文件读写指针指向位置$n$。即指明逻辑地址。

2. 使用C语言库函数`fgetc`，从读写指针所指位置读出$1$B内容。

   `fgetc`底层使用了`Read`系统调用，总之操作系统总能将(逻辑块号，块内偏移量)转换为(物理块号，块内偏移量)。

### 4.2 顺序文件

用C语言创建顺序文件

~~~c
typedef struct {
    int number;//学号
    char name[30];//姓名
    char major[30];//专业
}Student_info;
//以"写"方式打开文件
FILE *fp = fopen("students.info", "w");
if(fp == NULL) {
    printf("打开文件失败!");
    exit(0) ;
}
Student_info student[N];//用数组保存N个学生信
for(int i = 0; i<N; i++){//生成 N个学生信息
    student[i].number=i;
    student[i].name[0]='?';
    student[i].major[0]='?';
}
//将N个学生的信息写入文件
fwrite (student,sizeof(Student_info),N,fp);//参数分别是:首地址,每条记录大小,要写入几条记录,要存放数据的文件
fclose(fp);
~~~

上面程序运行后，学生信息就会存放在这个文件中。

<img src="https://image.sybblogs.fun/img-common/202402112011733.png" alt="c语言创建顺序文件" style="zoom: 33%;" />

每个学生记录占$64$B。如果要读出第五个学生的信息，需要用以下代码实现：

~~~c
//以"读"方式打开文件
FILE *fp =fopen("students.info", "r");
if(fp == NULL) {
    printf("打开文件失败!");
    exit(0);
}
//文件读写指针指向编号为5的学生记录
fseek(fp,5*sizeof(Student_info),SEEK_SET);
Student_info stu;
//从文件读出1条记录，记录大小为sizeof(Student_ info)
fread(&stu,sizeof(Student_info), 1, fp);
printf("学生编号: %d\n",stu.number);
fclose(fp);
~~~

这样就可以读出$5$号学生的编号。总之在用户看来每个学生的记录似乎是连续存放的。并且每个学生占的空间记录是$64$B，是相同的。所以当要从问件中读出某一个学生对应的记录时，就可以方便算出那条记录对应的逻辑地址。总之只需要给操作系统提供逻辑地址，接下来操作系统会完成转换的操作。

上面是用顺序存储方式，同样用户也可以采用链式存储方式：

<img src="https://image.sybblogs.fun/img-common/202402112022051.png" alt="链式存储" style="zoom:50%;" />

对于用户来说

1. 顺序存储，各条记录相邻这存放。

   支持随机访问：指可以直接确定第$i$条记录的逻辑地址。

2. 链式存储，各条记录离散着存放，用指针表示先后关系。

所以用户可以自己决定采用什么方式。但是无论如何在用户看来这些记录都是占有一整片连续空间。

从操作系统视角来看，学生信息就是一堆二进制数据，每个磁盘块可存储$1$KB，学生信息会被拆分为一块一块!

<img src="https://image.sybblogs.fun/img-common/202402112019332.png" alt="物理结构" style="zoom:50%;" />

此时操作系统可以采用连续分配、链接分配或者索引分配方式存放这些数据。至于哪一种分配方式作为用户不需要关心。

**所以文件内部各条记录链式存储是由创建文件的用户自己设计的。而文件整体用链接分配方式是由操作系统决定。**

### 4.3 索引文件

C语言实现索引结构：

~~~c
//存放学生索引
typedef struct {
    int number;//学号
    int addr;//学生记录的逻辑地址
} IndexTable;

//存放学生信息
typedef struct {
    char name[30];//姓名
    char major[30];//专业
}Student_info;
~~~

这样一个`IndexTable`结构体就对应了一个索引项，每个索引项记录就学生的学号和学生记录的地址。之后的空间可以定义一个`Student_info`存放学生信息。之后索引项会建立起学号和各个学生的映射关系。

<img src="https://image.sybblogs.fun/img-common/202402112029275.png" alt="建立索引文件" style="zoom: 50%;" />

从用户视角来看，索引文件中的数据项依然是连续存放的。如：前$1$MB存放索引项，后续部分存放记录。在找某个学生时候可以先把前面$1$MB字节的索引数据读入内存。查询其中的索引项找到目标学生的索引项，之后在根据这个索引项的信息确定目标学生的记录存放在哪个逻辑地址当中。

从操作系统视角来看，这些信息就是一堆二进制数据，每个磁盘块可存储$1$KB，所以会被拆分为一块一块!

<img src="https://image.sybblogs.fun/img-common/202402112019332.png" alt="物理结构" style="zoom:50%;" />

此时操作系统可以采用连续分配、链接分配或者索引分配方式存放这些数据。至于哪一种分配方式作为用户不需要关心。

**所以索引文件的索引表是用户自己建立的，映射是由关键字$\rightarrow$记录存放的逻辑地址。而索引分配的索引表是操作系统建立的，映射是从逻辑块号$\rightarrow$物理块号。**

逻辑结构和物理结构总结：

<img src="https://image.sybblogs.fun/img-common/202402112040654.png" alt="逻辑结构和物理结构总结" style="zoom:33%;" />
