[^2-2-2.1]:参考佩亚诺余项运算

[^7-2-1]:$\lceil\rceil$表示向上取整
[^7-3.6-1]:这里的后继结点不是指子结点，而是通过递归遍历时的访问顺序。

[toc]

# 一. 基本概念

> ==数据结构三要素：逻辑结构、数据的运算、物理结构(存储结构)==

1. 提取操作对象，找出操作对象之间的关系并用数学的语言描述就是数据结构。

   操作对象指：每位学生的信息(学号、姓名、性别.....)

   操作的算法指：查询、插入、修改、删除等。

2. 数据结构可分为：线性数据结构（数组，队列，线性表等）、非线性数据结构（集合，树，图等）。

   线性数据结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。如：学生管理系统，是一对一关系

   非线性数据结构：一个结点可能油多个直接前趋和直接后继。如：目录结构(树)、最短路径(图)，是一对多关系或多对多关系。

   [最短路径：](https://image.sybblogs.fun/img-common/202304052128205.png)

   <img src="https://image.sybblogs.fun/img-common/202304052128205.png" alt="导航节点" style="zoom: 50%;" />

## 1. 概念及定义

### 数据(Data)

> 数据是能输入计算机且能被计算机处理的各种符号的集合。

数据特点：

1. 信息的载体

2. 是对客观事物符号化的表示

3. 能够被计算机识别存储和加工

数据包括：

1. 数值型的数据：整数、实数等。

2. 非数值型的数据：文字、图像、图形、声音等。

### 数据元素

> 数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。而一个数据元素可由多个数据项组成，数据项是构成数据元素不可分割最小单位。

也可称为元素，或称为记录、结点或顶点。如上面最短路径图，其中的每个点我们称之为结点。

- 数据项

  > 数据项是构成元素的不可分割的最小单位。

  [数据项：](https://image.sybblogs.fun/img-common/202304052131322.png)

  <img src="https://image.sybblogs.fun/img-common/202304052131322.png" alt="数据项" style="zoom:43%;" />

  上面每行可称为数据元素，而每列可以称之为数据元素中的**数据项**。

- 三者关系

  数据$>$数据元素$>$数据项

  例子：学生表$>$个人记录$>$学号、姓名....

### 数据对象

> 数据对象是性质相同的数据元素的集合，是数据的一个子集。

如：学籍表可以看作是一个数据对象，由若干条学生信息构成的子集。

- 数据元素和数据对象关系

  数据元素：组成数据的基本单位。其与数据的关系是：数据元素是集合的个体。

  数据对象：性质相同的数据元素的集合。其与数据的关系是：集合的子集。

[数据对象图例：](https://image.sybblogs.fun/img-common/202304162111379.png)

<img src="https://image.sybblogs.fun/img-common/202304162111379.png" alt="数据对象图例" style="zoom: 25%;" />

### 数据结构

> 意义：数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构( Structure )
>
> 数据结构是指相互之间存在一种或多种特定关系的数据元素集合。或者说，数据结构是带结构的数据元素的集合。

- 数据结构包含内容：

  1. 数据元素之间的逻辑关系，也称为**逻辑结构**。
  2. 数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的**物理结构**或数据的**存储结构**。
  3. 数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。

- 数据结构的两个层次

  1. 逻辑结构：

     描述数据元素之间的逻辑关系

     与数据存储无关，独立于计算机

     是从具体问题抽象出来的数学模型

  2. 物理结构(存储结构)：

     数据元素及其关系在计算机存储器中的结构(存储方式)

     是数据结构在计算机中的表示

  3. 逻辑结构和存储结构的关系：

     存储结构是逻辑关系的映像与元素本身的映像。

     逻辑结构是数据结构的抽象，存储结构是数据结构的实现。

     两者综合起来建立了数据元素之间的结构关系。

## 2. 四种逻辑结构

> 逻辑结构和数据的运算是定义一种数据结构前提。

集合结构(大纲不考)：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

[集合结构例子：](https://image.sybblogs.fun/img-common/202304161957873.png)

<img src="https://image.sybblogs.fun/img-common/202304161957873.png" alt="集合结构例子" style="zoom:25%;" />

线性结构：结构中的数据元素之间存在着一对一的线性关系，除了除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。

基本运算：①查找第$i$个数据元素。②在第$i$个位置插入新的数据元素。③删除第$i$个位置数据元素.....

[线性结构例子：](https://image.sybblogs.fun/img-common/202304161959324.png)

<img src="https://image.sybblogs.fun/img-common/202304161959324.png" alt="线性结构例子" style="zoom:25%;" />

树形结构：结构中的数据元素之间存在着一对多的层次关系。

[树形结构例子：](https://image.sybblogs.fun/img-common/202304162001827.png)

<img src="https://image.sybblogs.fun/img-common/202304162001827.png" alt="树形结构例子" style="zoom:25%;" />

图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。

[图结构例子：](https://image.sybblogs.fun/img-common/202304162002143.png)

<img src="https://image.sybblogs.fun/img-common/202304162002143.png" alt="图结构例子" style="zoom:25%;" />

[逻辑结构分类：](https://image.sybblogs.fun/img-common/202304052216835.png)

<img src="https://image.sybblogs.fun/img-common/202304052216835.png" alt="逻辑结构分类" style="zoom: 50%;" />

## 3. 四种基本存储结构

> 当我们定义完一种数据结构后，需要用计算机来实现这种数据结构，此时用到基本存储结构。

### 顺序存储结构

含义：

1. 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
2. C语言中用数组来实现顺序存储结构

[顺序存储结构示例：](https://image.sybblogs.fun/img-common/202304052224091.png)

<img src="https://image.sybblogs.fun/img-common/202304052224091.png" alt="顺序存储结构" style="zoom:43%;" />

### 链式存储结构

含义：

1. 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针表示。
2. C语言中用指针来实现链式存储结构。

[链式存储结构：](https://image.sybblogs.fun/img-common/202304052231942.png)

<img src="https://image.sybblogs.fun/img-common/202304052231942.png" alt="链式存储结构" style="zoom: 33%;" />

如：上图$bat$对应指针(地址)是$165$，后面$130$是下一个元素地址，即$cat$。没有即为$NULL$

### 索引存储结构

含义：

1. 在存储结点信息的同时，还建立附加的索引表。
2. 通俗讲索引就是目录，一般形式是：关键字、地址。
3. 关键字是能唯一标识一个结点的数据项。
4. 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引。

[索引存储结构：](https://image.sybblogs.fun/img-common/202304162013420.png)

<img src="https://image.sybblogs.fun/img-common/202304162013420.png" alt="索引存储结构2" style="zoom:25%;" />

### 散列存储结构

根据结点的关键字直接计算出该结点的存储地址。如：哈希表。

## 4. 数据类型、抽象数据类型

### 4.1 数据类型

> 数据类型是一个值的取值范围和定义在此范围上的一组操作(加减、取模等)的总称。

1. 原子类型：其值不可再分的数据类型。如$int$类型(可进行加、减、乘、除、取模等运算)，$bool$类型(可进行与、或、非等操作)
2. 结构类型：其值可以再分解为若干成分(分量)的数据类型。如定义一个可操作横坐标和纵坐标的函数。

### 4.2 抽象数据类型(ADT)

> 抽象数据类型是抽象数据组织及与之相关的操作。如：逻辑结构、数据运算、物理结构(存储结构)，这个过程。

# 二. 算法

## 1. 算法基本概念

> 算法就是如何高效地处理这些数据，以解决实际问题。
>
> 其定义是对特定问题求解步骤地一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

算法特点：

1. 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。

3. 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入。 一个算法有零个或多个输入， 这些输入取自于某个特定的对象的集合。
   输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

以上特点只要有一个不满足，就不能称之为算法。

一个好的算法所具备特质：

1. 正确性。算法能够正确解决求解问题。
2. 可读性。算法应具有良好的可读性，以帮助人们理解。==考试时候要写注释==。
3. 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 高效率和低存储。即算法时间复杂度低，空间复杂度低。

[算法基本概念总结：](https://image.sybblogs.fun/img-common/202304162133530.png)

<img src="https://image.sybblogs.fun/img-common/202304162133530.png" alt="算法基本概念总结" style="zoom: 33%;" />

## 2. ==算法效率度量==

算法复杂度度量可以从两个方面：①时间复杂度、②空间复杂度

### 2.1 时间复杂度

> 用事前预估算法时间开销$T(n)$与问题规模$n$的关系($T$表示"time")。

方法：

- 时间复杂度加法规则：

  我们可以通过对每一行有效代码进行时间记录，从而估计出代码所需的执行时间。如下：

  ~~~c++
  void loveYou(int n) { //n 为问题规模
      int i=1;//爱你的程度
      while(i<=n){
          i++ ;
          //每次+1
          printf("I Love You %d\n",i);
      }
      printf("I Love You More Than %d\n",n) ;
  }
  int main( ){
      loveYou(3000) ;
  }
  ~~~

  以上代码模拟打印3000遍I Love You。运行结果如下：

  ~~~c++
  ....
  I Love You 2994
  I Love You 2995
  I Love You 2996
  I Love You 2997
  I Love You 2998
  ....
  I Love You 3001
  I Love You More Than 3000
  ~~~

  我么可以估计一下语句执行时间：①⑤各执行一次，②执行3001次，③④执行3000次，所以变量$n$为3000时，所需执行时间为：

  $T(3000)=1+1+3001+2\times3000$。所以其时间开销$T$与问题规模$n$关系式子为：$T(n)=3n+3$。

  虽然我们通过如此简单方式得出这段程序所需执行时间，但是广义化之后该方法并不适用：如果代码是几万行的这种方法显然不适用。

  根据我们所学数学知识，我们想得到一个估计大小时，一个表达式中更低阶部分我们往往可以省略。所以上面可以写为$T(n)=3n$。假设有以下算法时间复杂度：
  $$
  \begin{equation*}
  	\begin{aligned}
  &T_1(n)=3n^2+3n+3000\xrightarrow{忽略低阶后}=3n^2\\
  \\
  &T_2(n)=n^3+n^2+9999\xrightarrow{忽略低阶后}=n^3
  	\end{aligned}
  \end{equation*}
  $$
  我们一般用$O$表示"同阶"(同等数量级。即，当$n\to\infty$时，二者极限之比为常数，来代替最高阶前面系数)，来规范时间复杂度的写法。所以上面规范写法如下：
  $$
  \begin{equation*}
  	\begin{aligned}
  &3n^2=O(n^2)\\
  \\
  &n^3=O(n^3)
  	\end{aligned}
  \end{equation*}
  $$
  结论：一个程序的算法复杂度可以只考虑阶数高的部分。以上是时间复杂度计算的加法规则，同样我们可以推出以下的规则：

- 乘法规则

  $T(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$

  即多项相乘，都保留。如：$T(n)=O(n^3)\times O(n^2)=O(n^5)$[^2-2-2.1]

- 混合运算规则

  $T(n)=O(f(n))+O(g(n))=max\{O(f(n))+O(g(n))\}$

  混合运算需要保留最大那个项。为了方便理解我们可以保留其中变化趋势最大函数，函数变化趋势如下：

  [复杂度变化趋势：](https://image.sybblogs.fun/img-common/202304171954955.png)

  <img src="https://image.sybblogs.fun/img-common/202304171954955.png" alt="复杂度变化趋势" style="zoom:43%;" />

  例子：$T(n)=n^3+n^2\log_2n=$$O(n^3)+O(n^2\log_2n)=$$O(n^3)$。

通过以上规则我们还要注意以下几点：

1. 顺序执行的代码只会影响常数项，所以可以忽略不记。
2. 循环执行代码中，我们只需要挑一个循环体基本操作，分析他的执行次数即可。
3. 如果有多层嵌套循环，我们只需要关注最深层代码循环次数即可。

例1：分析以下代码时间复杂度

~~~c++
//算法3- 指数递增型爱 你
void loveYou(int n) { //n 为问题规模
    int i=1;//爱你的程度
    while(i<=n){
        i=i*2; //每次翻倍
        printf("I Love You %d\n",i);        
    }
    printf("I Love You More Than %d\n",n);
}
~~~

> 答案：$T(n)=O(\log_2n)$
>
> 解析：我们直接看循环体，循环体中，赋值语句$i$每次翻倍，假设循环了$x$次，则循环结束时刚好满足$2^x>n$，所以$x=\log_2n+1$
>
> 则，时间复杂度$T(n)=O(\log_2n)$

例2：分析以下代码时间复杂度

~~~c++
void loveYou(int flag[]， int n) { //n 为问题规模
    printf("I Am Iron Man\n") ;
    for(int i=0; i<n; i++){ //从第一个元素开始查找
        if(flag[i]==n){ //找到元素n
            printf("I Love You %d\n"，n) ;
            break; //找 到后立即跳出循环
        }
    }
}
//其中flag数组是1~n个数，输入一个数n找出n在数组中的位置
int main(){
    int flag[n]={1...n};
    loveYou(flag,n); 
    return 0;
}
~~~

> 答案：最好情况：元素n在第一个位置，即最好时间复杂度$T(n)=O(1)$
> 最坏情况：元素n在最后一个位置，最坏时间复杂度$T(n)=O(n)$
> 平均情况：假设元素n在任意一个位置的概率相同为$\frac{1}{n}$，平均时间复杂度$T(n)=O(n)$
>
> 平均情况解析：循环次数$x=(1+2+3+...+n)\frac{1}{n}=(\frac{n(1+n)}{2})\frac{1}{n}=\frac{1+n}{2}$，即$T(n)=O(x)=O(n)$

注意：我们在评价一个算法时候一般只看最坏情况和平均情况，而最好情况一般参考意义不大。

[时间复杂度总结：](https://image.sybblogs.fun/img-common/202304172233517.png)

<img src="https://image.sybblogs.fun/img-common/202304172233517.png" alt="时间复杂度总结" style="zoom: 33%;" />

### 2.2 空间复杂度

空间复杂度需要时间复杂度中运算知识。空间复杂度我们用$S(n)$表示。

例1：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n];
    //声明一个长度为n的数组
    int i;
    //.....此处省略很多代码
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数所需要参数$n为int类型$占四个字节，下面的$i也是int$类型所以也是四字节，数组长度是$n$且为int类型，所以是$4n$，那么这个程序所需要空间为：$4n+8$。规范写法为$S(n)=O(n)$

结论：常数项同样不考虑，注意数组大小等。

例2：计算以下程序空间复杂度

~~~c++
void test(int n) {
    int flag[n][n]; //声明 n*n的二维数组
    int otheg[n];
    //声明一个长度为n的数乡
    int i;
    //.... .此处省略很多代码
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：二维int类型n长度数组占大小为：$4n^2$，下面一维数组是$4n$，所以$S(n)=O(n^2)+O(n)+O(1)=O(n^2)$

例3：计算以下程序空间复杂度

~~~c++
void loveYou(int n) { //n 为问题规模
    int a,b,c; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n)$
>
> 解析：函数递归$n$次，每次变量大小占$16$，所以应该为$S(n)=16n=O(n)$

结论：递归问题空间复杂$=$递归调用深度。

例4：我们对例3进行改进，讲声明变量改为数组

~~~c++
void loveYou(int n) { //n 为问题规模
    int flag[n]; //声明一 系列局部变量
    //...省略代码
    if(n>1){
        loveYou(n-1);
    }
    printf("I Love You %d\n"， n);
}
int main(){
    loveYou(n)
}
~~~

> 答案：$S(n)=O(n^2)$
>
> 解析：函数递归调用$n$次，每次数组长度为$n$，所以空间复杂度为：$1+2+3+...n=\frac{n(1+n)}{2}=\frac{1}{2}n^2+\frac{1}{2}n$，即答案。	 

[空间复杂度总结：](https://image.sybblogs.fun/img-common/202304172316612.png)

<img src="https://image.sybblogs.fun/img-common/202304172316612.png" alt="空间复杂度总结" style="zoom:43%;" />

# 三. 线性表

## 1. 线性表定义

定义：线性表是具有**相同数据类型**的$n (n≥0)$ 个数据元素的**有限序列**，其中$n$为表长，当$n=0$时线性表是一个空表。若用$L$命名线性表，则其一般表示为：
$$
\begin{equation*}
	\begin{aligned}
&L=(a_1,a_2...a_i,a_{i+1}...a_n)
	\end{aligned}
\end{equation*}
$$
几个概念：

1. $a_i$是线性表中的"第$i$个"元素线性表中的位序
2. $a_1$是表头元素；$a_n$是表尾元素。
3. 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。

## 2. 线性表的基本操作

InitList(&L)：初始化表。构造一个空的线性表$L$，分配内存空间。
DestroyList(&L)：销毁操作。销毁线性表，并释放线性表$L$所占用的内存空间。

ListInsert(&L，i，e)：插入操作。在表$L$中的第$i$个位置上插入指定元素$e$。
ListDelete(&L，i，&e)：删除操作。删除表$L$中第$i$个位置的元素，并用$e$返回删除元素的值。

LocateElem(L，e)：按值查找操作。在表$L$中查找具有给定关键字值的元素。
GetElem(L，i)：按位查找操作。获取表$L$中第$i$个位置的元素的值。

其他常用操作:
Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。
PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。
Empty(L)：判空操作。若L为空表，则返回true，否则返回false。

以上括号内的是参数。

总结：

1. 对数据的操作：创建，销毁、增删改查

2. $C$语言函数的定义：<返回值类型>函数名(<参数1类型>参数1，<参数2类型>参数2.....)

3. 函数名和参数的形式、命名都可改变。对于命名一般用驼峰命名法：

   方法名、参数名、成员变量、局部变量需要使用小驼峰命名法

   类名需要使用大驼峰命名法

4. 什么时候要传入引用"&"：对参数的修改结果需要"带回来"。解释如下：

   ~~~c++
   #include<stdio.h>
   void test(int & x) {
       x=1024;
       printf( "test函数内部x=%d\n",x);
   }
   int main() {
       int X=1;
       printf("调用test前x=%d\n",x) ;
       test(X) ;
       printf( "调用test后x=%d\n",x) ;
   }
   ~~~

   运行结果：

   调用test前x=1
   test函数内部x=1024
   调用test后x= 1024

   > 这里test函数中的$x$是引用类型，所以不用返回值就可以修改主函数中的$x$值。

[线性表知识点总结：](https://image.sybblogs.fun/img-common/202304222018400.png)

<img src="https://image.sybblogs.fun/img-common/202304222018400.png" alt="线性表知识点总结" style="zoom: 50%;" />

## 3. 顺序表

顺序表是线性表的一种。其定义是：用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置，上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。

顺序表优缺点：

- 优点:可随机存取，存储密度高
- 缺点:要求大片连续空间，改变容量不方便

我们可以用$C$语言提供的$sizeof$关键字来判断一个类型或者数据的大小。

[顺序存储：](https://image.sybblogs.fun/img-common/202304222108332.png" alt="顺序存储" style="zoom:25%;" />)

<img src="https://image.sybblogs.fun/img-common/202304222108332.png" alt="顺序存储" style="zoom:25%;" />

### 3.1 顺序表的静态分配

~~~c++
#define MaxSize 10			//定义最大长度
typedef struct{
    ElemType data[MaxSize];	//用静态的“数组”存放数据元素
    int length;				//顺序表的当前长度
}SqList;					//顺序表的类型定义(静态分配方式)
~~~

> 给各个数据元素分配连续的存储空间，大小为$MaxSize* sizeof(ElemType)$。即数组大小$\times$数据类型。
>
> 注意：$C$语言要初始化数据。否则会出现"脏数据"情况。

静态分配存在一定局限性：无法提前预知数组大小。

### 3.2 顺序表的动态分配

$C$语言中动态申请和释放内存空间函数：

- ==malloc(动态申请空间)==：SeqList.data = (ElemType *) malloc (sizeof(ElemType) * InitSize);

  > malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针。

- 
  free(删除申请空间)：free(SeqList.data)

~~~c++
#define InitSize 10	//顺序表的初始长度
typedef struct{
    ElemType *data;	//指示动态分配数组的指针
    int MaxSize;	//顺序表的最大容量
    int length;		//顺序表的当前长度
} SeqList;			//顺序表的类型定义(动态分配方式)
~~~

动态分配案例：

~~~c++
#include <bits/stdc++.h>
using namespace std;
struct stu{
	int *arr;
	int len;
};
void initArr(stu &l){						//初始化arr指针，并未其分配初始空间
	int i=0,j=0;
	l.arr=(int *)malloc(10*sizeof(int));
	l.len=0;
	while(cin>>i){							//输入数组值
		l.arr[j]=i;
		l.len++;
		j++;
	}
}

void insertArr(stu &l,int cout){			//扩大arr指针空间
	int *p=l.arr;
	l.arr=(int *)malloc((cout+l.MaxSize)*sizeof(int));
	for(int i=0;i<l.len;i++){
		l.arr[i]=p[i];
		printf("指针值：%d\n",p[i]);
	}
	free(p);
}
int main(){
	stu l;
	initArr(l);
	insertArr(l,3);
	for(int i=0;i<l.len;i++){
		cout<<l.arr[i]<<endl;				//输出扩大后的数组arr
	}
} 
~~~

顺序表的特点:

1. 随机访问，即可以在$O(1)$时间内找到第$i$个元素。
2. 存储密度高，每个节点存储数据元累
3. 拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)
4. 插入、删除操作不方便，需要移动大量元素

### 3.3 顺序表的插入

~~~c++
#define MaxSize 10				//定义最大长度
typedef struct{
    int data[MaxSize]; 			//用静态的"数组"存放数据
    int length;					//顺序表的当前长度
}SqList;						//顺序表的类型定义
bool ListInsert(SqList &L,int i,int e){
    if(i<1||i>L.length+1) 		//判断i的范围是否有效
        return false;
    if(L.length>=MaxSize)		//当前存储空间已满，不能插入
        return false;
    for(int j=L.length;j>=i;j--)//将第1个元素 及之后的元素后移
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;				//在位置i处放入e 
    L.length++;					//长度加1
    return true ;
}
int main( ) {
    SqList L;					//声明一个顺序表
    InitList(L);				//初始化顺序表
    //...此处省略一些代码，插入几个元素
    ListInsert(L,3,3);
    return 0;
}
~~~

> 以上就是对顺序表进行元素插入操作。

我们可以对以上ListInsert()方法进行时间复杂度分析：

1. 最好情况：新元素插入到表尾，不需要移动元素。

   $i=n+1$，循环$0$次，最好时间复杂度$=O(1)$

2. 最坏情况：新元素插入到表头，需要将原有的$n$个元素全部向后移动

   $i=1$，循环$n$次；最坏时间复杂度$=O(n)$

3. 平均情况：假设新元素插入到任何一个位置的概率相同，即$i=1,2,3...,length+1$的概率都是$p=\frac{1}{n+1}$

   当$i=1$时，循环$n$次；$i=2$时，循环$n-1$次；$i=3$时，循环$n-2$次$...i=n+1$时，循环$0$次。

   所以平均循环次数$=np+(n-1)p+(n-2)p+...+p=\frac{n(n+1)}{2}\frac{1}{n+1}=\frac{n}{2}$

   由此可得时间复杂度为$O(n)$

### 3.4 顺序表的删除

~~~c++
#define MaxSize 10				//定义最大长度
typedef struct{
    int data[MaxSize]; 			//用静态的"数组"存放数据
    int length;					//顺序表的当前长度
}SqList;	
bool ListDelete(SqList &L,int i,int &e){
    if(i<1||i>L.length)			//判断i的范围是否有效
        return false;
    e=L.data[i-1];				//将被删除的元素赋值给e
    for(int j=i;j<L.length;j++) //将第i个位 置后的元素前移
        L.data[j-1]=L.data[j];
    L.length--;					//线性表长度减1
    return true ;
}
int main() {
    SqList L;					//声明一个顺序表
    InitList(L);				//初始化顺序表
    //.. .此处省略一些代码，插入几个元素
    int e; 						//用变量e把删除的元素”带回来”
    if (ListDelete(L,3,e))
        printf("已删除第3个元素,删除元素值为=%d\n",e);
    else
        printf("位序i不合法，删除失败\n");
    return 0;
}
~~~

运行结果：已删除第3个元素,删除元素值为$=$3；

我们可以对以上ListDelete()方法进行时间复杂度分析：

1. 最好情况：删除表尾元素，不需要移动其他元素

   $i=n$，循环$0$次，最好时间复杂度$=O(1)$

2. 最坏情况：删除表头元素，需要将后续的$n-1$个元素全都向前移动

   $i=1$，循环$n-1$次；最坏时间复杂度$=O(n)$；

3. 平均情况：假设删除任何一个元素的概率相同，即$i= 1,2,3, ... length$的概率都是$p=\frac{1}{n}$

   $i=1$，循环$n-1$次，$i=2$，循环$n-2$次$...i=n$时，循环$0$次

   平均循环次数为$=(n-1)p+(n-2)p+...+p=\frac{n(n-1)}{2}\frac{1}{n}=\frac{n-1}{2}$

   由此可得时间复杂度为$O(n)$

[顺序表基本操作总结：](https://image.sybblogs.fun/img-common/202304231803306.png)

<img src="https://image.sybblogs.fun/img-common/202304231803306.png" alt="顺序表基本操作" style="zoom: 33%;" />

### 3.5 顺序表的查找

- 按位查找

  获取表L中第i个位置的元素的值。静态分配方式：

  ~~~c++
  #define MaxSize 10
  //定义最大长度
  typedef struct{
      ElemType data [MaxSize];//用静态的“数组”存放数据元素
      int length;				//顺序表的当前长度
  }SqList;					//顺序表的类型定义(静态分配方式)
  ElemType GetElem(SqList L,int i){
     return L.data[i-1]; 
  }
  ~~~

  动态分配方式：

  ~~~c++
  #define InitSize 10			//顺序表的初始长度
  typedef struct{
      ElemType *data;			//指示动态分配数组的指针
      int MaxSize;			//顺序表的最大容量
      int length;				//顺序表的当前长度
  } SeqList;					//顺序表的类型定义(动态分配方式)
  ElemType GetElem(SqList L,int i){
     return L.data[i-1]; 
  }
  ~~~

  由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第$i$个元素。具有"随机存取"特性。

- 按值查找

  注意：不能直接判断两个结构体是否相等。如果要判断我们需要对结构体一个一个比较。

  基本数据类型如：int、 char、 double、float等可以直接用运算符"=="比较。但$C++$可以

  ~~~c++
  #define InitSize 10					//顺序表的初始长度
  typedef struct{
      ElemType *data;					//指示动态分配数组的指针
      int MaxSize;					//顺序表的最大容量
      int length;						//顺序表的当前长度
  } SeqList;							//顺序表的类型定义(动态分配方式)
  //在顺序表L中查找第一一个元素值等于e的元素，并返回其位序
  int LocateElem(SeqList L,ElemType e){
      for(int i=0;i<L. length; i++)
          if(L.data[i]==e)
              return i+1; 			// 数组下标为i的元素值等于e，返回其位序i+1
      return 0;						//退出循环，说明查找失败
  }
  ~~~

  该算法的时间复杂度：

  1. 最好情况：目标元素在表头，循环$1$次；最好时间复杂度$=O(1)$

  2. 最坏情况：目标元素在表尾，循环$n$次，最坏时间复杂度$=O(n)$

  3. 平均情况：假设目标元素出现在任何一个位置的概率相同， 都是$\frac{1}{n}$

     目标元素在第$1$位，循环$1$次；在第$2$位，循环$2$次.....在第$n$位，循环$n$次

     平均循环次数：$=1·\frac{1}{n}+2·\frac{1}{n}+...+n·\frac{1}{n}=\frac{n(n+1)}{2}\frac{1}{n}=\frac{n+1}{n}$

     即时间复杂度为$=O(n)$

[顺序表按位查找和按值查找总结：](https://image.sybblogs.fun/img-common/202304242008573.png)

<img src="https://image.sybblogs.fun/img-common/202304242008573.png" alt="顺序表按位查找和按值查找" style="zoom:43%;" />

## 4. 单链表

链表不同于顺序表的顺序存储方式，用的是链式存储。

单链表的每个结点除了存放数据元素，同时还需要包含指向下一个结点的指针。由于每个结点只包含一个指针所以叫单链表。

单链表优缺点：

- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可随机存取，要耗费一定空间存放指针，无法逆向检索。

单链表定义如下：

~~~c++
struct LNode{
    ElemType data;
    struct LNode *next;
}
~~~

> 上面的"LNode"称之为结点，data称为数据域，*next称为指针域。

带头节点的单链表：

~~~c++
typedef struct LNode{
    int data;				//定义单链表结点类型
    struct LNode *next;		//每个节点存放一个数据元素
}LNode,*LinkList;			//指针指向下一个节点

//初始化一个空的单链表
bool InitList(LinkList &L) {
    L = (LNode *)malloc(sizeof(LNode));	//分配一个头结点
    if (L==NULL)						//内存不足，分配失败
        return false;
    L->next = NULL;						//头结点之后暂时还没有节点
    return true;
}
void test(){
    LinkList L;				//声明一个指向单链表的指针
    //初始化一个空表
    InitList(L);
    //......后续代码......
}
~~~

> 上面前四行代码是将"struct LNode"命名为"LNode"，并且用"LinkList"表示一个指向"struct LNode"的指针。

不带头结点单链表

~~~C++
typedef struct LNode{
    int data;				//定义单链表结点类型
    struct LNode *next;		//每个节点存放一个数据元素
}LNode,*LinkList;			//指针指向下一个节点

//初始化一个空的单链表
bool InitList(LinkList &L) {
    L = NULL; //空表，暂时还没有任何结点
    return true;
}
void test(){
    LinkList L;				//声明一个指向单链表的指针
    //初始化一个空表
    InitList(L);
    //......后续代码......
}
~~~

### 4.1 单链表建立

#### 4.1.1 尾插法

先初始化一个带头结点的单列表，之后每次取个数据元素插入表尾部。是比较常用的方法。

- 先初始化链表：

  ~~~C++
  typedef struct LNode{
      int data;				//定义单链表结点类型
      struct LNode *next;		//每个节点存放一个数据元素
  }lNode,*linkList;			//指针指向下一个节点
  
  //初始化链表 
  bool initList(linkList &l){
  	l=(lNode*)malloc(sizeof(lNode));	//链表开辟一个头节点
  	if(l==NULL)
  		return false;
  	l->next=NULL;						//头结点指针域指向空
  	return true;
  }
  ~~~

- 创建链表：

  ~~~C++
  //尾插法创建链表 
  bool insertTail(linkList &l){
  	lNode *pHead,*pTial;				//指针pHead和pTial分别表示链表头部和尾部
  	pTial=l;							//将尾指针指向l链表
  	int i=0;
  	while(i!=999999){		
  		cin>>i;
  		if(i!=999999){
  			pHead=(lNode*)malloc(sizeof(lNode));	
  			pHead->data=i;				//创建结点pHead其数据与为输入的i值
  			pTial->next=pHead;			//将尾部结点的指针域指向头部结点
  			pTial=pHead;				//接着将尾部结点指向创建的头部结点
  		}
  	}
  	pTial->next=NULL;					//将最后一个指针域设置为空
  	return 1;
  }
  ~~~

- 主函数：

  ~~~C++
  int main(){
  	linkList link;
  	initList(link);					//链表初始化 
  	insertTail(link);				//尾插法创建链表 
  } 
  ~~~

运行结果：

> 输入：1，2，399

[尾插法图像示例：](https://image.sybblogs.fun/img-common/202305171720079.gif)

<img src="https://image.sybblogs.fun/img-common/202305171720079.gif" alt="f47832ac0b274b19b1fb2e5ba8d5fcb9" style="zoom: 25%;" />

#### 4.1.2 头插法建立链表

头插法将每个数据插入在链表头部。头插法可以用于==链表的逆置==。

- 同样先初始化链表：

  ~~~C++
  typedef struct LNode{
      int data;				//定义单链表结点类型
      struct LNode *next;		//每个节点存放一个数据元素
  }lNode,*linkList;			//指针指向下一个节点
  
  //初始化链表 
  bool initList(linkList &l){
  	l=(lNode*)malloc(sizeof(lNode));	//链表开辟一个头节点
  	if(l==NULL)
  		return false;
  	l->next=NULL;						//头结点指针域指向空
  	return true;
  }
  ~~~

- 创建链表：

  ~~~C++
  bool insertHead(linkList &l){
  	int i=0;
  	lNode *p;
  	while(i!=999999){		
  		cin>>i;
  		if(i!=999999){
  			p=(lNode*)malloc(sizeof(lNode));
  			p->data=i;
  			p->next=l->next;
  			l->next=p;
  		}		
  	}
  	return 1;
  }
  ~~~

- 主函数

  ~~~C++
  int main(){
  	linkList link;
  	initList(link);					//链表初始化 
  	insertHead(link);				//尾插法创建链表 
  } 
  ~~~

运行效果和尾插法一样。

[头插法图像示例：](https://image.sybblogs.fun/img-common/202305171718497.gif)

<img src="https://image.sybblogs.fun/img-common/202305171718497.gif" alt="7ae0a7bd64d74b5d9a149f7849e38f93" style="zoom:25%;" />

### 4.2 单链表的插入

核心思路是将插入位置前一个结点的指针域指向新建立的结点，再将新节点的指针与指向后一个结点(前一个结点指针域中的值为后一个结点)。

代码如下：

~~~C++
//按序号插入
bool insertVaule(linkList &l,int local,int e){	//local表示要插入位置，e表示插入的值
	lNode *p,*head=l;							
	int i;
	p=(lNode*)malloc(sizeof(lNode));
	if(p==NULL||local<1) return 0;
	p->data=e;									//建立新节点p
	while(head->next!=NULL&&i<local-1){			//找到要插入位置的上一个结点
		head=head->next;
		i++;
	}
	p->next=head->next;							//将新节点p的指针域指向后一个结点
	head->next=p;								//前一个结点指针域指向新节点p
	return 1;
} 
//前插操作:将s结点插入到p结点之前
bool InsertPriorNode (LNode *p,LNode *s){
    if (p==NULL||S==NULL) return false;
    s->next=p->next;				//s指针与连接到p结点的后继
    p->next=s;						//s连到p之后
    ElemType temp=p->data; 			//交换数据域部分
    p->data=s->data;
    S->data=temp;
    return true;
}
~~~

主函数：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
	insertVaule(link,3,66); 		//按号插入 
	printlist(link);				//链表遍历 	
}  
~~~

[指定结点前插操作：](https://image.sybblogs.fun/img-common/202305181901601.png)

<img src="https://image.sybblogs.fun/img-common/202305181901601.png" alt="指定结点前插操作" style="zoom:43%;" />

> 输入：1，2，3，4，5
>
> 运行结果：1，2，3，66，4，5

### 4.3 单链表的删除

通过按照输入序号删除对应结点，其原理和上面的插入类似。

~~~C++
//按序号删除
bool deletaList(linkList &l,int number){
    int i=0;
    lNode *p=l,*tail;				//tail指针存放的要删除的结点
    if(number<=0){
        return 0;
    }
    while(p!=NULL&&i<number-1){		//找到删除结点的前一个结点
        p=p->next;
        i++;
    }
    tail=p->next;					//将tail指向要删除结点地址
    p->next=tail->next;				//将前一个结点指针域指向被删除结点后一个结点
    free(tail);						//释放要删除结点
    return 1;
} 
//删除指定结点p
bool DeleteNode (LNode *p){
    if (p==NULL) return false;
    LNode *q=p->next;				//令q指向*p的后继结点
    p->data=p->next->data; 			//和后继结点交换数据域
    p->next=q->next;				//将*q结点从链中“断开”
    free(q);						//释放后继结点的存储空间
    return true;
}
~~~

主函数代码：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
	deletaList(link,3);				//按序号删除
	printlist(link);				//链表遍历 	
}  
~~~

关于删除指定节点p，其本质就是将p的后继结点复制给p结点，再释放后继结点，并将p结点重新指向下一个结点。这种方法有个局限性，就是我们在删除最后一个结点时，由于后一个结点为null所以程序会出错，我们就只能使用传统办法循环一个个找了。

> 输入：1，2，3，4，5
>
> 运行结果：1，2，4，5

### 4.4 链表的查找

最常用的查找是按值查找和按序号查找

~~~C++
//按值查找
bool findVaule(linkList &l,int d){	//d代表要查找的值
	lNode *p=l;
	while(p!=NULL){
		if(p->data==d){				//如果找到要查找的值d返回1
			return 1;
		}
		p=p->next;
	}
	return 0;
	
} 

//按号查找
int findNumber(linkList &l,int num){//表示返回第num个结点的值
	int i=0;
	if(num<=0){
		return 0;
	}
	lNode *p=l;
	while(p!=NULL&&i<num){			//找到这个结点，并返回结点值域中的值
		p=p->next;
		i++;
	}
	return p->data;
} 
//对单链表进行打印 
void printlist(linkList &l){
	while(l->next!=NULL){
		cout<<l->next->data<<endl;
		l=l->next;
	}
}
~~~

主函数：

~~~C++
int main(){
	linkList link;
	initList(link);					//链表初始化 
	insertTail(link);				//尾插法创建链表 
    int resultVaule,resultNumber;
	resultVaule=findVaule(link,2);	//按值查找 
	cout<<resultVaule<<endl;
	resultNumber=findNumber(link,3);//按序号查找 
	cout<<resultNumber<<endl;
	printlist(link);				//链表遍历 	
}  
~~~

### 4.5 习题：链表的逆置

逆置方法有很多种：

方法一：可以通过遍历链表元素，用头插法将遍历元素值插入新链表。

~~~C++
#include <bits/stdc++.h>
#include<string>
using namespace std;
typedef struct lNode{
	int data;
	lNode *next;
}lNode,*linkList;

//初始化
bool initLink(linkList &l){
	l=(lNode*)malloc(sizeof(lNode));
	if(l==NULL) return 0;
	l->next=NULL;
	return true;
} 

//尾插法
bool insertTail(linkList &l){
	int i=0;
	lNode *head,*tial=l;
	while(i!=999999){
		cin>>i;
		if(i!=999999){
			head=(lNode*)malloc(sizeof(lNode));
			head->data=i;
			tial->next=head;
			tial=head;
		}
	}
	tial->next=NULL;
	return 1;
}
 
 //头插法实现逆序
lNode* reverseLink(linkList &l){
	lNode *p,*r;
	initLink(r);
	while(l->next!=NULL){				//遍历链表取值
		p=(lNode*)malloc(sizeof(lNode));
		p->data=l->next->data;			//头插法赋值给新链表
		p->next=r->next;
		r->next=p;
		l=l->next;						
	}
	return r;
} 
 
 //打印链表
 void printLink(linkList &l){
 	while(l->next!=NULL){
 		cout<<l->next->data<<endl;
 		l=l->next;
	 }
 } 
 
int main(){
	lNode *link,*result;
	initLink(link);						//初始化链表 
	insertTail(link);					//尾插法创建列表
	result=reverseLink(link);			//用头插法实现逆序
	printLink(result);
}
~~~

> 输入值：1，23，4，5
>
> 运行结果：5，4，23，1

==方法二==：

方法是先让新结点`p=l->next`，

再让头节点指针`l->next=NULL`断开链表。

用结点`lNodeNext=p`来记录结点`p`，`p=p->next`指向下一轮待逆置的结点。

最后让`lNodeNext`用头插法插在`l`链表内即可

<img src="https://image.sybblogs.fun/img-common/202310140009673.png" alt="链表逆置" style="zoom: 25%;" />

<img src="https://image.sybblogs.fun/img-common/202310140010866.png" alt="链表逆置2" style="zoom:25%;" />

~~~C++
//链表的逆置
void changeList(linkList &l){ 
	lNode *lTem=l,*p=l->next,*qNextLNode;
	lTem->next=NULL;
	while(p!=NULL){
		qNextLNode=p;
		p=p->next; 
		qNextLNode->next=lTem->next;
		lTem->next=qNextLNode;
	}

} 

int main(){
	linkList link6;
	initList(link6);
	//链表的逆置
	cout<<"请输入一组链表进行逆置:"<<endl;
	createList(link6);
	cout<<"逆置后的链表为:"<<endl;
	changeList(link6);
	myPrint(link6);
}
~~~

> 输入值：1，23，4，5
>
> 运行结果：5，4，23，1

## 5. 双链表

由于单链表只能指向下一个指针，而双链表同时指向前驱节点和后继结点。

### 5.1 双链表的初始化

~~~C++
typedef struct DNode{						//定义双链表结点类型
    ElemType data;							//数据域
    struct DNode *prior,*next;				//前驱和后继指针
}DNode, *DLinklist;

//初始化双链表
bool InitDLinkList(DLinklist &L){
    L = (DNode *) malloc(sizeof (DNode)); 	//分配一个头结点
    if (L==NULL) return false;				//内存不足， 分配失败
    L->prior = NULL;						//头结点的prior永远指向NULL
    L->next = NULL;							//头结点之后暂时还没有节点
    return true;
}
void testDL inkList() {						//初始化双链表
    DLinklist L;
    InitDLinkList(L);
    //后续代码...
}
~~~

同样的这里的`DNode`和`DLinklist`等价，只是为了区分链表`(DLinklist)`和结点`(DNode)`

### 5.2 双链表的插入

~~~C++
//在p结点之后插入s结点.
bool InsertNextDNode(DNode *p，DNode *s){
    if (p==NULL||s==NULL) return false;		//非法参数
    s->next=p->next;
    if (p->next != NULL) 
        p->next->prior=s; 					//如果p结点有后继结点
    s->prior=p;
    p->next=s;
    return true;
}
~~~

[双链表的插入：](https://image.sybblogs.fun/img-common/202305221637350.png)

<img src="https://image.sybblogs.fun/img-common/202305221637350.png" alt="双链表的插入" style="zoom: 33%;" />

[双链表最后一个节点插入：](https://image.sybblogs.fun/img-common/202305221638889.png)

<img src="https://image.sybblogs.fun/img-common/202305221638889.png" alt="双链表的最后一个节点插入" style="zoom: 33%;" />

### 5.3 双链表的删除

同样和之前但链表删除方法一致。

~~~C++
//删除p结点的后继结点q
bool DeleteNextDNode(DNode *p){
    if ( p==NULL) return false;
    DNode *q = p->next; 			//找到p的后继结点q
    if (q==NULL) return false; 		//p没有后继
    p->next=q->next;
    if (q->next !=NULL)				//q结点不是最后一个结点
        q->next->prior=p;
    free(q);						//释放结点空间
    return true; 
}

//双链表的销毁
void DestoryL ist(DLinklist &L){	//循环释放各个数据结点
    while (L->next != NULL)
        DeleteNextDNode(L);			//删除每个结点的后一个结点
    free(L);						//释放头结点
    L=NULL;							//头指针指向NULL   							
}
~~~

[双链表的总结：](https://image.sybblogs.fun/img-common/202305221701942.png)

<img src="https://image.sybblogs.fun/img-common/202305221701942.png" alt="双链表的总结" style="zoom:25%;" />

## 6. 循环链表

循环链表就是在单链表(双链表)的基础上讲最后一个结点指向头节点。

特点是：从一个结点出发可以找到其他任何一个结点。常用于对表头和表尾操作频率高的情况下。

### 6.1 循环单链表的初始化

[循环单链表结构：](https://image.sybblogs.fun/img-common/202305221703001.png)

<img src="https://image.sybblogs.fun/img-common/202305221703001.png" alt="循环链表" style="zoom:25%;" />

~~~C++
typedef struct LNode{						//定义单链表结点类型
    ElemType data;							//每个节点存放一个数据元素
    struct LNode *next;						//指针指向下一个节点
}LNode, *LinkList;
//初始化一个循环单链表
bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode)); 	//分配一个头结点
    if (L==NULL) return false;				//内存不足,分配失败
    L->next = L;							//头结点next指向头结点本身
    return true; 
}
~~~

其他操作基本与前面一致。注意判断最后一个结点时，应该判断是否指向头节点。

### 6.2 循环双链表的初始化

循环链表：表头结点的prior指向表尾结点；表尾结点的next指向头结点。

循环双链表不需要考虑表头表尾的界限操作。

[循环双链表结构：](https://image.sybblogs.fun/img-common/202305221713236.png)

<img src="https://image.sybblogs.fun/img-common/202305221713236.png" alt="循环双链表" style="zoom:25%;" />

~~~C++
typedef struct DNode{						//定义双链表结点类型
    ElemType data;							//数据域
    struct DNode *prior,*next;				//前驱和后继指针
}DNode, *DLinklist;

//初始化空的循环双链表
bool InitDL inkList(DLinklist &L){
    L = (DNode *) malloc(sizeof(DNode)); 		//分配一个头结点
    if (L==NULL) return false;					//内存不足,分配失败
    L->prior = L;								//头结点的prior指向头结点
    L->next = L;								//头结点的next指向头结点
    return true;
}
~~~

其他操作

~~~C++
//在p结点之后插入s结点
bool InsertNextDNode(DNode *p,DNode *s){
    s->next=p->next; 							//将结点*s插入到结点*p之后
    p->next->prior=s;
    S->prior=p;
    p->next=s;
}

//删除p的后继结点q
p->next=q->next;
q->next>prior=p;
free(q);
~~~

[循环链表总结：](https://image.sybblogs.fun/img-common/202305221739830.png)

<img src="https://image.sybblogs.fun/img-common/202305221739830.png" alt="循环链表总结" style="zoom:25%;" />

## 7. 静态链表

与单链表不同的是静态链表是分配一整片连续的内存空间，各个结点集中安置。

静态链表每个数据元素4B，每个游标4B ( 每个结点共8B)。设起始地址为addr，e1的存放地址为addr + 8*2。2是接下来要寻找的数组下标。

适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景(如操作系统的文件分配表FAT)。

[静态链表结构：](https://image.sybblogs.fun/img-common/202305221746658.png)

<img src="https://image.sybblogs.fun/img-common/202305221746658.png" alt="静态链表" style="zoom:25%;" />

### 7.1 静态链表的初始化

~~~C++
#include<stdio.h>
#define maxsize 30
 
typedef char elemtype;
typedef struct{
	int cur;
	elemtype data;
}slink,slinklist[maxsize];

void initspace_sl(slink *space){//将数据各分量链接成一个备用链表，space[0]代表头指针
	int i;
	for(i=0;i<maxsize-1;i++){
		space[i].cur=i+1;		//下标为i结点的后继为下标是i+1的结点
	}
	space[maxsize-1].cur=0;		//0表示空指针
} 
~~~

[初始化静态链表：](https://image.sybblogs.fun/img-common/202305221803193.png)

<img src="https://image.sybblogs.fun/img-common/202305221803193.png" alt="初始化静态链表" style="zoom: 50%;" />

## 8. 顺序表和链表的比较

两种表的适用场景：

1. 表长难以预估、经常要增加$/$删除元素用链表(订餐系统)。
2. 表长可预估、查询(搜索)操作较多用顺序表(课堂点名)。

逻辑结构：顺序表和链表都属于线性结构。

存储结构：

- 顺序表优点：拥有随机存取的特点，存储密度高。缺点：大片连续空间分配不方便，改变容量不方便。
- 链表优点：离散的小空间分配方便，改变容量方便。缺点：不可随机存储，存储密度低。

基本操作比较：

- 两种表的创建：

  - 顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量;若分配空间过大，则浪费内存资源。

    静态分配：容量不可更改。

    动态分配：容量可以更改，但需要移动大量元素，时间代价高。

  - 链表：只需分配一个头结点(也可以不要头结点，只声明一个头指针)，之后方便拓展

- 两种表的销毁：

  - 链表：依次删除各个结点(free)

  - 顺序表：需要讲$length=0$。静态分配方式，系统会自动回收。动态分配：需要手动销毁(free)。

    注意：malloc和free函数必须成对出现。

- 两种表的增加和删除

  - 顺序表：插入$/$删除元素要将后续元素都后移$/$前移。虽然在时间复杂度上和链表一致，但数据元素大，移动时间成本就高。

  - 链表：插入$/$删除元素只需修改指针即可。查找元素时间低。

- 两种表的查找

  - 顺序表：按位查找时间复杂度为$O(1)$。按值查找时间复杂度$O(n)$，若表内元素有序可以通过算法，可在$O(\log_2n)$时间内找到。
  - 链表：按位查找和按值查找时间复杂度都为$O(1)$

在遇到一个开放式问题探讨时：从逻辑结构，存储结构和基本操作这三方面回答。

# 四. 栈

栈和线性表的结构很相似，但栈只允许在一端进行插入或删除操作的线性表。栈和我们生活种摞起来的盘子类似。

[摞起来的盘子：](https://image.sybblogs.fun/img-common/202305231625768.png)

<img src="https://image.sybblogs.fun/img-common/202305231625768.png" alt="盘子" style="zoom:43%;" />

[栈结构和常见术语：](https://image.sybblogs.fun/img-common/202305231627448.png)

<img src="https://image.sybblogs.fun/img-common/202305231627448.png" alt="栈结构和术语" style="zoom:43%;" />

进栈顺序：$a_1\longrightarrow a_2\longrightarrow a_3\longrightarrow a_4\longrightarrow a_5$

出战顺序：$a_5\longrightarrow a_4\longrightarrow a_3\longrightarrow a_2\longrightarrow a_1$

栈特点：后进(push)先出(pop)(LIFO)

栈的基本操作：创建、销毁、增加、删除、查询、判空。

## 1. 栈的顺序存储实现

### 1.1 栈的定义

和线性表类似，我们先要用结构体初始化栈。

~~~C++
#define MaxSize 10			//定义栈中元素的最大个数
typedef struct{
    ElemType data [MaxSize];//静态数组存放栈中元素
    int top;				//栈顶指针,每次入栈值+1,永远指向栈顶
} SqStack;

//初始化栈
void InitStack(SqStack &S){
    S.top=-1;				//初始化栈顶指针   
}

//判断栈空
bool StackEmpty(SqStack S){
    if(S. top==-1)
        return true;		//栈空
    else      
        return false;	 	//不空
}
~~~

### 1.2 栈的增加

~~~C++
//新元素入栈
bool Push(SqStack &s, ElemType x){
    if(s.top==MaxSize-1)
        return false;		//栈满，报错
    s.top = s.top+1;		//指针先加1       
    s.data[s.top]=x;		//新元素入栈    
    //上面两句等价于：s.data[++s.top]=x;
    return true;
}
~~~

### 1.3 出栈操作

~~~C++
//出栈操作
bool Pop(SqStack &S, ELemType &x){
    if(S.top==-1) 			//栈空,报错       
        return false;
    x=S.data[S.top]; 		//栈顶元素先出栈   
    S.top=S.top-1; 			//指针再减l
    //等价于：x=S.data[s.top--];
    return true;
}
~~~

### 1.4 共享栈

通过上面代码实现我们可以发现栈的一个明显缺点是栈的大小不可变，可以通过链式栈或者分配大空间来解决这个问题。但分配大片空间会导致空间冗余，这时候可以用共享栈解决。

共享栈就是两个栈共享一片空间。

共享栈实现：

~~~C++
#define MaxSize 10
//定义栈中元素的最大个数
typedef struct{
    ElemType_ data [MaxSize];	//静态数组存放栈中元素
    int top0;					//0号栈栈顶指针	
    int top1;					//1号栈栈顶指针
} ShStack;

//初始化栈
void InitStack(ShStack &S){
    S.top0=-1;					//初始化栈顶指针    
    S.top1=MaxSize;
}
~~~

[共享栈结构：](https://image.sybblogs.fun/img-common/202305231703776.png)

<img src="https://image.sybblogs.fun/img-common/202305231703776.png" alt="共享栈" style="zoom:43%;" />

共享栈两个top指针一个从下网上存储，一个从上往下存储。判断栈满的条件是：`top0 + 1 == top1`

## 2. 链栈

定义：用链式存储结构实现的栈

实现：实际上我们用头插法建立的单链表就是一个链栈。

### 2.1 链栈初始化

~~~C++
typedef struct Linknode{
    ElemType data;				//数据域
    struct L inknode *next;		//指针域
} *LiStack;						//栈类型定义

//初始化 
bool initStack(LiStack &l){
	l=(LiStack)malloc(sizeof(LiStack));//带头节点
	if(l==NULL) return false;
	l->next=NULL;
	return true;
}
~~~

### 2.2 链栈的入栈

用头插法入栈

~~~C++
bool pushStack(LiStack &l,int e){
    if(l==NULL) return false;
    LiStack p;
    p=(LiStack)malloc(sizeof(LiStack));
    p->data=i;							//头插法
    p->next=l->next;
    l->next=p;
    return true;
}  
~~~

### 2.3 链栈的出栈

链栈的出栈操作，栈顶指针是第一个指针（头指针的下一个），所以将其往后挪一位就好了。

~~~C++
//出栈
bool Pop(LiStack &l){
    LiStack p;
    if(l->next==NULL){
        return false;
    }else{
        p=l->next;			//p指向第一个结点(头结点后继结点)
		l->next=p->next;	//往后挪一位
        free(p);
        return true;
    }
}
~~~

### 2.4 链栈打印

最后其它操作和单链表一致。

~~~C++
void printStack(LiStack &l){
	while(l->next!=NULL){
		cout<<l->next->data<<endl;
		l=l->next;
	}
} 
~~~

## 3. 栈的应用—括号匹配

括号匹配就是相邻括号成对出现。如：$[],\{\},()$.

具体思路是用栈实现括号匹配：

1. 依次扫描所有字符，遇到左括号入栈，遇到右括号存入数组(也可以不用数组，当输入右括号直接和栈中括号匹配)
2. 查看是否匹配。匹配失败情况:
   ①左括号单身②右括号单身③左右括号不匹配

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 20
using namespace std;

static int couts=0;				//全局静态变量，用于记录数组中的右括号数 
typedef struct Linknode{
    char data;				
    struct Linknode *next;		
} *LiStack;						

//初始化
bool initLiStack(LiStack &l){
	l=(LiStack)malloc(sizeof(LiStack));
	if(l==NULL) return false;
	l->next=NULL;
	return true;
} 

//入栈
bool pushStack(LiStack &l,char s){
	LiStack p;
	p=(LiStack)malloc(sizeof(LiStack));
	if(p==NULL) return false;
	p->data=s;
	p->next=l->next;
	l->next=p;
	return true;
}

//出栈 
char popStack(LiStack &l){					
	LiStack p;
	char s;
	if(l->next==NULL) {
		cout<<"栈空"<<endl;
		return 'E';	
	}
	s=l->next->data;
	p=l->next;
	l->next=p->next;
	free(p);
	return s;	
}

//区分左右括号
void bracketLeftRight(LiStack &l,char *p,char str){	//p表述指针数组，str用户输入值 
 	if(str=='('||str=='{'||str=='['){				//如果是左括号，放入栈中 
 		pushStack(l,str);
	 }else if(str==')'||str=='}'||str==']'){		//如果是右括号，放入数组中，全局变量couts+1 
	 	p[couts]=str;
	 	couts+=1;
	 }else{
	 	cout<<"输入值不合法"<<endl;
	 } 
 }
 
 //判断括号是否对应
 bool  bracketCheck(LiStack &l,char *p){
 	char bracket;
 	for(int j=0;j<couts;j++){
 		bracket=popStack(l);
 		if(bracket=='E') return false; 				//栈空，配对失败 
 		if(p[j]==')'&&bracket!='(') return false; 	//三种括号匹配 
 		if(p[j]==']'&&bracket!='[') return false;
 		if(p[j]=='}'&&bracket!='{') return false;
	 }
 }

int main(){
	LiStack l;	
	char str,c[MaxSize]={0},*p=c;					//str:接受输入值，c[]存放右括号,p数组指针传递 
	initLiStack(l);									//初始化 
	while(str!='!'){								//输入'!'结束输入 
		cin>>str;
		if(str!='!'){
			bracketLeftRight(l,p,str);				//每输入一个值判断左右括号 
		}
	}
	if(bracketCheck(l,p)>0){
		cout<<"括号全部匹配"<<endl; 					//括号全部匹配 
	}else{
		cout<<"括号不匹配"<<endl; 					//括号不匹配 
	} 
} 
~~~

[括号匹配思路：](https://image.sybblogs.fun/img-common/202305262025840.png)

<img src="https://image.sybblogs.fun/img-common/202305262025840.png" alt="栈练习--括号匹配" style="zoom:25%;" />

## 4. ==栈的应用—表达式求值==

表达式通常由三部分组成：①操作数②运算符③界限符(括号等)

常见表达式有以下几种：

1. 中缀表达式：$a+b$、$a\backslash b$、$a+b-c$、$a+b-c*d$

   特点：运算符在两个数中间

2. 后缀表达式(逆波兰表达式)：$ab+$、$ab\backslash$、$ab+c-$、$ab+cd*-$

   特点：运算符在两个操作数后面

3. 前缀表达式(波兰表达式)：$+ab$、$\backslash ab$、$-+abc$、$-+ab*cd$

   特点：运算符在操作数前面

### 4.1 中缀表达式转后缀方法

遵循==左优先==原则。

①确定运算顺序

②选择下一个运算符，按照$[左操作数$ $右操作数$ $运算符]$的方式组合成一个新的操作数

③如果还有运算符没被处理，继续②

如$中缀表达式((15÷(7-(1+1)))\times3)-(2+(1+1))$转换为后缀步骤：

1. $1$ $1$ $+$
2. $7$ $1$ $1$ $+$ $-$
3. $15$ $7$ $1$ $1$ $+$ $-$ $÷$
4. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$
5. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $1$ $1$ $+$
6. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $2$ $1$ $1$ $+$ $+$
7. $15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $2$ $1$ $1$ $+$ $+$ $-$

### 4.2 后缀表达式计算

通过上面我们将中缀表达式转为后缀表达式$15$ $7$ $1$ $1$ $+$ $-$ $÷$ $3$ $\times$ $2$ $1$ $1$ $+$ $+$ $-$

计算后缀表达式也不难：从**左往右扫描**，每遇到**一个运算符**，就让运算符前面最近的两个操作数执行对应运算
合体为一个操作数。注意：两个操作数的左右顺序。

步骤：

1. 第一个运算符是$+$，先算$1+1$
2. 第二个运算符是$-$，$7-2$
3. 第三个运算符是$÷$，$15÷5$
4. 第四个运算符是$\times$，$3\times3=9$
5. 第五个运算符是$+$，$1+1$
6. 第六个运算符是$+$，$2+2=4$
7. 最后一个运算符是$-$，$9-4$得最后结果

[后缀表达式计算图示：](https://image.sybblogs.fun/img-common/202306151824409.png)

<img src="https://image.sybblogs.fun/img-common/202306151824409.png" alt="后缀表达式计算" style="zoom:25%;" />

### 4.3 代码实现

代码实现需要遵循以下几点：

①遇到操作数直接入栈

②遇到界限符'$($'，直接入栈，遇到'$)$'，依次弹出栈内的运算符，直到栈顶元素为'$($'。

③运算符运算弹出规则，应该是：==操作符栈顶运算符大于或等于当前输入运算符==则弹出栈顶操作符。数字栈依次弹出两个数字$num1,num2$，运算是$num2+-...num1$

$\Large 例:计算中缀表达式((15÷(7-(1+1)))\times3)-(2+(1+1))$

Ⅰ.先分析运算符生效顺序，如下图:

<img src="https://image.sybblogs.fun/img-common/202306081849449.png" alt="运算符生效顺序" style="zoom:25%;" />

Ⅱ. 从左到右依次扫描入栈:操作符栈(charStack),操作数栈(numStack)

Ⅲ. 定义操作符优先级：$+/-$为$A$，$\times/÷$为$B$，$($为$C$.

Ⅳ. 进行扫描运算：

> ①输入'$($'，由于操作符栈为$NULL$，直接入栈。
>
> ②输入'$($'，操作符栈不为$NULL$，且优先级等于操作栈顶的元素'('，但由于括号不参与运算，所以直接入栈。
>
> ③输入$15$，数字直接入栈。
>
> ④输入'$÷$'，由于'÷'优先级低于操作符栈顶元素'('，直接入栈。
>
> ⑤输入'$($'，括号直接入栈。
>
> ⑥输入$7$，数字直接入栈。
>
> ⑦输入'$-$'，'$-$'优先级低于操作符栈顶元素'$($'，入栈。
>
> ⑧输入'$($'，直接入栈
>
> ⑨输入$1$，入栈
>
> ⑩输入'$+$'，'$+$'优先级低于操作符栈顶元素'$($'，入栈
>
> ⑪输入$1$，入栈。此时栈中元素情况如下：

[操作符栈和操作数栈：](https://image.sybblogs.fun/img-common/202306131739136.png)

<img src="https://image.sybblogs.fun/img-common/202306131739136.png" alt="运算栈" style="zoom:25%;" />

> ⑫输入'$)$'，栈顶操作符一次出栈直到为NULL或者为'$($'。此时弹出操作符栈顶元素'$+$'，弹出操作数栈前两个元素$1,1$。之后运算$1+1$得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131741661.png" alt="运算栈2" style="zoom:25%;" />

> ⑬输入')'，再次重复上面，弹出操作符栈顶元素'$-$'，弹出操作数栈两个元素$2,7$，运算$7-2$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131742019.png" alt="运算栈3" style="zoom:25%;" />

> ⑭输入'$)$'，重复上面过程，弹出操作符栈顶元素'$÷$'，弹出操作数栈两个元素$5,15$，运算$15÷5$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131743466.png" alt="运算栈4" style="zoom:25%;" />

> ⑮输入'$\times$'，此时操作符栈顶元素为'$($'，优先级低于栈顶元素，直接入栈。
>
> ⑯输入'$3$'，直接入栈

<img src="https://image.sybblogs.fun/img-common/202306131744115.png" alt="运算栈5" style="zoom:25%;" />

> ⑰输入'$)$'，弹出操作符栈顶元素'$\times$'，弹出操作数栈两个元素$3,3$，运算$3\times3$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131745892.png" alt="运算栈6" style="zoom:25%;" />

> ⑱输入'$-$'，此时操作栈为NULL，直接入栈
>
> ⑲输入'$($'，入栈
>
> ⑳输入$2$，入栈
>
> ㉑输入'$+$'，优先级小于操作栈顶元素'$($'，入栈
>
> ㉒输入'$($'，直接入栈
>
> ㉓输入$1$，入栈
>
> ㉔输入'$+$'，优先级低于操作栈栈顶元素'$($'，入栈
>
> ㉕输入$1$，入栈

<img src="https://image.sybblogs.fun/img-common/202306131747104.png" alt="运算栈7" style="zoom:25%;" />

> ㉖输入'$)$'，弹出操作符栈顶元素'$+$'，弹出操作数栈两个元素$1,1$，运算$1+1$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131748232.png" alt="运算栈8" style="zoom:25%;" />

> ㉗输入'$)$'，弹出操作符栈顶元素'$+$'，弹出操作数栈两个元素$2,2$，运算$2+2$。得到新的数字重新放回操作栈顶部，再次执行弹出元素为'$($'，这次运算结束。

<img src="https://image.sybblogs.fun/img-common/202306131749733.png" alt="运算栈9" style="zoom:25%;" />

> ㉘弹出操作栈顶元素'$-$'，弹出操作数栈两个元素进行最后运算，得到结果为$5$

详细代码

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 20
using namespace std;

char arrGrad(char s){
	switch(s){
		case '+':
			return 'A';
		case '-':
			return 'A';
		case '*':
			return 'B';
		case '/':
			return 'B';
		default :
			return 'C'; 
	}
}

//存放运算符 
typedef struct linkC{
    char data;
	char grad;				
    struct linkC *next;		
} *linkChar;

//存放运算数 
typedef struct linkN{
    int data;				
    struct linkN *next;		
} *linkNum;	 

bool initCharNum(linkChar &c,linkNum &n,char (&s)[MaxSize]){
	memset(s,'\0',sizeof(s));
	c=(linkChar)malloc(sizeof(linkChar));
	n=(linkNum)malloc(sizeof(linkNum));
	if(c==NULL||n==NULL) return false;
	c->next=NULL;
	n->next=NULL;
	return true;
}

//操作符入栈 
bool pushChar(linkChar &c,char s){
	linkChar p;
	p=(linkChar)malloc(sizeof(linkChar));
	if(p==NULL) return false;
	if(s=='+'|s=='-'){
		p->data=s;
		p->grad=arrGrad(s);
		p->next=c->next;
		c->next=p;
		return true;
	}else if(s=='*'|s=='/'){
		p->data=s;
		p->grad=arrGrad(s);
		p->next=c->next;
		c->next=p;
		return true;
	}else if(s=='('){
		p->data=s;
		p->grad=arrGrad(s);
		p->next=c->next;
		c->next=p;
		return true;
	}else{
		return false;
	}	
}

//操作数入栈 
bool pushNum(linkNum &n,int e){
	linkNum p;
	p=(linkNum)malloc(sizeof(linkNum));
	if(p==NULL) return false;
	p->data=e;
	p->next=n->next;
	n->next=p;
	
	return true;
}

//操作符出栈
char popChar(linkChar &c){
	char s;
	linkChar p;
	if(c->next==NULL) return 'E';
	s=c->next->data;
	p=c->next;
	c->next=p->next;
	free(p);
	return s;
}

//操作数出栈
int popNum(linkNum &n){
	int i;
	linkNum p;
	if(n->next==NULL) return 0;
	i=n->next->data;
	p=n->next;
	n->next=p->next;
	free(p);
	return i;
}

//获取操作符栈顶元素
char selectChar(linkChar &c,int e){
	if(e) return c->next->data;
	return c->next->grad;
}

//运算
void ope(linkChar &c,linkNum &n){
	char popchar=popChar(c);
	int num1=popNum(n);
	int num2=popNum(n);
	cout<<num2<<popchar<<num1<<endl;
	switch(popchar){
		case '+':
			pushNum(n,num2+num1);
			break;
		case '-':
			pushNum(n,num2-num1);
			break;
		case '*':
			pushNum(n,num2*num1);
			break;
		case '/':
			pushNum(n,num2/num1);
			break;
	}
} 

void printStack(linkChar &c,linkNum &n){
	while(c->next!=NULL){
		cout<<"data:"<<c->next->data<<"grad::"<<c->next->grad<<endl;
		c=c->next;
	}
	while(n->next!=NULL){
		cout<<"result:"<<n->next->data<<endl;
		n=n->next;
	}
}

//字符转数字 
int opeNum(char (&s)[MaxSize]){
	int couts,sum=0;
	for(int i=0;i<strlen(s);i++){
		couts=s[i]-'0';
		for(int j=i;j<strlen(s)-1;j++){
			couts=couts*10;
		}
		sum+=couts;
	}
	memset(s,'\0',sizeof(s));
	return sum;
}
int con=0;

//区分操作数和操作符
bool isCharNum(linkChar &c,linkNum &n,char s,char (&chrs)[MaxSize]){
	int i;
	if(s>='0'&&s<='9'){													//数字直接存入操作数栈 
		chrs[con++]=s;
		return true;
	}else if(s=='+'||s=='-'||s=='*'||s=='/'||s=='('||s=='!'){			//判断是否是操作符 
		if(strlen(chrs)>0) {
			i=opeNum(chrs);
			pushNum(n,i);
			con=0;
		}
		if(c->next==NULL){												//操作符栈为空，直接入栈 
			pushChar(c,s);
			return true;
		}
		if(selectChar(c,0)>=arrGrad(s)&&selectChar(c,1)!='('){			//不为空且栈顶操作符优先级大于等于当前所输入操作符元素,并且不是"("
			while(c->next!=NULL&&c->next->grad>=arrGrad(s)&&c->next->data!='('){			//取出操作符进行运算操作 
				ope(c,n);
			} 
		} 
		pushChar(c,s);													//将当前输入操作符压入栈顶 
		return true;
	}else if(s==')'){	
		if(strlen(chrs)>0||s=='!') {
			i=opeNum(chrs);
			pushNum(n,i);
			con=0;
		}															//如果当前输入是")",弹出所有操作符进行运算,直到碰到"(" 
		while(selectChar(c,1)!='('){
			ope(c,n);
		}
		popChar(c);														//弹出栈顶的"(" 
		return true;
	}else{
		return false;
	}
} 

int main(){
	char chr,chrs[MaxSize];
	linkChar c;
	linkNum n;
	initCharNum(c,n,chrs);
	while(chr!='!'){
		cin>>chr;
		isCharNum(c,n,chr,chrs);
	}
	ope(c,n);
	printStack(c,n);
} 
~~~

## 5. 栈在递归中的应用

先给出一段代码，看一下函数调用背后过程

~~~C++
void main(){
    int a,b,c;
    func1(a,b);
    c=a+b;
    ...
}
void func1(int a,int b){
    int x;
    func2(x);
    x=x+10086;
    ...
}
void func2(int x){
    int m,n;
    ...
}
~~~

主函数用执行第一句代码后会在栈中存放$a,b,c$的地址

[栈递归中应用：](https://image.sybblogs.fun/img-common/202306172002005.png)

<img src="https://image.sybblogs.fun/img-common/202306172002005.png" alt="栈递归中应用" style="zoom: 50%;" />

接着执行func1函数所对应代码，当执行func1时，会将后面应该执行代码，这里是表达式`c=a+b`地址同样压入栈中，图示如下(表达式地址用$\#1$代替)

<img src="https://image.sybblogs.fun/img-common/202306172005240.png" alt="栈递归中应用2" style="zoom: 50%;" />

同样func2执行过程同上一步，表达式`x=x+10086`地址假设为$\#2$

<img src="https://image.sybblogs.fun/img-common/202306172009314.png" alt="栈递归中应用3" style="zoom:45%;" />

执行完func2函数后，之后弹栈，根据栈顶地址，执行$\#2$对应代码(func1)。接着再弹栈执行$\#1$对应代码，即主函数中`c=a+b`。

以上就是递归基本原理。适合用递归算法解决是：可以把原始问题转换为属性相同，但规模较小的问题。

实现递归两个重要条件：递归表达式，递归边界条件。

[阶乘问题：]()

<img src="https://image.sybblogs.fun/img-common/202306172022900.png" alt="阶乘问题" style="zoom:25%;" />

上面代码当执行到第10层时，$n=1$返回$1$，弹栈；执行第9层代码此时$n=1$，表达式就是`2*1`；之后以此类推。

上面也可以看出递归缺点就是非常占用栈空间，所以太多层递归可能会导致栈溢出。

# 五. 队列

队列是只允许在队尾一端插入(入队)，在队头一端删除(出队)的数据结构。

特点：先进入先出(FIFO)。

栈的基本操作：创建、销毁、增加、删除、查询、判空。

## 1. 队列的顺序实现

### 1.1 队列初始化

~~~C++
typedef struct Linknode{
    int data[MaxSize];			//数据域
    int front,rear;				//队头指针和队尾指针 
    int size;					//记录队列大小
} sqQueue;						//队列 

//初始化
bool initQueue(sqQueue &s){
	s.front=0;
	s.rear=0;
	s.size=0;
} 
~~~

### 1.2 入列

~~~C++
//入列 
bool insertQueue(sqQueue &s,int e){
	if(s.size==MaxSize-1) return false;	//判断队列是否已满
	s.data[s.rear]=e;					//值赋给尾指针所指向的位置
	s.rear=(s.rear+1)%MaxSize;			//尾指针+1取余变为循环队列
	s.size+=1;							//队列元素个数+1
	return true;
} 
~~~

上面第五行取余操作，可以将对列变为循环队列。

[循环队列结构图：](https://image.sybblogs.fun/img-common/202305251735432.png)

<img src="https://image.sybblogs.fun/img-common/202305251735432.png" alt="循环队列" style="zoom:25%;" />

### 1.3 出列

~~~C++
//出列 
bool popQueue(sqQueue &s,int &e){
	if(s.size==0) return false;		//判断队列是否为空
	e=s.data[s.front];				//将头指针指向值赋值给e
	s.front=(s.front+1)%MaxSize;	//头指针往后移一位，取余变为循环队列
	s.size-=1;						//队列元素个数-1
	return true;
} 
~~~

和上面入列一样，这一队列变为循环队列，存储数据和读取数据更为方便。

### 1.4 队列元素个数

~~~C++
//元素个数
void printQueue(sqQueue s){
    cout<<(s.rear-s.front+MaxSize)%MaxSize<<endl;
} 
~~~

执行上面代码会实现当前队列中的元素个数。同时队列`s.size`中保存的也是元素个数。即
`(s.rear-s.front+MaxSize)%MaxSize<<endl~s.size`

### 1.5 其他情况

上面的都是队头队尾指针初始化时，指向同一位置，但有时候会碰见队尾指针在队尾情况

[队尾指针在队尾情况：](https://image.sybblogs.fun/img-common/202305251750011.png)

<img src="https://image.sybblogs.fun/img-common/202305251750011.png" alt="队尾指针在队尾" style="zoom: 50%;" />

此时入队操作有所改变，我们要先让尾指针向后移一位，再进行插入。

~~~C++
//入列 
bool insertQueue(sqQueue &s,int e){
    s.rear=(s.rear+1)%MaxSize;			//尾指针+1取余变为循环队列
	s.data[s.rear]=e;					//值赋给尾指针所指向的位置	
	return true;
} 
~~~

而初始化方式也有所不同，让尾指针指向队尾元素，当第一次入队时通过取余操作，往后移动到第一位。

~~~C++
//初始化
bool initQueue(sqQueue &s){
	s.front=0;
	s.rear=MaxSize-1;				//尾指针指向尾部
} 
~~~

判空操作和判满操作也不同：

~~~C++
//判空
(s.rear+1)%MaxSize==s.front;
~~~

判满操作同上，除了`size`判满操作，我们也可以通过设置辅助遍历`tag`来记录上次是入队操作，还是出队操作。由于只有入队操作会让队满，而只有出队操作会让队空，所以当入队时设置`tag=1`，当出队时设置`tag=0`。

~~~C++
//通过tag方式判断队列已满
if((s.rear+1)%MaxSize==s.front&&s.tag==1)
~~~

## 2. 链式队列

### 2.1 链式队列的初始化

~~~C++
typedef struct Linknode{		//结点	
    int data;					
    struct Linknode *next;		
}linknode;						

typedef struct linkQueue{		//链式队列			
	linknode* front;			//头指针 
	linknode* rear;				//尾指针	 
}linkQueue;

//初始化
bool initQueue(linkQueue &q){
	//带头节点方式： 
	q.rear=(linknode* )malloc(sizeof(linknode));
	q.front=q.rear;
	q.front->next=NULL;
	//不带头结点方式:
	//q.front=NULL;
	//q.rear=NULL; 
} 
~~~

初始化创造两个结构体，第一个是结点，第二个存储链队列地址。

[带头结点初始化：](https://image.sybblogs.fun/img-common/202305251939775.png)

<img src="https://image.sybblogs.fun/img-common/202305251939775.png" alt="带头结点初始化方式" style="zoom: 50%;" />

[不带头结点初始化：](https://image.sybblogs.fun/img-common/202305251940579.png)

<img src="https://image.sybblogs.fun/img-common/202305251940579.png" alt="不带头结点初始化方式" style="zoom:25%;" />

### 2.2 链式队列的入队

~~~C++
//入队操作
bool insertQueue(linkQueue &q,int e){
	linknode *s=(linknode *)malloc(sizeof(linknode));
	s->data=e;
	s->next=NULL;
	//带头结点方式：
	//q.rear->next=s;				//新结点插入到rear之后
	//q.rear=s;						//修改表尾指针
	//不带头结点方式：
	if(q.front==NULL){				//条件成立，证明队列为NULL 
		q.front=s;					//头指着指向s 
		q.rear=s;					//尾指针指向s 
	} else{
		q.rear->next=s;				//否则不为空，尾指针域指向s 
		q.rear=s;					//尾指针指向s 
	}
} 
~~~

[带头结点入队：](https://image.sybblogs.fun/img-common/202305251941418.png)

<img src="https://image.sybblogs.fun/img-common/202305251941418.png" alt="带头结点入队" style="zoom:25%;" />

[不带头结点入队：](https://image.sybblogs.fun/img-common/202305251946648.png)

<img src="https://image.sybblogs.fun/img-common/202305251946648.png" alt="不带头结点入队" style="zoom:25%;" />

### 2.3 链式队列出队操作

- 带头结点出队

  ~~~C++
  //出队操作(带头结点)
  bool DeQueue(linkQueue &q, int &e){
  	if(q.front==q.rear) return false;	//空队
  	linknode *p=q.front->next;
  	e=p->data;							//用变量e返回队头元素
  	q.front->next=p->next; 				//修改头结点的 next 指针
  	if(q.rear==p)						//此次是最后一个结点出队
  		q.rear=q.front;					//修改rear 指针
  	free(p);							//释放结点空间
  	return true;
  }
  ~~~

  [带头结点出队操作：](https://image.sybblogs.fun/img-common/202305252000397.png)

  <img src="https://image.sybblogs.fun/img-common/202305252000397.png" alt="带头结点出队" style="zoom:25%;" />

  [带头最后一个结点出队：](https://image.sybblogs.fun/img-common/202305252001310.png)

  <img src="https://image.sybblogs.fun/img-common/202305252001310.png" alt="带头最后一个结点出队" style="zoom:25%;" />

  最后一个结点出队，实际上就是将队列再次变为空队列

- 不带头结点出队

  ~~~C++
  //不带头结点出队
  bool DeQueue(linkQueue &q, int &e){
      if(q.front==NULL ) return false;		//空队
      linknode *p=q.front;					//p指向此次出队的结点
      e=p->data;								//用变量x返回队头元素
      q.front=p->next;						//修改front 指针
      if(q.rear==p){							//此次是最后一个结点出队
          q.front = NULL;						//front指向NULL
          q.rear = NULL;						//rear指向NULL
      }
      free(p);								//释放结点空间
      return true;
  }
  ~~~

  [不头结点出队：](https://image.sybblogs.fun/img-common/202305252005348.png)

  <img src="https://image.sybblogs.fun/img-common/202305252005348.png" alt="不头结点出队" style="zoom:25%;" />

## 3. 双端队列

[双端队列定义：](https://image.sybblogs.fun/img-common/202305261553330.png)

<img src="https://image.sybblogs.fun/img-common/202305261553330.png" alt="双端队列定义" style="zoom: 33%;" />

具体又可以细分为：输入受限的双端队列、输出受限的双端队列

[输入受限的双端队列和输出受限的双端队列：](https://image.sybblogs.fun/img-common/202305261555897.png)

<img src="https://image.sybblogs.fun/img-common/202305261555897.png" alt="输出或输出受限的双端队列" style="zoom:25%;" />

考点：和栈一样会考某组数据出栈顺序是否合法。可以用卡特兰数计算出一组数据有多少种合法出战组合。
$$
\begin{equation*}
	\begin{aligned}
&卡特兰数:\frac{1}{n+1}C^{n}_{2n}\\
\\
&如:输入数列为:1,2,3,4\\
\\
&合法输出组合为:\frac{1}{4+1}C^4_8=14
	\end{aligned}
\end{equation*}
$$

## 4. 队列的应用——树的遍历

队列有一个重要应用：树的层次遍历。

[树的遍历：](https://image.sybblogs.fun/img-common/202306191704305.png)

<img src="https://image.sybblogs.fun/img-common/202306191704305.png" alt="树的遍历" style="zoom: 50%;" />

遍历步骤：

1. 遍历$1$号节点，将一号两个子节点放入队列队尾：$1\rightarrow2\rightarrow3$
2. 遍历完$1$号节点后出队，遍历$2$号节点两个子节点放入队尾：$2\rightarrow3\rightarrow4\rightarrow5$
3. 遍历$2$号后出队，遍历$3$号节点两个子节点放入队尾：$3\rightarrow4\rightarrow5\rightarrow6\rightarrow7$
4. 之后遍历$4$节点，$4$节点没有子节点，遍历完后直接弹出：$5\rightarrow6\rightarrow7$
5. 遍历$5$节点，子节点入队：$5\rightarrow6\rightarrow7\rightarrow8\rightarrow9$
6. 遍历$5$节点后，$6$节点没有子节点，遍历完后直接弹出：$7\rightarrow8\rightarrow9$
7. 遍历$7$节点，将子节点放入队列：$7\rightarrow8\rightarrow9\rightarrow19\rightarrow11$
8. 依次遍历弹出即可

## 5. 特殊矩阵的压缩存储

### 5.1 一维数组

数组`a[10]`在内存中存储如下：

[数据存储：](https://image.sybblogs.fun/img-common/202306191718919.png)

<img src="https://image.sybblogs.fun/img-common/202306191718919.png" alt="数据存储" style="zoom:25%;" />

各个元素大小相同，且物理上连续存放。所以我们可以根据数组起始地址得到任何一个数组内存地址。

计算方法：==$a[i]$存放地址$=起始地址+i*sizeof(ElemType)$==。数组下标$i$默认从$0$开始，如果从$1$开始，计算公式要改为`i-1`。

### 5.2 二维数组

数组`b[2][4]`内存存储如下：

[二维数组存储：](https://image.sybblogs.fun/img-common/202306191725303.png)

<img src="https://image.sybblogs.fun/img-common/202306191725303.png" alt="二维数组存储" style="zoom: 50%;" />

存储方式有两种：行优先(一行一行存)，列优先(一列一列存)。

计算方法：$M$行$N$列二维数组`b[m][n]`，按照==行优先==存储，则==$b[i][j]$的存储地址$=起始地址+(i*N+j)*sizeof(ElemType)$==

$M$行$N$列二维数组`b[m][n]`，按照==列优先==存储，则==$b[i][j]$的存储地址$=起始地址+(j*M+i)*sizeof(ElemType)$==

### 5.3 对称矩阵压缩存储

若$n$阶方阵中任意一个元素$a_{i,j}$都有$a_{i,j}=a_{j,i}$，则该矩阵为对称矩阵。

[对称矩阵：](https://image.sybblogs.fun/img-common/202306191742520.png)

<img src="https://image.sybblogs.fun/img-common/202306191742520.png" alt="对称矩阵" style="zoom:25%;" />

其特点就是关于主对角线下标$i=j$对称

[对称矩阵特点：](https://image.sybblogs.fun/img-common/202306191745807.png)

<img src="https://image.sybblogs.fun/img-common/202306191745807.png" alt="对称矩阵特点" style="zoom: 50%;" />

存储数组：数组从$0$开始，大小为：$\frac{(1+n)·n}{2}-1$的一维数组存储

存储方式：只存储主对角线$+上/$下三角区域

- 策略一：按照行优先原则，将各个元素存入一维数组中。

  [对称矩阵一维存储：](https://image.sybblogs.fun/img-common/202306191754712.png)

  <img src="https://image.sybblogs.fun/img-common/202306191754712.png" alt="对称矩阵一维存储" style="zoom: 50%;" />

  数组下标获取：$a_{i,j}$是数组$a[k]$第$\frac{i(i-1)}{2}+j$个元素，所以下标$k=\frac{i(i-1)}{2}+j-1$

- 策略二：按照列优先原则，将各个元素存入一维数组中。

  [对称矩阵列存储：](https://image.sybblogs.fun/img-common/202306191832897.png)

  <img src="https://image.sybblogs.fun/img-common/202306191832897.png" alt="对称矩阵列存储" style="zoom:25%;" />

  数组下标获取：$a_{i,j}$是数组$a[k]$下标$k=[n+(n-1)+(n-2)+...+(n-j-2)]+(i-j)$

### 5.4 三角矩阵

下三角矩阵：除了主对角线和下三角区，其余的元素都相同

上三角矩阵：除了主对角线和上三角区，其余的元素都相同

[下三角矩阵：](https://image.sybblogs.fun/img-common/202306191838365.png)

<img src="https://image.sybblogs.fun/img-common/202306191838365.png" alt="下三角矩阵" style="zoom:25%;" />

[上三角矩阵：](https://image.sybblogs.fun/img-common/202306191839702.png)

<img src="https://image.sybblogs.fun/img-common/202306191839702.png" alt="上三角矩阵" style="zoom:25%;" />

存储策略：按行优先原则将橙色区元素存入一维数组，并在最后一个位置存储常数$c$.

[三角矩阵行优先存储：](https://image.sybblogs.fun/img-common/202306191841065.png)

<img src="https://image.sybblogs.fun/img-common/202306191841065.png" alt="三角矩阵行优先存储" style="zoom:25%;" />

求$a_{i,j}$元素在数组中下标$k$：
$$
\begin{equation*}
	\begin{aligned}
k=\left\{ 
\begin{matrix}
\frac{i(i-1)}{2}+j-1,i\ge j(下三角区和主对角线元素)\\
\frac{n(n+1)}{2},i<j(上三角区元素)
\end{matrix}
\right.
\quad
	\end{aligned}
\end{equation*}
$$

### 5.5 三对角矩阵的压缩存储

又称为带状矩阵，当满足$|i-j|>1时,$有$a_{i,j}=0(1\le i,j\le n)$

[三对角矩阵：](https://image.sybblogs.fun/img-common/202306191903248.png)

<img src="https://image.sybblogs.fun/img-common/202306191903248.png" alt="三对角矩阵" style="zoom:25%;" />

压缩策略：按行优先原则(列优先)，只存储带状部分(非$0$部分)

[三对角矩阵压缩存储：](https://image.sybblogs.fun/img-common/202306191905297.png)

<img src="https://image.sybblogs.fun/img-common/202306191905297.png" alt="三对角矩阵压缩存储" style="zoom: 50%;" />

$a_{i,j}(|i-j|\le1)$元素在数组中是第几个：

前$i-1$行共$3(i-1)-1$个元素，$a_{i,j}$是$i$行第$j-i+2$个元素，$a_{i,j}$是第==$2i+j-2$==个元素。

若已知数组下标$k$，如何得到$i,j$：

①前$i-1$行共$3(i-1)-1$个元素

②前$i$行共$3i-1$个元素

③显然$3(i-1)-1<k+1\le3i-1$，即$i\ge\frac{(k+2)}{3}$。$i$向上取整即可满足这个不等式：$i=[\frac{k+2}{3}]$

### 5.6 稀疏矩阵压缩存储

稀疏矩阵：非零元素远远少于矩阵元素个数。

[稀疏矩阵：](https://image.sybblogs.fun/img-common/202306191919409.png)

<img src="https://image.sybblogs.fun/img-common/202306191919409.png" alt="稀疏矩阵" style="zoom: 33%;" />

压缩存储策略：

- 顺序存储：三元组，存储行、列、值

  [稀疏矩阵三元组存储：](https://image.sybblogs.fun/img-common/202306241812141.png)

  <img src="https://image.sybblogs.fun/img-common/202306241812141.png" alt="三元组存储" style="zoom: 50%;" />

- 十字链表法：

  定义一个节点，节点包含非零元素所在的行、列、值。节点还会有两个指针：

  [十字链表节点：](https://image.sybblogs.fun/img-common/202306241847376.png)

  <img src="https://image.sybblogs.fun/img-common/202306241847376.png" alt="十字链表节点" style="zoom:25%;" />

  再定义两个数组：向下域(存放列指针)和向右域(存放行指针)，数组中存放的是一个个指针。

  [十字链表域：](https://image.sybblogs.fun/img-common/202306241850960.png)

  <img src="https://image.sybblogs.fun/img-common/202306241850960.png" alt="十字链表" style="zoom: 50%;" />

  这里以行遍历为例：行数组中第一个指针指向节点值是4，其节点行指针域保存本行下一个非零元素指针，当找到下一个节点行指针域为NULL时。行数组$+1$进入下一行，执行过程同上。

  列遍历同行遍历。

  

[矩阵常见考题：](https://image.sybblogs.fun/img-common/202306241819776.png)

<img src="https://image.sybblogs.fun/img-common/202306241819776.png" alt="矩阵考题" style="zoom: 50%;" />

# 六. 串

串，即字符串。是一种特殊的线性表，数据元素之间呈线性关系。

[串的线性关系：](https://image.sybblogs.fun/img-common/202306291538128.png)

<img src="https://image.sybblogs.fun/img-common/202306291538128.png" alt="串的线性关系" style="zoom:25%;" />

术语：

1. 子串：串中任意个**连续的字符**组成的子序列。空串也是字符串的子串。
2. 主串：整个字符串
3. 字符在主串中的位置：字符在串中的序号，从$1$开始。
4. 字串在主串中的位置：字串的第一个字符在主串中的位置，也是从$1$开始。如：$T=$`iPhone pro Max`，`pro`在$T$中位置是$8$

5. 只有长度为$0$时，才是空串。空格也算字符串，每个占$1B$

串的基本操作增删改查等，通常以子串为操作对象。

字符集编码：任何数据存到计算机中一定是二进制数，需要确定一个字符和二进制数的对应规则，这就是"编码"。一般考试用`ASCII`编码，一个字符大小为$1B$。

## 1. 串的存储方法

一般采用以下几种存储方法：

[串的几种存储：](https://image.sybblogs.fun/img-common/202306291607941.png)

<img src="https://image.sybblogs.fun/img-common/202306291607941.png" alt="串存储方法" style="zoom: 33%;" />

方案一缺点是从$0$开始，与串的序列不符。方案二缺点是`char[0]`大小不能超过255。所以经常采用方案四。

## 2. 串的顺序存储

### 2.1 定长顺序存储

可以采用静态数组方式实现串的顺序存储

~~~C++
#define MaxLEN 255
typedef struct{
    char ch[MaxLEN];
    int length;
}SString;
~~~

这样做缺点是数组长度是定长的，不能改变。

### 2.2 堆分配存储

用动态数组方式实现

~~~C++
typedef struct{
    char *ch;
    int length;
}HString;
HString S;
s.ch=(char*)malloc(MaxLEN*sizeof(char));
~~~

## 3. 串的链式存储

### 3.1 低密度存储

存储密度低，每个字符$1B$，而每个指针$4B$

~~~C++
typedef struct StringNode{
    char ch;
    struct StringNode *next;
}StringNode,*String;
~~~

[串低密度存储：](https://image.sybblogs.fun/img-common/202306291615862.png)

<img src="https://image.sybblogs.fun/img-common/202306291615862.png" alt="串低密度存储" style="zoom:25%;" />

### 3.2 高密度存储

每个结构体有一个长度为$4$的字符型数组

~~~C++
typedef struct StingNode{
    char ch[4];
    struct StingNode *next;
}StingNode,*String;
~~~

[串高密度存储：](https://image.sybblogs.fun/img-common/202306291617238.png)

<img src="https://image.sybblogs.fun/img-common/202306291617238.png" alt="串高密度存储" style="zoom:25%;" />

最后一个节点存储不满，可以用特殊字符标记，建议用`\0`

## 4. 字符串基本操作

### 4.1 求字串

要求：用`sub`返回串`S`的第`pos`个字符起长度为`len`的子串。

~~~C++
typedef struct{
    char ch[MaxLEN];
    int length;
}SString;
bool SubString(SString &Sub,SString S,int pos,int len){//sub:暂存;S:主串;pos:起始位置;len:截取长度
    if(pos+len-1>S.length) return false;	
    for(int i=pos;i<pos+len;i++){
        Sub.ch[i-pos+1]=S.ch[i];
    }
    Sub.length=len;
    return true;
}
~~~

### 4.2 字符串比较

若$S>T$，则返回值$>0$；若$S=T$，则返回值$=0$；若$S<T$，则返回值$<0$.

~~~C++
int StrCompare(SString S,SString T){
	for(int i=1;i<=S.length&&i<=T.length;i++){
        if(S.ch[i]!=T.ch[i]) return S.ch[i]-T.ch[i];
    }
    //所有字符串都相同，则长度大的字符串大
    return S.length-T.length;
}
~~~

### 4.3 定位操作

若主串$S$中存在与串$T$值相同的子串，则返回它在主串$S$中第一次出现的位置，否则函数值为$0$。

~~~C++
int Index(SString S,SString T){
    int i=1,n=StrLength(S),m=StrLength(T);
    SString sub;//暂存字串
    while(i<=n-m+1){
        SubString(sub,S,i,m);
        if(StrCompare(sub,T)!=0) ++i;
        else return i;//返回子串在主串中的位置
    }
    return 0;
}
~~~

每次从$S$中取$T$大小的字符，逐个对比即可。

## 5. 朴素模式匹配算法

字符串模式匹配：在一大片字符串(主串)中搜索某个字符串(模式串)。如：一个文档中搜索一段话。

这里解释较容易混淆概念：子串是主串的一部分，一定存在。模式串不一定能在主串中找到。

朴素模式匹配思路：在主串中依次取和模式串长度相同字符串进行匹配。如：主串长度为$n$，模式串长度为$m$，将主串中所有长度为$m$的子串依次进行对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。最多对比$n-m+1$个子串。

代码实现：用两个标记指针$i,j$，分别指向主串和模式串的第一个元素，每匹配依次，两个指针后移，匹配到不相同元素时让$i=i-j+2,j=1$，重新匹配。

~~~C++
int Index(SString S,SString T){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[i]){
            ++i,++j;//字符相等继续比较后续字符
        }else{
            i=i-j+2;
            j=1//指针后退重新开始匹配
        }
    }
    if(j>T.length) return i-T.length;//返回主串中匹配相同位置
    else return 0;//所有都不匹配返回0
}
~~~

时间复杂度：最坏情况，每个子串都要对比$m$个字符，共$n-m+1$个子串，复杂度$=O((n-m+1)m)=O(nm-m^2+m)=O(nm)$(由于很多时候往往$n\ge m$，所以$nm$数量级要远远大于$m^2,m$.所以只保留$nm$)

## 6. KMP算法匹配字符串

KMP算法是朴素模式匹配算法优化。利用好模式串本身带有的信息可以跳过中间很多没有必要的对比，从而使算法效率得到提升。给出一组子串和一个模式串：

1. 从主串$1$位置开始匹配，假定模式串前$5$个元素都匹配成功，但最后一个匹配失败。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111745319.png" alt="主串0" style="zoom:25%;" />
   <img src="https://image.sybblogs.fun/img-common/202307111745660.png" alt="模式串0" style="zoom:25%;" />

   对于模式串`T='abaabc'`，当第6个元素匹配失败时，可令主串指针$i$不变，模式串指针$j=3$，直接跳过$2,3$循环对比

   <img src="https://image.sybblogs.fun/img-common/202307111739872.png" alt="主串1" style="zoom:25%;" />
   <img src="https://image.sybblogs.fun/img-common/202307111739306.png" alt="模式串1" style="zoom: 50%;" />

2. 从主串$5$位置开始匹配，假定模式串的前$5$个元素都匹配成功，但最后一个匹配失败。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111753113.png" alt="主串2" style="zoom:25%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111754115.png" alt="模式串2" style="zoom:25%;" />

   同样对于模式串`T='abaabc'`，当第6个元素匹配失败时，可令主串指针$i$不变，模式串指针$j=3$，直接跳过$6,7$循环对比。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111757203.png" alt="主串3" style="zoom:25%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111757011.png" alt="模式串3" style="zoom:25%;" />

3. 从主串$1$位置开始匹配，假定模式串前$4$个元素都匹配成功，但第$5$个匹配失败。对于模式串`T='abaabc'`，当第5个元素匹配失败时，也就代表主串中前四个元素信息可以确定是`abaa`。此时可以让主串指针$i$不变，模式串指针指向$j=2$。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111802273.png" alt="主串4" style="zoom:25%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111802698.png" alt="模式串4" style="zoom:25%;" />

4. 从主串$1$位置开始匹配，假定模式串前$3$个元素都匹配成功，但第$4$个匹配失败。对于模式串`T='abaabc'`，当第4个元素匹配失败时，也就代表主串中前三个元素信息可以确定是`aba`。此时可以让主串指针$i$不变，模式串指针指向$j=2$。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111805669.png" alt="主串5" style="zoom:25%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111805030.png" alt="模式串5" style="zoom:25%;" />

5. 以此类推，主串$1$位置开始匹配，假定模式串前$2$个元素都匹配成功，但第$3$个匹配失败。对于模式串`T='abaabc'`，当第3个元素匹配失败时，也就代表主串中前二个元素信息可以确定是`ab`。可以让主串指针$i$不变，模式串指针指向$j=1$。如下：

   <img src="https://image.sybblogs.fun/img-common/202307111808500.png" alt="主串6" style="zoom:25%;" />

   <img src="https://image.sybblogs.fun/img-common/202307111808514.png" alt="模式串6" style="zoom:25%;" />

6. 同样的假定模式串第$2$个元素匹配失败，可令主串$i$不变，模式串$j=1$

7. 当第$1$个元素匹配失败时，匹配下一个相邻子串，令$j=0,i++,j++$

优化后的主串指针$i$不"回溯"。对于模式串`T='abaabc'`，回溯有以下情况：

[回溯情况：](https://image.sybblogs.fun/img-common/202307111903614.png)

<img src="https://image.sybblogs.fun/img-common/202307111903614.png" alt="回溯情况" style="zoom:25%;" />

我们可以用一个$next[]$数组存放模式串回溯信息。上面匹配情况$next$数组如下：

[next数组：](https://image.sybblogs.fun/img-common/202307111906009.png)

<img src="https://image.sybblogs.fun/img-common/202307111906009.png" alt="next数组" style="zoom:25%;" />

当第一个元素匹配失败时，令$j=next[1]$；当第二个元素匹配失败时，令$j=next[2]$；当第三个元素匹配失败时，令$j=next[3]$....

判断代码：

~~~C++
if(S[i]!=T[j]){
    j=next[i]
}
if(j==0){
    i++;
    j++;
}
~~~

模式匹配部分完整代码：

~~~C++
int Index_KMP(SString S,SString T,int next[]){
    int i=1, j=1;
    while( i<=S.length&&j<=T.length){
        if(j==0||S.ch[i]==T.ch[j]){
            ++i;
            ++j;			//继续比较后继字符
        }
        else j=next[j];		//模式串向右移动
    }
    if(j>T.length)
        return i-T.length;	//匹配成功
    eLse return 0;
}
~~~

KMP算法最欢时间复杂度$O(m+n)$.其中求$next$数组时间复杂度为$O(m)$，模式匹配时间复杂度为$O(n)$

## 7. ==求next数组==

求next数组过程很关键，要利用next数组进行匹配，主串指针不用回溯，从而减少时间复杂度。

求字符串`google`的next数组过程：字符串`google`长度是$6$，那么next数组长度也应该是$6$。主串指针为$i$，模式串指针为$j$

- $next[1]$的含义是当第一个字符匹配失败要回溯的位置。

  此时让$next[1]$的值为$0$，实际上任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串，因此，`next[1]`都无脑写$0$

- $next[2]$的含义是当第二个字符匹配失败要回溯的位置。此时只知道主串前一个元素的值。

  任何模式串都一样，第$2$个字符不匹时，应尝试匹配模式串的第$1$个字符，因此，`next[2]`都无脑写$1$

- $next[3]$是第三个字符匹配失败要回溯位置。在匹配失败元素前面画一条竖线。此时知道主串前两个元素的值。如下：

  <img src="https://image.sybblogs.fun/img-common/202309211301104.png" alt="求next数组" style="zoom:25%;" />

  尝试模式串往后移动一位与主串对应元素进行匹配：

  <img src="https://image.sybblogs.fun/img-common/202309211302966.png" alt="求next数组2" style="zoom:25%;" />

  显然$g!=o$故再往后移：

  <img src="https://image.sybblogs.fun/img-common/202309211303810.png" alt="求next数组3" style="zoom:25%;" />

  此时移动到匹配失败元素的位置，而指针$j=1$故$next[3]=1$

- 同理，当第四个元素匹配失败要回溯位置$next[4]$

  <img src="https://image.sybblogs.fun/img-common/202309211306022.png" alt="求next数组4" style="zoom:25%;" />

  模式串右移一位，与对应主串匹配：

  <img src="https://image.sybblogs.fun/img-common/202309211307654.png" alt="求next数组5" style="zoom:25%;" />

  $g!=o$再次右移仍不匹配，直到模式串指针$j$移动到主串指针$i$指向的位置

  <img src="https://image.sybblogs.fun/img-common/202309211310903.png" alt="求next数组6" style="zoom:25%;" />

  此时$j=1$，故$next[4]=1$

- $next[5]$的值，同理

  <img src="https://image.sybblogs.fun/img-common/202309211313022.png" alt="求next数组7" style="zoom:25%;" />

  模式串右移同时观察是否匹配对应主串，当移动到第四位时：

  <img src="https://image.sybblogs.fun/img-common/202309211314431.png" alt="求next数组8" style="zoom:25%;" />

  发现模式串第一位$g$与主串可以匹配，但由于主串$i$所指位置不确定，故`next[5]=j`，即next[5]=2

- 同理得$next[6]=1$

总结：next数组的作用：当模式串的第j个字符失配时，从模式串的第`next[j]`的继续往后匹配

步骤总结：在不匹配的位置前边，划一根分界线，模式串一步一步往后退，直到分界线之前能匹配上，或模式串完全跨过分界线为止此时$j$指向哪儿，next数组值就是多少。代码如下：

~~~C++
//计算next数组 
void nextVal(char s[],int next[],int len){
	//c是不匹配的位置，i主串位置，j匹配串位置；由于前两位匹配失败回溯值确定，所以从第三个位置开始匹配
    //由于不匹配位置从3开始,故主串自动右移一位与模式串第一位进行匹配,即i=2,j=1
	int c=3,i=2,j=1;
	while(c<=len){
        //首次循环如果模式串第一位匹配主串第二位是否相等
		if(s[i]==s[j]){
            //如果相等主串与模式串指针继续后移匹配
			++i,++j;
		}else{
            //如果不相等,主串继续后移,模式串回溯到1重新匹配
			i=i-j+2;
			j=1;
		}
        //如果主串指针i指向不匹配元素位置,则结束本次匹配,j的值就是next[c]的值
		if(i==c){
			next[c]=j;
            //继续计算下一次next[c]的值
			c++;
		}
	}
} 
~~~

## 8. KMP算法进一步优化

本质是对next数组的优化，将next数组优化为nextval数组。

以模式串`abaabc`为例，其对应next数组如下：

<img src="https://image.sybblogs.fun/img-common/202309211338861.png" alt="求next数组9" style="zoom:25%;" />

当$next[3]$时模式串指针$j$应该回溯到$1$的位置，此时会发现模式串回溯位置是字符`a`，而回溯之前匹配失败位置$3$处的值也是`a`，所以主串所指位置$i$处一定不是`a`，这样又要将模式串进行$next[1]$的回溯，相当于多一次不必要的回溯。

即$next[3]处所指向元素=next[1]处所指向元素$，而主串$S[i]处元素\ne next[3]处元素$

<img src="https://image.sybblogs.fun/img-common/202309211346746.png" alt="求next数组10" style="zoom:25%;" />

直接办法是让`next[3]=next[1]=0`，此时如果模式串第三个位置匹配失败，执行$next[3]=0$，回溯到$0$处，此时直接跳过主串$S[3]$处必定失败的匹配。

同理，$next[5]$处值也可以优化为$next[2]$处的值，即$next[5]=next[2]=1$。优化后next数组如下：

<img src="https://image.sybblogs.fun/img-common/202309211358831.png" alt="求next数组11" style="zoom:25%;" />

其代码实现核心是失败位置$next[i]$所指向的元素是否**等于**主串$S[i]$处的元素。如果等于则优化为：$nextval[i]=nextVal[next[i]]$

~~~C++
//优化next数组,s模式串,len模式串长度
void nextVals(char s[],int next[],int nextVal[],int len){
	for(int i=2;i<=len;i++){
		if(s[next[i]]==s[i])
			nextVal[i]=nextVal[next[i]];
		else
			nextVal[i]=next[i];
	}
	for(int i=1;i<=len;i++){
		cout<<"nextVal："<<nextVal[i]<<endl;
	}
} 
~~~

# 七 ==树==

树是一种递归定义的结构。树的结构如下：

<img src="https://image.sybblogs.fun/img-common/202309212037104.png" alt="非空树结构" style="zoom:25%;" />

以上是非空树结构，还有空树$\varnothing——$结点为$0$的树。

## 1. 树的基本概念

非空树特点：

1. 有且仅有一个根节点

2. 没有后继的结点称为"叶子结点"(或终端结点)

3. 有后继的结点称为"分支结点"(或非终端结点)

4. 除了根节点，==任何一个节点都有且仅有一个前驱==

5. 每个节点可以有$0$个或多个后继

6. 除根节点外，其余节点可以分为若干个**子树**，这些子树特点是互不相交

   <img src="https://image.sybblogs.fun/img-common/202309212045820.png" alt="子树" style="zoom:25%;" />

结点之间的关系描述：

<img src="https://image.sybblogs.fun/img-common/202309212049150.png" alt="结点之间的关系描述" style="zoom:25%;" />

- 祖先结点：从子结点开始，往上经过结点都是祖先结点

  如：`爷爷`$——$`父亲`是`你`的祖先结点

- 孙子结点：从子结点开始，下面的分支都是孙子结点

  如：`F`是`父亲`的孙子结点

- 双亲结点(父结点)：一个结点直接前驱是父结点

  如：`你`的父结点是`父亲`

- 孩子结点：一个结点的直接后继是孩子结点

  如：`H`的孩子结点是`M`

- 兄弟结点：子树同一层结点为兄弟结点

  如：`I`，`j`是`H`的兄弟结点

- 堂兄弟结点：同一层结点为堂兄弟结点

  如：`G`，`H`，`I`是`J`的堂兄弟结点

- 路径：描述两个结点之间的路径，是单向的，只能从上往下。

- 路径长度：指经过了几条边

结点、树的属性描述

属性:
结点的层次(深度)——从上往下数

<img src="https://image.sybblogs.fun/img-common/202309212124113.png" alt="树结点的层次" style="zoom:25%;" />

结点的高度——从下往上数

<img src="https://image.sybblogs.fun/img-common/202309212124368.png" alt="树结点的高度" style="zoom:25%;" />

树的高度(深度)——树总共多少层

结点的度——一个结点有几个分支(包括根结点)。非叶子结点的度$>0$，叶子结点度$=0$

树的度——各结点的度的最大值。如上面树的度$=3$，是结点`D`

有序树：逻辑上看，树种结点的各子树从左到右是有次序的，不能互换。如：

<img src="https://image.sybblogs.fun/img-common/202309212049150.png" alt="结点之间的关系描述" style="zoom:25%;" />

无序树：树中结点的各子树从左至右是无次序的，可以互换。如：

<img src="https://image.sybblogs.fun/img-common/202309212131709.png" alt="无序树" style="zoom:25%;" />

森林：森林是$m(m\ge0)$棵互不相交的树的集合，可以允许有$\varnothing$现象。

<img src="https://image.sybblogs.fun/img-common/202309212133120.png" alt="森林" style="zoom:25%;" />

如果以上森林加一个共同根节点`A`，森林就变成了树。这是一个重要考点。

## 2. 树常考的性质

- 考点一：结点数$=$总度数$+1$

- 考点二：度为$m$的树、$m$叉树的区别

  $m$叉树：每个结点最多只能有$m$个孩子的树

  |            度为$m$的树             |              $m$叉树               |
  | :--------------------------------: | :--------------------------------: |
  | 任意结点的度$\le m$(最多$m$个孩子) | 任意结点的度$\le m$(最多$m$个孩子) |
  | 至少有一个结点度$=m$(有$m$个孩子)  |       允许所有结点的度都$<m$       |
  |  一定是非空树，至少有$m+1$个结点   |             可以是空树             |

  <img src="https://image.sybblogs.fun/img-common/202309212204069.png" alt="度为m树与m叉树" style="zoom:25%;" />

- 考点三：度为$m$的树第$i$层至多有$m^{i-1}$个结点$(i\ge1)$

  <img src="https://image.sybblogs.fun/img-common/202309212209936.png" alt="树常考点三" style="zoom:25%;" />

  第一层：最多$m^0$个结点；第二层：最多$m^1$个结点；第三层：最多$m^2$个结点；第四层：最多$m^3$个结点

  同理，$m$叉树第$i$层至多有$m^{i-1}$个结点$(i\ge1)$

- 考点四：高度为$h$的$m$叉树至多有$\frac{m^h-1}{m-1}$个结点

- 考点五：高度为$h$的$m$叉树至少有$h$个结点。高度为$h、$度为$m$的树至少有$h+m-1$个结点

  <img src="https://image.sybblogs.fun/img-common/202309212230180.png" alt="树常考点五" style="zoom: 50%;" />

- 考点六：具有$n$个结点的$m$叉树的最小高度为$\lceil\log_m(n(m-1)+1)\rceil$[^7-2-1]。

  高度最小情况：所有结点都有$m$个孩子
  $$
  \begin{aligned}
  	\begin{gather*}
  \\\Large{证明：}\\
  &高度为h的m叉树至多有\frac{m^h-1}{m-1}个结点\\
  \\
  &前h-1有\frac{m^{h-1}-1}{m-1}个结点\\
  \\
  &\frac{m^{h-1}-1}{m-1}<n\le\frac{m^h-1}{m-1}\\
  \\
  &\therefore h-1<\log_m(n(m-1)+1)\le h
  	\end{gather*}
  \end{aligned}
  $$

- 考点七：设非空二叉树中度为$0、1$和$2$的结点个数分别为$n_0、n_1$和$n_2$，则==$n_0=n_2+1$==(度为$0$的叶子结点比度为$2$的叶子结点多一个)。

  假设树中结点总数为$n$，则：

  ①$n=n_0+n_1+n_2$

  ②$n=n_1+2n_2+1$(树的结点数$=$总度数$+1$)

  此时②$-$①$\Longrightarrow n_0=n_2+1$，即叶子结点比二分支结点多一个。

  <img src="https://image.sybblogs.fun/img-common/202309301654790.png" alt="二叉树考点七" style="zoom:25%;" />

- 考点八：二叉树第$i$层至多有$2^{i-1}$个结点$(i\ge1)$；$m$叉树第$i$层至多有$m^{i-1}$个结点$(i\ge1)$。

  <img src="https://image.sybblogs.fun/img-common/202309301855581.png" alt="二叉树考点八" style="zoom:25%;" />

- 考点九：高度为$h$的二叉树至多有$2^{h}-1$个结点(满二叉树)，高度为$h$的$m$叉树至多有$\frac{m^{h}-1}{m-1}$个结点

  等比数列求和公式：$a+aq+aq^2+\cdots+aq^{n-1}=\frac{a(1-qn)}{q}$

- 完全二叉树考点$1$：具有$n$个$(n>0)$结点的完全二叉树的高度$h$为$\lceil\log_2(n+1)\rceil$或$\lfloor\log_2n\rfloor+1$

  高为$h$的满二叉树共有$2^h-1$个结点

  高为$h-1$的满二叉树共有$2^{h-1}-1$个结点

  故$h-1<\log_2(n+1)\le h$化简可得$h=\lceil\log_2(n+1)\rceil$
  
  <img src="https://image.sybblogs.fun/img-common/202310071217339.png" alt="完全二叉树常考点1" style="zoom: 50%;" />

- 完全二叉树考点$2$：对于完全二叉树，可以由树的结点数$n$推出度为$0,1$和$2$的结点个数为$n_0,n_1,n_2$

  完全二叉树最多只有一个度为$1$的结点，即$n_1=0$或$1$

  假设$n_0$是叶子结点的个数，$n_2$是双分支结点的个数，则$n_0=n_2+1\Longrightarrow n_0+n_2=2n_2+1$，故$n_0+n_2$一定是奇数。

  例：若一个完全二叉树有$2k$(偶数)个结点，则$n_1=1,n_0=k,n_2=k-1$

  <img src="https://image.sybblogs.fun/img-common/202310071219386.png" alt="完全二叉树常考点2" style="zoom:25%;" />

[常考点总结：](https://image.sybblogs.fun/img-common/202310071233110.png)

<img src="https://image.sybblogs.fun/img-common/202310071233110.png" alt="常考点总结" style="zoom:25%;" />

## 3. 二叉树

二叉树是$n(n\ge0)$个结点的有限集合

①或者是**空二叉树**，即$n=0$

②或者由一个根结点和两个互不相交的被称为根的左子树喝右子树组成，左子树和右子树又分别是一颗二叉树。

<img src="https://image.sybblogs.fun/img-common/202309252221835.png" alt="二叉树" style="zoom:25%;" />

特点：每个结点至多只有两棵子树，左右子树不能颠倒(二叉树是有序树)；二叉树是递归定义的数据结构。

二叉树五种状态：

<img src="https://image.sybblogs.fun/img-common/202309252226308.png" alt="二叉树五种状态" style="zoom: 33%;" />

### 3.1 几个特殊二叉树

#### 满二叉树

满二叉树：一棵高度为$h$，且含有$2^h-1$个结点的二叉树

<img src="https://image.sybblogs.fun/img-common/202309252229321.png" alt="满二叉树" style="zoom:25%;" />

特点：

①只有最后一层有叶子结点；

②不存在度为$1$的结点；

③按层序从$1$开始编号，结点$i$的左孩子为$2i$，右孩子为$2i+1$；结点$i$的父结点为$[i/2]$

#### 完全二叉树

完全二叉树：当且仅当其每个结点都与高度为$h$的**满二叉**树中编号为$1$~$n$的结点一一对应时，称为完全二叉树。

特点：

①只有最后两层可能有叶子结点；

②且最多只有一个度为$1$的结点。

③按层序从$1$开始编号，结点$i$的左孩子为$2i$，右孩子为$2i+1$；结点$i$的父结点为$[i/2]$

④$i\le[n/2]$为分支结点，$i>[n/2]$为叶子结点

⑤一个结点如果有孩子，一定是左孩子。

满二叉树是完全二叉树，而完全二叉树不一定是满二叉树。

<img src="https://image.sybblogs.fun/img-common/202309252314777.png" alt="完全二叉树" style="zoom:25%;" />

#### 二叉排序树

二叉排序树是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树:

①左子树上所有结点的关键字均小于根结点的关键字;

②右子树上所有结点的关键字均大于根结点的关键字。

③左子树和右子树又各是一棵二叉排序树。

<img src="https://image.sybblogs.fun/img-common/202309252332527.png" alt="二叉排序树" style="zoom:25%;" />

例：如果找`60`这个元素，先从根结点开始，根结点$19<60$往右结点走，右结点$50<60$再往右走，此时右结点$66>60$故往左走找到`60`元素的结点。

<img src="https://image.sybblogs.fun/img-common/202309301609187.png" alt="二叉排序树例子" style="zoom:25%;" />

#### 平衡二叉树

平衡二叉树，树上任一结点的左子树和右子树的深度之差不超过$1$

特点是：根节点子树越多，高度越低，搜索排序的效率越高。

<img src="https://image.sybblogs.fun/img-common/202309301626242.png" alt="平衡二叉树" style="zoom:25%;" />

同样平衡二叉树排序搜索效率很高。

### 3.2 二叉树存顺序储结构

#### 完全二叉树顺序存储

完全二叉树几个常考的基本操作：

- $i$号结点的左孩子：$2i$
- $i$号结点的右孩子：$2i+1$
- $i$号结点的父节点：$\lfloor  i/2\rfloor$
- $i$结点所在的层次：$\lceil\log_2(n+1)\rceil或\lfloor\log_2n\rfloor+1$

<img src="https://image.sybblogs.fun/img-common/202310252340467.png" alt="二叉树顺序存储3" style="zoom: 50%;" />

若完全二叉树中共有$n$个结点，则：

- 判断$i$是否有左孩子：$2i\le n?$
- 判断$i$是否有右孩子：$2i+1\le n?$
- 判断$i$是否是叶子$/$分支结点：$\lfloor i>n/2\rfloor?$

要存储下面完全二叉树结构：

<img src="https://image.sybblogs.fun/img-common/202310072028168.png" alt="二叉树顺序存储" style="zoom:25%;" />

~~~C++
#include <bits/stdc++.h>
#include<string>
#define MaxSize 100 
using namespace std;

struct treeNode{
	int data;
	bool isEmpy;
};

//初始化，所有结点标记为空
void initNode(treeNode t[]){
	for(int i=0;i<MaxSize;i++){
		t[i].isEmpy=true;
	}
}


int main(){
	treeNode t[MaxSize];
	initNode(t);
}
~~~

这里结构体中的`isEmpy`变量是该结点有没有元素，有的话为`false`，初始化时默认为`true`。其树元素在顺序表中存储如下：

<img src="https://image.sybblogs.fun/img-common/202310072030932.png" alt="二叉树顺序存储2" style="zoom:25%;" />

> 可以让第一个位置空缺，保证数组下标和结点编号一致。

#### 非完全二叉树顺序存储

要存储下面二叉树结构：

<img src="https://image.sybblogs.fun/img-common/202310252154932.png" alt="非完全二叉树" style="zoom:25%;" />

如果不是完全二叉树，依然按层序将各节点顺序存储，无法从结点编号反映出结点间的逻辑关系。

<img src="https://image.sybblogs.fun/img-common/202310072030932.png" alt="二叉树顺序存储2" style="zoom:25%;" />

这种存储方法不能用完全二叉树操作解决，所以是错误的。

解决方法是将二叉树结点编号与完全二叉树对应起来。将二叉树重新编号如下：

<img src="https://image.sybblogs.fun/img-common/202310252159921.png" alt="非完全二叉树存储2" style="zoom: 50%;" />

其存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202310252158760.png" alt="非完全二叉树存储" style="zoom:25%;" />

此时可以通过结点间的编号确定结点之间关系：

- $i$号结点的左孩子：$2i$
- $i$号结点的右孩子：$2i+1$
- $i$号结点的父节点：$[i/2]$

但是判断结点方法不能像完全二叉树那样，只能通过创建的`isEmpy`字段判断。如：判断$5$号结点是否有左孩子，由于结点编号关系可知左孩子$=2i=10$，$10$号结点的`isEmpy=true`所以$5$号结点没有左孩子。

缺点：

这样存储会导致顺序表有大量闲置空间，最坏情况是：高度为$h$且只有$h$个结点的单支树(所有结点只有右孩子)，也至少需要$2h-1$个存储单元.

[二叉树顺序存储最坏情况：](https://image.sybblogs.fun/img-common/202310252206390.png)

<img src="https://image.sybblogs.fun/img-common/202310252206390.png" alt="二叉树顺序存储最坏情况2" style="zoom:25%;" />

==结论==：二叉树的顺序存储结构，只适合存储**完全二叉树**。

### 3.3 二叉树的链式存储

存储以下二叉树结构：

<img src="https://image.sybblogs.fun/img-common/202310252210111.png" alt="二叉树链式存储" style="zoom:25%;" />

~~~c++
//二叉树的结点(链式存储)
typedef struct BiTNode{
    ElemType data;			//数据域
    struct BiTNode *lchild,*rchild;  //左、右孩子指针   
}BiTNode, *BiTree;
~~~

[实现结构图：](https://image.sybblogs.fun/img-common/202310252215149.png)

<img src="https://image.sybblogs.fun/img-common/202310252215149.png" alt="二叉树链式存储结构图" style="zoom:25%;" />

> `^`代表这个结点指针域为空。
>
> 由于每个结点都有两个指针域，如果一个二叉树有$n$个结点，那么它总共就有$2n$个指针域。除了根结点，每个结点头上都至少有一个指针连接，即有$n-1$个指针，故空指针个数为：$2n-(n-1)=n+1$个

完整定义代码：

~~~c++
struct ElemType{
    int value;
};
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *child,*rchild;
}BiTNode, *BiTree; 

//定义一棵空树
BiTree root = NULL; 
//插入根节点
root=(BiTree)malloc(sizeof(BiTNode));
root->data = {1};
root->lchild = NULL;
root->rchild = NULL;

//插入新结点
BiTNode *p=(BiTNode*)malloc(sizeof(BiTNode));
p->data = {2};
p->lchild = NULL;
p->rchild = NULL;
root->lchild=p;//作为根节点的左孩子
~~~

找到指定结点左$/$右孩子：只用通过指针就可以找到。

找到$p$结点父结点：只能通过遍历找到谁的左右指针是指向$p$结点的，这样很耗时，所以我们定义三叉链表解决这个问题：

~~~C++
typedef struct BiTNode{
    ElemType data;
    //数据域
    struct BiTNode *lchild,*rchild; //左、右孩子指针
    struct BiTNode *parent;			//父结点指针
}BiTNode,*BiTree;
~~~

### 3.4 二叉树遍历

二叉树递归特性：二叉树要么是个空二叉树，要么就是由"根节点$+$左子树$+$右子树"组成的二叉树。

#### ==三种遍历方法==

按照这种特性可以制定==三种常考的遍历规则==：

先序遍历：根左右($NLR$)
中序遍历：左根右($LNR$)
后序遍历：左右根($LRN$)

<img src="https://image.sybblogs.fun/img-common/202310260955958.png" alt="二叉树三种遍历方式" style="zoom:25%;" />

上图二叉树三种遍历方式为：

先序遍历：$ABC$
中序遍历：$BAC$
后序遍历：$BCA$

较为复杂二叉树如下：

<img src="https://image.sybblogs.fun/img-common/202310260958428.png" alt="二叉树三种遍历方式2" style="zoom:25%;" />

遍历方式如如下：

先序遍历：$ABDECFG$
中序遍历：$DBEAFCG$
后序遍历：$BCA$

算法表达式分析数：对于表达式：$a+b*(c-d)-e/f$的二叉树存储如下：

<img src="https://image.sybblogs.fun/img-common/202310261028530.png" alt="算数表达式的分析树" style="zoom:25%;" />

先序遍历：$-+a*b-cd/ef$

中序遍历：$a+b*c-d-e/f$

后序遍历：$abcd-*+ef/-$

由此可知：先序遍历$==$前缀表达式、中序遍历$==$中缀表达式(需要加界限符)、后续表达式$==$后缀表达式

三种遍历实现方式如下：

~~~c++
//先序遍历
void Pre0rder(BiTree T){
    if (T!=NULL){
        visit(T);				//访问根结点
        Pre0rder(T->lchild);	//递归遍历左子树
        Pre0rder(T->rchild);	//递归遍历右子树
    }
}
//中序遍历
void Pre0rder(BiTree T){
    if (T!=NULL){
        Pre0rder(T->lchild);	//递归遍历左子树
        visit(T);				//访问根结点
        Pre0rder(T->rchild);	//递归遍历右子树
    }
}
//后序遍历
void Pre0rder(BiTree T){
    if (T!=NULL){
        Pre0rder(T->lchild);	//递归遍历左子树
        Pre0rder(T->rchild);	//递归遍历右子树
        visit(T);				//访问根结点
    }
}
~~~

先序遍历(PreOrder)的操作过程如下：

1. 若二叉树为空，则什么也不做

2. 若二叉树非空：
   ①访问根结点

   ②先序遍历左子树

   ③先序遍历右子树

> 从根节点出发，画一条路：如果左边还有没走的路，优先往左边走，走到路的尽头(空结点)就往回走。如果左边没路了，就往右边走。如果左、右都没路了，则往上面走。先序遍历$\Longrightarrow$是在第一次路过时访问结点。

<img src="https://image.sybblogs.fun/img-common/202310261054371.png" alt="先序遍历图解" style="zoom:25%;" />

中序遍历和后续遍历同上，差别在于访问结点顺序不一样。

应用：求下面树的深度

<img src="https://image.sybblogs.fun/img-common/202310261101332.png" alt="遍历求树的高度" style="zoom:25%;" />

~~~c++
int treeDepth(BiTree T){
    if (T == NULL) {
        return 0;
    }else {
        int l = treeDepth(T->lchild);
        int r = treeDepth(T->rchild);
        //树的深度=Max (左子树深度/右子树深度+1)
        return (l>r)?l+1:r+1;
    }
}
~~~

> 上面算法通过递归特性，通过退栈，每退一次右子树的右结点，则`r+1`。遇到`NULL`结点时，进行退栈。

#### 二叉树层序遍历

层序遍历是每次都要判断一个结点$p$的左右结点是否为空，不为空的话，左右孩子入队，$p$结点出队。遍历如下的二叉树：

<img src="https://image.sybblogs.fun/img-common/202310261135354.png" alt="二叉树层次遍历" style="zoom:25%;" />

算法思想：
①初始化一个辅助队列
②根结点入队
③若队列非空，则队头结点出队，仿问该结点，并将其左、右孩子插入队尾(如果有的话)
④重复，知道队列为空

代码实现：

~~~C++
void LevelOrder(BiTree T){
    LinkQueue Q;
    InitQueue(Q); 				//初始化辅助队列
    BiTree p;
    EnQueue(Q,T);				//将根结点入队.
    while(!IsEmpty(Q)){			//队列不空则循环
        DeQueue(Q,p);			//队头结点出队
        visit(p);				//访问出队结点
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild); //左孩子入队
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);//右孩子入队
    }
}
~~~

结构定义：

~~~C++
//二叉树的结点(链式存储)
typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
//链式队列结点
typedef struct LinkNode{
    BiTNode * data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front,*rear; //队头队尾D
}LinkQueue;
~~~

> 结构定义第$8$行，我们并不需要保存整个树结点，只需要保存这个树结点的指针即可。

### 3.5 通过遍历序列构造二叉树

给定以下中序遍历序列：$BDCAE$

其二叉树树结构可能为以下几种情况：

<img src="https://image.sybblogs.fun/img-common/202310292006548.png" alt="不同二叉树的遍历序列" style="zoom: 33%;" />

同样可以得到一个结论：若只给出二叉树的前$/$中$/$后$/$层序遍历序列中的一种，不能唯一确定一棵二叉树。

但如果给出中序$+$前序$/$后续$/$层序就能反推出树的结构。

遍历序列特点：

- 前序遍历序列左边元素是根结点
- 后续序列的右边元素是根结点
- 中序序列可以通过前$/$后序列得出的根结点，划分左子树和右子树。如下例$1$中根结点$D$，则中序遍历序列中$D$左边为左子树右边为右子树。
- 层序遍历序列从左往右都是根结点。

<img src="https://image.sybblogs.fun/img-common/202310292031026.png" alt="遍历序列反推二叉树结构" style="zoom: 33%;" />

$\Large例1：$给出前序遍历序列：$DAEFBCHGI$；中序序列：$EAFDHCBGI$

1. 先由**前序遍历序列**得出根结点$D$；在**中序遍历序列**中$D$的左边为左子树，右边为右子树

   <img src="https://image.sybblogs.fun/img-common/202310292055171.png" alt="前序遍历+中序遍历" style="zoom:25%;" />

2. 左子树元素为：$EAF$，由**前序遍历序列**得出父结点$A$，其左子树为$E$，右子树为$F$

   <img src="https://image.sybblogs.fun/img-common/202310292058999.png" alt="前序遍历+中序遍历2" style="zoom:25%;" />

3. 右子树$HCBGI$，根结点**前序遍历序列**得出根结点$B$；其左子树为$HC$，右子树为$GI$

   <img src="https://image.sybblogs.fun/img-common/202310292105947.png" alt="前序遍历+中序遍历3" style="zoom:25%;" />

4. 再根据**前序遍历序列**得出左子树$HC$根结点为$C$；右子树$GI$的根结点为$G$。故整棵二叉树结构如下：

   <img src="https://image.sybblogs.fun/img-common/202310292109078.png" alt="前序遍历+中序遍历4" style="zoom:25%;" />

[三种遍历序列特点：](https://image.sybblogs.fun/img-common/202310292134793.png)

<img src="https://image.sybblogs.fun/img-common/202310292134793.png" alt="遍历序列反推二叉树结构2" style="zoom:25%;" />

注意：必须要知道**中序遍历序列**才能推出二叉树结构。

### 3.6 线索二叉树

#### 线索二叉树概念

<img src="https://image.sybblogs.fun/img-common/202311011943334.png" alt="二叉树线索" style="zoom:25%;" />

如上图二叉树结构，假设此时从$G$结点出发对这棵树进行中序遍历，显然是不能实现的，即从一个指定结点开始遍历树是不能完全实现的，因为以$G$结点为例，显然不能找到后继结点$B$[^7-3.6-1]。

再看$F$结点，结点的前驱是$A$，找到指定结点的前驱方法是：

- 从根节点出发，重新进行一次中序遍历，指针$q$记录当前访问的结点，指针$pre$记录上一个被访问的结点。
  ①当$q==p$时，$pre$即为前驱。

  ②同样找后继方法相同。当$pre==p$时，$q$为后继。

这样缺点是：每次必须从根结点开始，找前驱、后继很不方便。

此时就需要线索二叉树解决这个问题。

> 一个有$n$个结点的二叉树，有$n+1$个空链域。这些空链域可用来记录前驱、后继的信息。

上面的二叉树结构我们可以将其线索化，将结点空链域指向其前驱或后继(左指针指向前驱，右指针指向后继)。

[中序遍历线索二叉树：](https://image.sybblogs.fun/img-common/202311012043740.png)

<img src="https://image.sybblogs.fun/img-common/202311012043740.png" alt="中序遍历线索二叉树" style="zoom: 50%;" />

指向前驱后继的指针称为"**线索**"。代码实现：

~~~C++
//线索二叉树结点
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag, rtag;
    //左、右线索标志
}ThreadNode, *ThreadTree;
~~~

[线索二叉树结构定义：](https://image.sybblogs.fun/img-common/202311012048987.png)

<img src="https://image.sybblogs.fun/img-common/202311012048987.png" alt="线索结构图" style="zoom: 50%;" />

> $tag==0$，表示指针指向孩子
>
> $tag==1$，表示指针是"线索"

[中序线索二叉树的链式存储：]()

<img src="https://image.sybblogs.fun/img-common/202311012106600.png" alt="中序线索二叉树的链式存储" style="zoom:25%;" />

先序、后序原理同中序。

[三种序列二叉树线索化对比：]()

<img src="https://image.sybblogs.fun/img-common/202311012128791.png" alt="三种序列二叉树线索化对比" style="zoom:25%;" />

#### 线索二叉树代码实现

方法一：以中序遍历为例用$pre$指针记录前驱，$q$指针向下遍历，直到$q==p$时，$pre$指针指向结点就是$p$的前驱。

~~~C++
//中序遍历
void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild);	//递归遍历左子树       
        visit(T)			//访问根结点
        InOrder(T->rchild);	//递归遍历右子树
    }
}
//访问结点q
void visit(BiTNode *q){
    if (q==p)				//当前访问结点刚好是结点p
        final = pre;		//找到p的前驱
    else 
        pre = q;			//pre指向当前访问的结点
}
//辅助全局变量，用于查找结点p的前驱
BiTNode *p;					// p指向目标结点
BiTNode * pre=NULL;			//指向当前访问结点的前驱一
BiTNode * final=NULL;		//用于记录最终结果
~~~

方法二：同样以中序遍历为例，一边遍历一边线索化

~~~C++
ThreadNode *pre=NULL;

//线索二叉树结点
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag, rtag;
    //左、右线索标志
}ThreadNode, *ThreadTree;

//中序遍历二叉树，一边遍历一边线索化
void InThread (ThreadTree T) {
    if(T!=NULL) {
        InThread(T->lchild);
        //中序遍历左子树
        visit(T);
        //访问根节点
        InThread(T->rchild) ;
        //中序遍历右子树
    }
}

//访问结点
void visit (ThreadNode *q) {
    if(q->lchild==NULL){//左子树为空，建立前驱线索
        q->lchild=pre;
        q->ltag=1;
    }
    if(pre!=NULL&&pre->rchild==NULL){
        pre->rchild=q; //建立前驱结点的后继线索
        pre->rtag=1;
    }
    pre=q; 
}

void CreateInThread (ThreadTree T){
    pre=NULL;		//pre初始为NULL
    if(T!=NULL){	//非空二叉树才能线索化
        InThread(T);//中序线紧化二叉树
        if (pre->rchild==NULL)
            pre->rtag=1;	//处理遍历的最后一个结点

    }
}
~~~

> 上面代码第$40$行最后还要检查$pre$的$rchild$是否为$NULL$，如果是，则令$rtag=1$

要特别注意先序线索化，由于先序线索化要先访问根结点：

<img src="https://image.sybblogs.fun/img-common/202311042040268.png" alt="先序遍历注意点" style="zoom:25%;" />

当上面代码执行到$D$结点时，由于$D$左结点没有子结点，所以`q->lchild=pre;`，在执行`InThread(T->lchild);`时，`q`指针会回到$B$结点，导致出现死循环。解决方法是，在执行`InThread(T->lchild);`时先判断`tag`变量的值，看是否为真结点。修改代码如下：

~~~C++
//先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadTree T) {
    if(T!=NULL){
        visit(T);//先处理根节点
        if (T->ltag==0) //判断当前结点是否为真结点，而不是线索
            PreThread(T->lchild);
        PreThread(T->rchild);
    }
}
~~~

后序遍历线索化同中序遍历线索化。

#### 线索二叉树找前驱与后继

- 中序线索二叉树找后继

  在中序线索二叉树中找到指定结点$*p$，的中序后继$next$。线索化后的二叉树结构如下：

  <img src="https://image.sybblogs.fun/img-common/202311042056927.png" alt="线索二叉树找后继" style="zoom:25%;" />

  ①当`p->rtag==1`，则`next=p->rchild`的结点即为后继结点。

  ②当`p->rtag==0`时，证明结点的右子树非空，由于中序遍历顺序是`左 根 右`，故根结点下一个被访问的结点一定为后继。==即$p$结点右子树最左边结点即为后继==。

  代码实现：

  ~~~C++
  //找到以P为根的子树中，第一个被中序遍历的结点
  ThreadNode *Firstnode (ThreadNode *p){
      //循环找到最左下结点(不一定是叶结点)
      while(p->ltag==0) p=p->lchild;
      return p;
  }
  
  //在中序线索二叉树中找到结点p的后继结点
  ThreadNode *Nextnode(ThreadNode *p){
      //右子树中最左下结点
      if(p->rtag==0) return Firstnode(p->rchild);
      //else return p->rchild; //rtag==1 直接返回后继线索
      else return NULL;
  }
  
  //对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)
  void Inorder (ThreadNode *T){
      //for(ThreadNode *p=Firstnode(T); p!=NULL; p=Nextnode(p))
      for(ThreadNode *p=T; p!=NULL; p=Nextnode(p))
          visit(p);
  }
  ~~~

  > `for`循环中会直接找到`p`结点的后继结点。

- 中序线索二叉树找前驱

  ①若`p->ltag==1`， 则`pre=p->lchild`
  ②若`p->ltag==0`，证明结点的左子树非空，由于中序遍历顺序是`左 根 右`，故根结点前一个被访问的结点一定为前驱。==即$p$结点左子树最右边结点即为前继==。

  代码实现：

  ~~~C++
  //找到以P为根的子树中，第一个被中序遍历的结点
  ThreadNode *Lastnode (ThreadNode *p){
      //循环找到最左下结点(不一定是叶结点)
      while(p->rtag==0) p=p->rchild;
      return p;
  }
  
  //在中序线索二叉树中找到结点p的后继结点
  ThreadNode *Prenode(ThreadNode *p){
      //右子树中最左下结点
      if(p->ltag==0) return Lastnode(p->lchild);
      //else return p->rchild; //rtag==1 直接返回后继线索
      else return NULL;
  }
  
  //对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)
  void Inorder (ThreadNode *T){
      //for(ThreadNode *p=Firstnode(T); p!=NULL; p=Nextnode(p))
      for(ThreadNode *p=T; p!=NULL; p=Prenode(p))
          visit(p);
  }
  ~~~

  > `for`循环中会直接找到`p`结点的前驱结点。

- 先序线索二叉树找后继

  ①当`p->rtag==1`，则`next=p->rchild`的结点即为后继结点。

  ②当`p->rtag==0`时，证明结点的右子树非空，由于先序遍历顺序是`根 左 右`，有以下几种情况：

  1. 若`p`有左孩子，则先序后继为左孩子。
  2. 假设`p`没有左孩子，则先序后继为右孩子。

- 先序线索二叉树找前驱

  ①若`p->ltag==1`， 则`pre=p->lchild`
  ②若`p->ltag==0`，情况下先序遍历，左右子树中的结点只可能是根的后继，不可能是前驱。这种情况下只能用土办法从头开始遍历。

  但二叉树为三叉链表存储结构(各个结点记录父结点。)的具体查找情况如下：

  1. 如果能找到`p`的父节点，且`p`是左孩子：`p`的前驱为**父结点**
  2. 如果能找到`p`的父节点，且`p`是右孩子，其左兄弟为空：`p`的前驱为父结点。
  3. 如果能找到`p`的父节点，且`p`是右孩子，其左兄弟非空：`p`的前驱为左兄弟子树中**最后一个**被遍历的结点。按照先序遍历特点，设计算法时应该，优先遍历左兄弟结点**右边的路走**，右边路走完，找有没有左边路，以此循环找到最后一个被先序遍历的结点即为后继。
  4. 如果`p`是树的根结点，则`p`没有先序前驱。

- 后序线索二叉树找前驱

  ①若`p->ltag==1`， 则`pre=p->lchild`
  ②若`p->ltag==0`，情况下后序遍历，证明`p`必定有左孩子，但右孩子未知。有以下几种情况：

  1. 假设有右孩子，按照`左 右 根`遍历顺序。`p`前驱一定是右子树当中按照后序遍历最后一个被访问结点。即`p`有右孩子，则后序前驱为右孩子。
  2. 假设没有右孩子：此时`p`的后序前驱为左孩子

- 后序线索二叉树找后继

  ①若`p->ltag==1`， 则`pre=p->lchild`
  ②若`p->ltag==0`，情况下后序遍历，按照`左 右 根`特点顺序，后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继。这种情况下只能用土办法从头开始遍历。

  但二叉树为三叉链表存储结构(各个结点记录父结点。)的具体查找情况如下：

  1. 如果能找到`p`的父节点，且`p`是右孩子：`p`的父结点为其后继
  2. 如果能找到`p`的父节点，且`p`是左孩子：`p`的父结点为其后继
  3. 如果能找到`p`的父节点，且`p`是左孩子，其右兄弟非空：`p`的后继为右兄弟子树中第一个被后序遍历的结点。按照后序遍历特点，设计算法时应该，优先遍历右兄弟结点**左边的路走**，左边路走完，找有没有右边路，以此循环找到最后一个被后序遍历的结点即为后继。

  4. 如果`p`是根节点，则`p`没有后序后继

总结：

|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |
| :----: | :------------: | :------------: | :------------: |
| 找前驱 |       √        |       ×        |       √        |
| 找后继 |       √        |       √        |       ×        |

==线索二叉树考点在于==：怎么手算二叉树线索化、找线索二叉树前驱和后继。

## 4. 树的存储与遍历

树是一种递归定义的数据结构。

树是$n(n\ge0)$个结点的有限集合，$n=0$时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足:

1. 有且仅有一个特定的称为根的结点。
2. 当$n>1$时，其余结点可分为$m (m>0)$个互不相交的有限集合$T_1,T_2.... T_m$，其中每个集合本身又是一棵树，并且称为根结点的子树。

[树结构：](https://image.sybblogs.fun/img-common/202311101443007.png)

<img src="https://image.sybblogs.fun/img-common/202311101443007.png" alt="树结构" style="zoom:25%;" />

### 4.1 树与森林的存储方法

#### 双亲表示法

双亲表示法：每个结点中保存指向双亲的"指针"。

树特点是树种任意一个结点都**有且仅有一个双亲**，所以在每个结点种保存指向"双亲"的指针。如要保存下面树结构：

<img src="https://image.sybblogs.fun/img-common/202311101451190.png" alt="双亲表示法" style="zoom:25%;" />

结构体如下：

~~~c
#define MaxSize 100
//树中最多结点数
typedef struct{
    ElemType data;		//树的结点定义
    //数据元素
    int parent;			//双亲位置域
}PTNode;
//树的类型定义
typedef struct{	
    PTNode nodes [MaxSize];//双亲表示
    int n;//结点数
}PTree;
~~~

[双亲表示法存储结构：](https://image.sybblogs.fun/img-common/202311111014149.png)

<img src="https://image.sybblogs.fun/img-common/202311111014149.png" alt="双亲表示法存储结构" style="zoom:25%;" />

如果新增加元素，无需按照逻辑上的次序存储。如：在`k`结点添加左孩子`k`和右孩子`l`，此时`k`，`l`结点插入顺序无所谓。

删除方案有两种：

- 将被删除元素的`parent`位置域指针值设置为：`-1`
- 删除该位置元素，并将尾部元素填充至该位置。

注意以上操作都要结点数`n-1`

如果删除的是根结点，那么要让根结点所有子结点同时删除，此时双亲表示法缺点就暴露出来：查指定结点的孩子只能从头遍历，对比该结点的`parent`值是否是删除根结点的位置。

如果被删除根结点子元素很多，那么使用**第一种删除方案会导致空数据增多**，增加遍历的时间复杂度。

#### 孩子表示法

孩子表示法：顺序存储各个节点，每个结点中保存孩子链表头指针

<img src="https://image.sybblogs.fun/img-common/202311111104993.png" alt="孩子表示法" style="zoom:25%;" />

树结构结构体代码如下：

~~~c
#define MaxSize 100
struct CTNode {
    int child;			//孩子结点在数组中的位置
    struct CTNode *next;//下一个孩子
};
typedef struct {
    ElemType data;
    struct CTNode *firstChild;//第一个孩子
}CTBox;
typedef struct{
    CTBox nodes[MaxSize] ;
    int n,r;			//结点数和根的位置
} CTree;
~~~

树结构存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202311111105767.png" alt="孩子表示法存储结构" style="zoom:25%;" />

#### ==孩子兄弟表示法==

孩子兄弟表示法：链式存储的方式存储一棵树。可以将树转化为二叉树的存储结构。

存储以下树结构：

<img src="https://image.sybblogs.fun/img-common/202311111104993.png" alt="孩子表示法" style="zoom:25%;" />

树的结构存储如下：

~~~c
typedef struct CSNode{
    ElemType data;							//数据域
    struct CSNode *firstchild,*nextsibling;	//第一个孩子和右兄弟指针
}CSNode,*CSTree;
~~~

`*firstchild`指针看作二叉树中的左指针，`*nextsibling`看作二叉树中的右指针。

存储过程如下：

1. 先存储根结点

2. 根结点左指针`*firstchild`指向第一个孩子`B`结点，接着`*nextsibling`指针指向`B`结点的兄弟结点。

   <img src="https://image.sybblogs.fun/img-common/202311111134883.png" alt="孩子兄弟表示法1" style="zoom:25%;" />

3. `B`结点的第一个孩子是`E`结点，`*firstchild`指向`E`；`E`结点兄弟是`F`，`*nextsibling`指针指向`F`。

   <img src="https://image.sybblogs.fun/img-common/202311111135989.png" alt="孩子兄弟表示法2" style="zoom:25%;" />

4. `E`的第一个孩子是`K`，`*firstchild`指向`K`

   <img src="https://image.sybblogs.fun/img-common/202311111136929.png" alt="孩子兄弟表示法3" style="zoom:25%;" />

5. `C`的第一个孩子是`G`，`*firstchild`指向`G`；

   <img src="https://image.sybblogs.fun/img-common/202311111137979.png" alt="孩子兄弟表示法4" style="zoom:25%;" />

6. `D`的第一个孩子是`H`，`*firstchild`指向`H`；剩下的`I`，`J`都是`H`的兄弟结点，故`H`的`*nextsibling`指针指向`I`，`I`的`*nextsibling`指针指向`J`

   <img src="https://image.sybblogs.fun/img-common/202311111140735.png" alt="孩子兄弟表示法5" style="zoom:25%;" />

以上操作我们将树转换为了二叉树。其优点是可以用熟悉的二叉树操作来处理树。

再看一个树转换二叉树例子：

<img src="https://image.sybblogs.fun/img-common/202311111143588.png" alt="树和二叉树的转化" style="zoom: 50%;" />

简单来说就是：树的左边都是其孩子结点，右边都是兄弟结点。

#### 森林转换二叉树

森林。森林是$m (m≥0)$棵互不相交的树的集合

上面的孩子兄弟表示法可以将树转换成二叉树。同样的，森林也可以转换为二叉树来存储和遍历。

将以下森林转换为二叉树：

<img src="C:\Users\Acid\OneDrive\图片\本机照片\408\森林转换为二叉树.png" alt="森林转换为二叉树" style="zoom:25%;" />

首先将这些森林的树转换为二叉树：

<img src="https://image.sybblogs.fun/img-common/202311111151856.png" alt="森林转换为二叉树1" style="zoom:25%;" />

由于这些树的根结点`B`，`C`，`D`是平级关系，所以相连称为兄弟关系。

<img src="https://image.sybblogs.fun/img-common/202311121454296.png" alt="森林转换为二叉树2" style="zoom:25%;" />

#### 二叉树转换为森林

二叉树转换为森林是对上一节的逆用。将以下二叉树转换为森林：

<img src="https://image.sybblogs.fun/img-common/202311121456591.png" alt="二叉树转换为森林" style="zoom: 50%;" />

根据右边结点是兄弟结点，左边是对应兄弟结点的子结点特性：

1. `A`，`C`，`F`，`L`是兄弟结点，即森林树的根结点。
2. 剩下结点依次为上面结点子结点即可

[二叉树转换为森林：](https://image.sybblogs.fun/img-common/202311121458890.png)

<img src="https://image.sybblogs.fun/img-common/202311121458890.png" alt="二叉树转换为森林2" style="zoom:25%;" />

### 4.2 树和森林的遍历

#### 先根遍历

先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历。

伪代码实现如下：

~~~c
//树的先根遍历
void Pre0rder(TreeNode *R) {
    if (R!=NULL){
        visit(R) 				//访问根节点
            while(R还有下一个子树T)
                Pre0rder(T);	//先根遍历下一棵子树 
    }
}
~~~

对下面树进行遍历：

<img src="https://image.sybblogs.fun/img-common/202311121637369.png" alt="先根遍历" style="zoom:25%;" />

先根遍历顺序：$A(B(EK)F)(CG)(DHIJ)$

==总结：树的先根遍历序列与这棵树相应二叉树的先序序列相同。==

#### 树的后根遍历(深度优先遍历)

后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。

伪代码如下：

~~~c
//树的后根遍历
void Pos tOrder(TreeNode *R){
    if (R!=NULL){
        while(R还有下一个子树T)
            PostOrder(T); 	//后根遍历下一棵子树
        visit(R); 			//访问根节点
    }
}
~~~

对下面树进行遍历：

<img src="https://image.sybblogs.fun/img-common/202311121637369.png" alt="先根遍历" style="zoom:25%;" />

后根遍历顺序：$((KE)FB)(GC)(HIJD)A$

==总结：树的后根遍历序列与这棵树相应二叉树的中序序列相同。==

#### 树的层次遍历(广度优先遍历)

用队列实现：

1. 若树非空，则根节点入队
2. 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
3. 重复
4. 直到队列为空

#### 森林的先序遍历

先序遍历森林：若森林为非空，则按如下规则进行遍历:

1. 访问森林中第一棵树的根结点。
2. 先序遍历第一棵树中根结点的子树森林。
3. 先序遍历除去第一棵树之后剩余的树构成的森林。

遍历以下森林结构：

<img src="https://image.sybblogs.fun/img-common/202311121649859.png" alt="森林的遍历" style="zoom:25%;" />

先序遍历顺序：$(B(EKL)F)(CG)(D(HM)IJ)$

森林的先序遍历效果等同于依次对各个树**进行先根遍历**

以上算法设计时，有两层的嵌套递归，所以推荐将森林转换为二叉树，==其先序遍历效果等同于依次对二叉树进行先序遍历==。

[森林转换二叉树：]()

<img src="https://image.sybblogs.fun/img-common/202311121656736.png" alt="森林转换二叉树遍历" style="zoom:25%;" />

#### 森林的中序遍历

先序遍历森林：若森林为非空，则按如下规则进行遍历:

1. 中序遍历第一棵树中根结点的子树森林。
2. 访问森林中第一棵树的根结点。
3. 中序遍历除去第一棵树之后剩余的树构成的森林。

遍历以下森林结构：

<img src="https://image.sybblogs.fun/img-common/202311121649859.png" alt="森林的遍历" style="zoom:25%;" />

中序遍历顺序：$((KLE)FB)(GC)((MH)IJD)$

森林的先序遍历效果等同于依次对各个树**进行后根遍历**

同样的以上算法设计时，有两层的嵌套递归，所以推荐将森林转换为二叉树，==其中序遍历效果等同于依次对二叉树进行中序遍历==。

[森林转换二叉树：]()

<img src="https://image.sybblogs.fun/img-common/202311121656736.png" alt="森林转换二叉树遍历" style="zoom:25%;" />

总结：

|    树    |   森林   |  二叉树  |
| :------: | :------: | :------: |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |

## 5. 哈夫曼树

结点的权：有某种现实含义的数值(如：表示结点的重要性等)

结点的带权路径长度：从树的根到该结点的路径长度( 经过的边数)与该结点上权值的乘积

树的带权路径长度：树中所有叶结点的带权路径长度之和(WPL, Weighted Path Length)
$$
WPL=\sum\limits_{i=1}^{n}w_il_i
$$
计算以下树叶子结点的带权路径长度：

<img src="https://image.sybblogs.fun/img-common/202311121726458.png" alt="哈夫曼树" style="zoom:25%;" />
$$
WPL=1*2+3*2+4*2+5*2=26
$$
<img src="https://image.sybblogs.fun/img-common/202311121729662.png" alt="哈夫曼树WPL值" style="zoom:25%;" />
$$
WPL=3*1+3*3+2*4+1*5=25
$$
<img src="https://image.sybblogs.fun/img-common/202311121730143.png" alt="哈夫曼树WPL值2" style="zoom:25%;" />
$$
WPL=1*5+2*4+3*1+3*3=25
$$
有了带权路径长度这个概念可以得到哈夫曼树==定义==：在含有$n$个带权叶结点的二叉树中，其中带权路径长度$(WPL)$最小的二叉树称为哈夫曼树，也称最优二叉树。

### 5.1 哈夫曼树的构造

给定$n$个权值分别为$w_1,w_2...w_3$，的结点，构造哈夫曼树的算法描述如下:

1. 将这$n$个结点分别作为$n$棵仅含一个结点的二叉树，构成森林$F$。
2. 构造一个新结点，从$F$中选取**两棵根结点权值最小的树**作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。
3. 从$F$中删除刚才选出的两棵树，同时将新得到的树加入$F$中。
4. 重复步骤$2$和$3$，直至$F$中只剩下一棵树为止。

有以下结点集合，构造哈夫曼树：

<img src="https://image.sybblogs.fun/img-common/202311122011174.png" alt="构造哈夫曼树" style="zoom:25%;" />

步骤：

1. 首先将集合中最小的两个结点作为孩子结点，其根结点为两个孩子结点权值之和。

   <img src="https://image.sybblogs.fun/img-common/202311122012114.png" alt="构造哈夫曼树2" style="zoom:25%;" />

   `a`，`c`结点权值较小作为孩子结点，其根结点是权值为`3`的结点。

2. 再将上面根结点与剩下结点集合中权值最小的结点`e`做合并，根结点为`3`与`e`结点权值之和`5`

   <img src="https://image.sybblogs.fun/img-common/202311122015274.png" alt="构造哈夫曼树3" style="zoom:25%;" />

3. 重复上述操作将`5`和`b`结合，其根结点为`8`；`8`在与`d`结合，根结点为`15`

   <img src="https://image.sybblogs.fun/img-common/202311122017374.png" alt="构造哈夫曼树4" style="zoom:25%;" />

   这颗树的`WPL`为：
   $$
   WPL_{min}=1*7+2*3+3*2+4*1+4*2=31
   $$
   这颗带权路径长度最小的二叉树就是哈夫曼树。

特点如下：

- 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。
- 哈夫曼树的结点总数为$2n-1$。
- 哈夫曼树不存在度为$1$的结点。

- 哈夫曼树不唯一，且$WPL$必然相同(最小)且为最优。

  上面例子还可以构造成下面这颗哈夫曼树：

  <img src="https://image.sybblogs.fun/img-common/202311122023460.png" alt="构造哈夫曼树5" style="zoom:25%;" />

  其$WPL_{min}=31$

### 5.2 哈夫曼树的应用

哈夫曼树应用是：哈夫曼编码用于压缩。

哈夫曼编码：即给定一个字符集，设计一个编码方案。

$\Large 例:$假设给定一个字符集$(A,B,C,D)$，其中$C$出现$80$次，$A$出现$10$次，$B$出现$8$次，$D$出现$2$次。

分析：规定哈夫曼树左路径是$0$，右路径是$1$。以上字母出现的次序就是哈夫曼树的权值，出现$2$次的$D$和出现$8$次的$B$结合成一个结点权重为$10$的结点。权重为$10$的结点和出现10次的$A$形成新的根结点$20$，根结点在和$C$形成权重为$100$的根结点。组成的哈夫曼树如下：

<img src="https://image.sybblogs.fun/img-common/202311122148892.png" alt="构造哈夫曼树6" style="zoom:25%;" />

此时$C$的编码为$0$；$A$的编码为$10$；$D$的编码为$110$；$B$的编码为$111$。将编码$0101010111110$编译为对应的字母：$CAAABD$

则此哈夫曼树的$MPL_{min}=1*80+2*10+3*2+3*8=130$

==哈夫曼编码特点==：

1. **可变长度编码**：允许对不同字符用不等长的二进制位表示。如上面的$A$编码不能设置为$1$，因为此时会和$110,111$冲突。
2. 固定长度编码：每个字符用相等长度的二进制位表示
3. 若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。非前缀编码在解码的时候有歧义，如将上面$A$编码改为$1$。
4. **有哈夫曼树得到哈夫曼编码**：字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树。

5. 同样，哈夫曼编码不唯一。
6. 上面哈夫曼编码可以用于压缩存储。

# 八. 并查集

注：并查集( Disjoint Set)是逻辑结构：是集合的一种具体实现，只进行"并"和"查"两种基本操作。

如果给定多个元素，将各个元素划分为若千个互不相交的子集，这些子集就叫做集合。

可以用**森林**结构表示各个子集。以下子集：

<img src="https://image.sybblogs.fun/img-common/202311122252198.png" alt="子集" style="zoom:25%;" />

可以用森林表示结构：

<img src="https://image.sybblogs.fun/img-common/202311122252875.png" alt="森林表示集合结构" style="zoom:25%;" />

集合两个常见操作：①查：给定元素，找到该元素所属的集合(根结点)；②并：将一棵树的根结点并到另一个树下。

可以看到以上两个操作需要都需要由下往上找到根结点，所以我们需要用到**树的双亲表示法**来存储集合结构

[并查集存储结构：](https://image.sybblogs.fun/img-common/202311122303263.png)

<img src="https://image.sybblogs.fun/img-common/202311122303263.png" alt="并查集存储结构" style="zoom: 50%;" />

其中$s[]$表示的是数据元素的父结点，即`parent`指针指向的结点。

集合初始化代码如下：

~~~c
#define SIZE 13
int UFSets [SIZE];//集合元素数组
//初始化并查集
void Initial(int S[]){
    for(int i=0;i<SIZE;i++)
        S[i]=-1;
}
~~~

将上面元素根结点都设置为`-1`表示每个元素当前都是一个独立的子集。之后可以根据业务的具体需求对元素进行合并操作。

## 1. 集合查操作<a id="1-1"></a>

集合关于查的操作主要有以下两个：

- 给定一个元素`E`如何查到这个元素所属集合：从指定元素出发一路向北，找到根节点即可。

- 如何判断两个元素是否属于同一集合：分别查到两个元素的根，判断根节点是否相同即可。

查找代码如下：

~~~c
//Find“查"操作,找x所属集合(返回x所属根结点)
int Find(int S[],int x){
    while(S[x]>=0)	//循环寻找x的根
        x=S[x];
    return x;		//根的S[]小于0
}
~~~

如我们要找到`L`元素所属集合：`L`的`s[]`的值为`4`，即所指元素为`E`；`E`的`s[]`的值为`1`，指向`B`；而`B`的`s[]`为`0`指向`A`，`A`的`s[]`为`-1`代表此为根元素，即`L`从属于`A`。

若结点数为$n$，算法时间复杂度为$O(n)$。如果一个树深度很高如下图：

<img src="https://image.sybblogs.fun/img-common/202311131703911.png" alt="并查集查找最坏情况" style="zoom:25%;" />

那么此时算法时间复杂度就增加，所以查找时间复杂度和树的高度$h$有有关。优化的思路是在每次合并操作树的时候，尽量不让树太高。

## 2. 集合的合并操作

合并两个集合操作：让一棵树成为另一棵树的子树即可。

合并集合代码如下：

~~~c
//Union “并"操作，将两个集合合并为一个
void Union(int S[], int Root1, int Root2) {
    //要求Root1与Root2是不同的集合
    if(Root1==Root2)return;
    //将根Root2连接到另一根Root1'下面
    S[Root2]=Root1;
}
~~~

上面的`Root1`和`Roor2`代表要合并的两个树根结点的数组下标。

如果给定的元素不是根结点，那要查找两个元素的根结点，再进行合并操作。

## 3. 并查集的优化

若结点数为$n$，算法时间复杂度为$O(1)$

优化合并算法可以降低查询算法的时间复杂度，优化思路是：

1. 用根节点的绝对值表示树的结点总数
2. Union操作， 让小树合并到大树

并查集存储结构：

<img src="https://image.sybblogs.fun/img-common/202311122303263.png" alt="并查集存储结构" style="zoom: 50%;" />

可以优化为：

<img src="https://image.sybblogs.fun/img-common/202311131707122.png" alt="并查集优化合并算法" style="zoom:25%;" />

上面`A`所对应的`s[]`值为`-6`，代表树的结点为$6$。所以`s[]`的负值的绝对值代表了该树有多少结点。

合并优化后代码：

~~~c
//Union“并"操作，小树合并到大树
void Union(int S[],int Root1, int Root2) {
    if (Root1==Root2 ) return;
    if(S[Root2]>S[Root1]) { 	//Root2结 点数更少
        S[Root1] += S[Root2]; 	//累加结点总数
        S[Root2]=Root1; 		//小树合并到大树
    } else {
        S[Root2] += S[Root1];	//累加结点总数
        S[Root1]=Root2;			//小树合并到大树
    }
}
~~~

假设合并`A`和`C`两棵树，其对应的`Root1=0`，`Root2=2`；显然`Root2>Root1`即树`A`结点树大于树`C`。再执行`S[Root2]=Root1; `将小树合并到大树。合并后的树如下：

<img src="https://image.sybblogs.fun/img-common/202311131716169.png" alt="并查集优化合并算法2" style="zoom:25%;" />

该算法优化后可以让树的高度不超过$[\log_2n]+1$。Union操作优化后，Find操作最坏时间复杂度: $O(log_2n)$

## 4. 并查集优化2

可以类似与缓存那样，将`Find`查找的结点所经过路径的所有结点直接成为根结点的子结点。此时，可以让之后查找的路径变短，这种让查找路径变短的方法称为压缩路径。

如我们要找`L`结点所属集合，此时`L`结点查找必经过`E`和`B`结点：

<img src="https://image.sybblogs.fun/img-common/202311131733593.png" alt="并查集优化合并算法3" style="zoom:25%;" />

优化后树的结构图如下：

<img src="https://image.sybblogs.fun/img-common/202311131733582.png" alt="优化后树的结构图" style="zoom: 50%;" />

优化后树的存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202311131735952.png" alt="优化后树的存储结构图" style="zoom:25%;" />

压缩路径：Find操作，先找到根节点，再将查找路径上所有结点都挂到根结点下。

代码实现方式如下：

~~~c
//Find “查”操作优化，(先找到根节点再进行“压缩路径”
int Find(int S[],int x){
    int root = x;
    while(S[root]>=0)
        root=S[root]; 		//循环找到根
    while(x!=root){ 		//压缩路径
        int t=S[x];			//t指向x的父节点
        S[x]=root;			//x直接挂到根节点下
        x=t;
    }
    return root;			//返回根节点编号
}
~~~

每次`Find`操作，先找根，再"压缩路径"，可使树的高度不超过$0(\alpha(n))$。$\alpha(n)$是一个增长很缓慢的函数，对于常见的$n$值，通常$\alpha(n)≤4$，因此优化后并查集的`Find`、`Union`操作时间可以用常数级时间复杂度$O(1)$表示，可以看出时间开销都很低。

