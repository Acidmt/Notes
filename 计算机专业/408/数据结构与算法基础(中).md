[^1-1-1]: $|E|$表示是图的边

[toc]

# 九. 图

图是由顶点集$V$和边集$E$组成的，$|V|$表示顶点个数，$|E|$表示边个数。

顶点集表示图的顶点个数组成的集合，也可以称为图的阶。边集表示的是连接顶点的边组成的集合，任何一条边两头必须连接一个顶点。

<img src="https://image.sybblogs.fun/img-common/202311131803896.png" alt="图" style="zoom:25%;" />

注意：线性表可以是空表，树可以是空树，但图不可以是空，**即V一定是非空集**，但边$E$可以是空的。如下：

<img src="https://image.sybblogs.fun/img-common/202311131804724.png" alt="图的边为空集" style="zoom:25%;" />

图数据结构应用：地图、社交软件好友关系等。

<img src="https://image.sybblogs.fun/img-common/202311131806151.png" alt="图的应用" style="zoom:25%;" />

## 1. 图的概念

- 无向图与有向图：

  1. 若$E$是无向边(简称边)的有限集合时，则图`G`为无向图。边是顶点的无序对，记为$(v, w)$或$(w,v)$，因为$(v, w)=(w,v)$，其中$v、w$是顶点。可以说顶点$w$和顶点$v$互为邻接点。边$(v, w)$依附于顶点$w$和$v$，或者说边$(v, w)$和顶点$v、w$相关联。

     <img src="https://image.sybblogs.fun/img-common/202311131814297.png" alt="无向图" style="zoom:25%;" />
     $$
     \begin{equation*}
     	\begin{aligned}
     &G_2=(V_2,E_2)\\
     \\
     &V_2=\{A,B,C,D,E\}\\
     \\
     &E_2=\{(A,B),(B,D),(B,E),(C,D),(C,E),(D,E)\}
     	\end{aligned}
     \end{equation*}
     $$

  2. 若$E$是有向边( 也称弧)的有限集合时，则图$G$为有向图。弧是顶点的有序对，记为$<v, w>$，其中$v、w$是顶点，$v$称为弧尾，$w$称为弧头，$<v, w>$称为从顶点$v$到顶点$w$的弧，也称$v$邻接到$w$，或$w$邻接自$v$。注意：$<v, w>\ne<w, v>$

     <img src="https://image.sybblogs.fun/img-common/202311131815279.png" alt="有向图" style="zoom:25%;" />

$$
\begin{equation*}
	\begin{aligned}
&G_1=(V_1,E_1)\\
\\
&V_1=\{A,B,C,D,E\}\\
\\
&E_1=\{<A,B>,<A,C>,<A,D>,<A,E>,<B,A>,<B,C>,<B,E>,<C,D>\}
	\end{aligned}
\end{equation*}
$$

- 简单图与多重图：

  1. 简单图：①不存在重复边；②不存在顶点到自身的边

     可分为简单无向图和简单有向图：

     <img src="https://image.sybblogs.fun/img-common/202311131821965.png" alt="简单无向图和简单有向图" style="zoom:25%;" />

  2. 多重图：图G中某两个结点之间的边数多于条，又允许顶点通过同一条边和自己关联，则G为多重图

     可分为多重无向图和多重有向图：

     <img src="https://image.sybblogs.fun/img-common/202311131823764.png" alt="多重无向图和多重有向图" style="zoom:25%;" />

     数据结构课程只探讨**简单图**。

- 顶点的度：

  1. 对于无向图：

     顶点$v$的度是指依附于该顶点的边的条数，记为`TD(v)`。

     在具有$n$个顶点、$e$条边的无向图中，$\sum\limits_{i=1}^{n}TD(v_i)=2e$，即无向图的全部顶点的度的和等于边数的2倍。

  2. 对于有向图：

     入度是以顶点$v$为终点的有向边的数目，记为`ID(v)`，即该顶点有多少个箭头指向它。

     出度是以顶点$v$为起点的有向边的数目，记为`OD(v)`。即该顶点有多少个箭头指向别的顶点。

     顶点$v$的度等于其入度和出度之和，即$TD(v) = ID(v) + OD(v)$。

     <img src="https://image.sybblogs.fun/img-common/202311131830733.png" alt="有向图的度" style="zoom:25%;" />

     上面有向图$A$结点的度为$ID(v) + OD(v)=1+4=5$

     在具有$n$个顶点、$e$条边的有向图中，$\sum\limits_{i=1}^{n}ID(v_i)=\sum\limits_{i=1}^{n}OD(v_i)=e$

- 描述顶点和顶点关系的术语：

  <img src="https://image.sybblogs.fun/img-common/202311131839411.png" alt="顶点的关系描述术语" style="zoom: 25%;" />

  1. 路径：顶点$v_p$到顶点$vq$之间的一条路径是指顶点序列。在无向图中路径的方向是没有限制的，有向图中路径的方向是有限制的，要和弧的方向一致。

  2. 回路：第一个顶点和最后一个顶点相同的路径称为回路或环。如上无向图顶点$V_B,V_D,V_E$组成的路径就是回路。

  3. 简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。

  4. 简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。

  5. 路径长度：路径上边的数目。

  6. 点到点的距离：从顶点$u$出发到顶点$v$的最短路径若存在，则此路径的长度称为从$u$到$v$的距离。若从$u$到$v$根本不存在路径，则记该距离为无穷$(\infty)$。

  7. 连通：无向图中，若从顶点$v$到顶点$w$有路径存在，则称$v$和$w$是连通的。

     如果图$G$任意两个点都是连通的则称为连通图：

     <img src="https://image.sybblogs.fun/img-common/202311131847103.png" alt="连通图" style="zoom:25%;" />

     ==常见考点==：对于$n$个顶点的无向图$G$，若$G$是连通图，则最少有$n-1$条边。

     若$G$是非连通图，则最多可能有$C_{n-1}^2$条边。

  8. 强连通：有向图中，若从顶点$v$到顶点$w$和从顶点$w$到顶点$v$之间都**有路径**，则称这两个顶点是强连通的。

     <img src="https://image.sybblogs.fun/img-common/202311132058018.png" alt="强连通图0" style="zoom:25%;" />

     上图$V_A$和$V_B$之间是强连通的。

     若图中任何一对顶点都是强连通的，则称此图为强连通图：

     <img src="https://image.sybblogs.fun/img-common/202311131847421.png" alt="强连通图" style="zoom:25%;" />

     ==常见考点==：对于$n$个顶点的有向图$G$，若$G$是强连通图，则最少有$n$条边(形成回路)。

- 子图：

  设有两个图$G=(V, E)和G'=(V',E')$，若$V'$是$V$的子集，且$E'$是$E$的子集，则称$G'$是$G$的子图。

  <img src="https://image.sybblogs.fun/img-common/202311132031786.png" alt="子图1" style="zoom:25%;" />

  上面子图可以是：

  <img src="https://image.sybblogs.fun/img-common/202311132032300.png" alt="子图2" style="zoom:25%;" />

- 生成子图：如果原图中包含子图所有顶点，这个子图就可以称为原图的生成子图：

  <img src="https://image.sybblogs.fun/img-common/202311132034589.png" alt="生成子图" style="zoom: 25%;" />

有向图子图和生成子图概念同上。

- ==连通分量==：

  无向图中的极大连通子图称为连通分量。子图必须连通，且包含尽可能多的顶点和边。

  <img src="https://image.sybblogs.fun/img-common/202311132038115.png" alt="无向图的连通分量" style="zoom:25%;" />

  上图三个连通分量如下：

  <img src="https://image.sybblogs.fun/img-common/202311132038259.png" alt="无向图的连通分量1" style="zoom:25%;" />

- ==强连通分量==

  有向图中的极大强连通子图称为有向图的强连通分量。子图必须强连通，同时保留尽可能多的边。

  <img src="https://image.sybblogs.fun/img-common/202311132104755.png" alt="有向图的强连通" style="zoom:25%;" />

  上图强连通分量是：

  <img src="https://image.sybblogs.fun/img-common/202311132105944.png" alt="有向图的强连通分量" style="zoom:25%;" />

  同样的剩下两个顶点`F`和`G`也是图的一部分，所以这两个顶点单独拿出来也是极大强连通子图，故这个图强连通分量有三个。

- 生成树<a id="2-1-1"></a>

  连通图的生成树是包含图中全部顶点的一个极小连通子图。边要尽可能的少，但要保持连通。

  <img src="https://image.sybblogs.fun/img-common/202311132109878.png" alt="生成树" style="zoom:25%;" />

  上图的生成树是：

  <img src="https://image.sybblogs.fun/img-common/202311132109489.png" alt="最小生成树" style="zoom: 50%;" />

  同时也有别的生成路径，所以对于一个生成树来说生成树结果不唯一。

  若图中顶点数为$n$，则它的生成树含有$n-1$条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。

- 生成森林

  在非连通图中，连通分量的生成树构成了非连通图的生成森林。

  <img src="https://image.sybblogs.fun/img-common/202311132113143.png" alt="生成森林" style="zoom:25%;" />

  上面生成森林可以拆分成几个连通分量：

  <img src="https://image.sybblogs.fun/img-common/202311132114818.png" alt="连通分量" style="zoom:25%;" />

  再生成上面连通分量与之对应的生成树，这样就得到了森林非连通图得生成森林：

  <img src="https://image.sybblogs.fun/img-common/202311132117828.png" alt="生成森林2" style="zoom:25%;" />

- 带权图

  边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。

  带权图/网：边上带有权值的图称为带权图，也称网。

  带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度。

  <img src="https://image.sybblogs.fun/img-common/202311132123197.png" alt="带权图" style="zoom:25%;" />

- 几种特殊的图

  无向完全图：无向图中任意两个顶点之间都存在边

  <img src="https://image.sybblogs.fun/img-common/202311132218984.png" alt="无向完全图" style="zoom:25%;" />

  有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧

  <img src="https://image.sybblogs.fun/img-common/202311132218663.png" alt="有向完全图" style="zoom:25%;" />

  稀疏图：边数很少的图

  <img src="https://image.sybblogs.fun/img-common/202311132219442.png" alt="稀疏图" style="zoom:25%;" />

  稠密图：反之称为稠密图

  <img src="https://image.sybblogs.fun/img-common/202311132220365.png" alt="稠密图" style="zoom:25%;" />

  树：不存在回路，且连通的无向图

  <img src="https://image.sybblogs.fun/img-common/202311132222559.png" alt="特殊图：树" style="zoom:25%;" />

  常见考点: $n$个顶点的图，==若$|E|>n-1$[^1-1-1]，则一定有回路==。

  有向树：一个顶点的入度为$0$、其余顶点的入度均为$1$的有向图，称为有向树。

  <img src="https://image.sybblogs.fun/img-common/202311132226692.png" alt="有向树" style="zoom:25%;" />

  有向树并不是强连通图

## 2. 图的存储

### 2.1 邻接矩阵法

#### 邻接矩阵存放普通图

用二维数组存放各个顶点之间边的关系

[无向图存储结构：](https://image.sybblogs.fun/img-common/202311132230836.png)

<img src="https://image.sybblogs.fun/img-common/202311132230836.png" alt="无向图存储结构" style="zoom:25%;" />

[有向图存储结构：](https://image.sybblogs.fun/img-common/202311132231093.png)

<img src="https://image.sybblogs.fun/img-common/202311132231093.png" alt="有向图存储结构" style="zoom:25%;" />

上图中无论是有向图还是无向图，右边二维数组中存放的是边的关系。如：顶点`A`与顶点`B`之间有边，故二维数组`[A][B]=1`

代码存储结构如下：

~~~c
#define MaxVertexNum 100
//顶点数目的最大值
typedef struct{
    char Vex[MaxVertexNum];					//顶点表
    int Edge[MaxVertexNum][MaxVertexNum];	//邻接矩阵，边表
    int vexnum, arcnum;						//图的当前顶点数和边数/弧数
} MGraph;
~~~

上面存放顶点信息的`vex`数组，可以存放更复杂的信息。同时，由于二维数组中只存放`0`和`1`，所以可以使用更小的`bool`变量。

`vex`数组存放顶点信息时，数组下标要与`edge`数组中边的信息一致。即：

结点数为$n$的图$G= (V, E)$的邻接矩阵$A$是$n\times n$的。将$G$的顶点编号为$v_1,v_2....v_n$则
$$
A[i][j]\left\{ 
\begin{matrix}
1,&若(v_i,v_j)或<v_i,v_j>是E(G)中的边\\
\\
0&若(v_i,v_j)或<v_i,v_j>不是E(G)中的边
\end{matrix}
\right.
$$
求顶点的度、入度和出度方法：

对于无向图来说：第$i$个结点的度$=$第$i$行(或第$i$列)的非零元素个数。

对于无相图：

- 第$i$个结点的出度$=$第$i$行的非零元素个数
- 第$i$个结点的入度$=$第$i$列的非零元素个数.
- 第$i$个结点的度$=$第$i$行、第$i$列的非零元素个数之和

邻接矩阵法求顶点的度$/$出度$/$入度的时间复杂度为$O(|V|)$

#### 邻接矩阵法存放带权图

同样用二维数组存放，但同时存放的不再是`0`和`1`；如果两个顶点有边则存放`权值`。如果两个顶点无边则存放$\infty$。

<img src="https://image.sybblogs.fun/img-common/202311132251408.png" alt="邻接矩阵存储带权图" style="zoom:25%;" />

存储结构代码如下：

~~~c
#define MaxVertexNum 100		//顶点数目的最大值
#define INFINITY 最大的int值	//宏定,义常量"无穷"

typedef char VertexType;		//顶点的数据类型
typedef int EdgeType;			//带权图中边上权值的数据类型
typedef struct{
    VertexType Vex[MaxVertexNum];//顶点
    EdgeType Edge[MaxVertexNum][MaxVertexNum];//边的权
    int vexnum,arcnum;//图的当前顶点数和弧数
}MGraph;
~~~

#### 邻接矩阵性能分析与性质

空间复杂度: $O(|V|^2)$，只和顶点数相关，和实际的边数无关。

适合用于存储稠密图。无向图的邻接矩阵是对称矩阵，可以压缩存储(只存储上三角区$/$下三角区)。

性质：

设图$G$的邻接矩阵为$G$(矩阵元素为$0$或$1$)，则$G^n$的元素$G^n[i][j]$等于由顶点$i$到顶点$j$的长度为$n$的路径数目。

<img src="https://image.sybblogs.fun/img-common/202311142042411.png" alt="邻接矩阵法性质" style="zoom:25%;" />

$\Large例1:$ $G^2[1][4]=a_{11}a_{14}+a_{12}a_{24}+a_{13}a_{34}+a_{14}a_{44}=1$

上面除了$a_{12}a_{34}=1$，其它表达式等于$0$，这个$a_{12}a_{24}=1$代表存在一条路径是$A\rightarrow B$再从$B\rightarrow D$。最后结果等于$1$代表**从$A\rightarrow D$如果路径为$2$情况下只能找到一条路径**。其中$a_{12}$指的是$AB$，$a_{24}$指的是$BD$

$\Large 例2:$$G^2[2][2]=a_{21}a_{12}+a_{22}a_{22}+a_{23}a_{32}+a_{24}a_{42}=3$

这个结果表示从$B\rightarrow B$长度为$2$的路径有三条。$a_{21}a_{12}$表示$B\rightarrow A$再从$A\rightarrow B$这条路径存在。由于这是一个简单图并不存在自身连接的路径$a_{22}a_{22}=0$不存在$B\rightarrow B,B\rightarrow B$这条路径；$a_{23}a_{32}$表示$B\rightarrow C,C\rightarrow B$这条路径存在；$a_{24}a_{42}$表示$B\rightarrow D,D\rightarrow B$这条路径存在。

总结$G^2$代表对应两个结点之间长度为$2$的路径总共多少条。

### 2.2 邻接表

通过顺序$+$链式存储方式实现：

<img src="https://image.sybblogs.fun/img-common/202311142213685.png" alt="邻接表法" style="zoom: 50%;" />

存储上面无向图可以用下面存储结构：

<img src="https://image.sybblogs.fun/img-common/202311142214340.png" alt="邻接表法存储结构" style="zoom:25%;" />

代码结构实现如下：

~~~c
//"边/弧"
typedef struct ArcNode{
    int adjvex;				//边/弧指向哪个结点
    struct ArcNode *next;	//指向下一条弧的指针
    //InfoType info;		//边权值
}ArcNode;

//"顶点"
typedef struct VNode{
    VertexType data;//顶点信息
    ArcNode *first;//第一条边/弧
}VNode,AdjList[MaxVertexNum];

//用邻接表存储的图
typedef struct{
    AdjList vertices;
    int vexnum,arcnum;
}ALGraph;
~~~

`AdjList[MaxVertexNum]`存储各个顶点信息(`data`和`*first`指向第一条弧$/$边)；`vertices`顶点结点数组，代表一个图，其中的`vexnum`表示有多少条结点，`arcnum`表示有多少条边；每个边和弧也会有与之对应的结点`ArcNode`	

有向图邻接表法存储结构：

<img src="https://image.sybblogs.fun/img-common/202311142228986.png" alt="有向图邻接表法存储结构" style="zoom:25%;" />

由于无向图中结点边都是对应的，所以两个结点间的边需要保存两次，即边结点的数量是$2|E|$，整体空间复杂度为$O(|V| + 2|E|)$。

有向图每条弧都是对应一个结点，所以边结点的数量是$|E|$，整体空间复杂度为$(O(|V| + |E|)$。

- 无向图找度和边：

  找无向图顶点的度只需要遍历和这个顶点相关的边链表(`*first`指针指向的链表)即可，有几个边结点，度就是多少。同时这个边链表就是这个顶点的所有边。

- 有向图的入度，出度和边

  找一个结点出度，只需要遍历和这个结点相关的边链表即可，这个边链表也是指向其他结点的弧。

  找入度和指向当前结点的弧较为复杂：依次遍历所有顶点边链表，找对应的边。这也是邻接表存储图一大缺点。

### 2.3 邻接表与邻接矩阵对比

[邻接表与邻接矩阵：]()

<img src="https://image.sybblogs.fun/img-common/202311142238721.png" alt="邻接表与邻接矩阵" style="zoom:25%;" />

|                      |                   邻接表                   |      邻接矩阵      |
| :------------------: | :----------------------------------------: | :----------------: |
|      空间复杂度      | 无向图$O(|V|+2|E|)$<br/>有向图$O(|V|+|E|)$ |     $O(|V|^2)$     |
|       适合用于       |                 存储稀疏图                 |     存储稠密图     |
|       表示方式       |                   不唯一                   |        唯一        |
| 计算度$/$出度$/$入度 |    计算有向图的度、入度不方便，其余方便    | 必须遍历对应行或列 |
|      找相邻的边      |      找有向图的入边不方便，其余很方便      | 必须遍历对应行或列 |

### 2.4 十字链表

只能用于存储有向图。

邻接矩阵主要问题是：空间复杂度高。而邻接表问题在于找有向图的入边不方便，其余很方便。

[十字链表结构体结构：](https://image.sybblogs.fun/img-common/202311162007516.png)

<img src="https://image.sybblogs.fun/img-common/202311162007516.png" alt="十字链表存储有向图" style="zoom:25%;" />

存储以下有向图：

<img src="https://image.sybblogs.fun/img-common/202311162009956.png" alt="十字链表存储有向图2" style="zoom:25%;" />

则十字链表数据存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202311162010277.png" alt="十字链表数据存储结构" style="zoom:25%;" />

以上结点$ABCD$会分别存储在数组种$0123$位置。

从$A$结点**绿色指针代表弧尾**指向的是下标$1$所在的结点即$B$，表示从$A\rightarrow B$；$B$的绿色指针弧尾又指向$2$下标所在$C$结点的橙色弧头位置，表示从$A\rightarrow C$。

而$A$结点的橙色指针指针$2$下标所在的$C$结点，表明$C\rightarrow A$，$C$结点橙色指针接着往下找指向的是下标为$3$的$D$结点，代表$D\rightarrow A$。

总结：通过绿色指针往后找可以找到所有从当前结点发射的所有弧(该节点指向了谁)。橙色指针往后找则可以找到所有指向当前结点的弧。

十字链表的空间复杂度：$O(|V|+|E|)$。V代表顶点个数，E代表边的个数。

即解决邻接矩阵**空间复杂度高的问题**。又解决邻接表找有向图的**入边不方便的问题**。

### 2.5 邻接多重表

只能用于存储无向图。

用邻接矩阵存储无向图会导致空间复杂度高$O(|V|^2)$。邻接表的每条边对应两份冗余信息导致删除顶点、删除边等操作时间复杂度高。

[邻接多重表结构体存储结构：](https://image.sybblogs.fun/img-common/202311162254267.png)

<img src="https://image.sybblogs.fun/img-common/202311162254267.png" alt="邻接多重表结构体存储结构" style="zoom:25%;" />

存储以下有向图：

<img src="https://image.sybblogs.fun/img-common/202311162257876.png" alt="邻接多重表存储无向图" style="zoom:25%;" />

则邻接多重表数据存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202311162257407.png" alt="邻接多重表数据存储结构" style="zoom:25%;" />

结点存放`ABCDE`是一个数组，`firstedge`指针指向当前顶点相连的第一条边。

如：$A$结点`firstedge`指向`0`和`1`相连的边，即`A——B`。顺着`B`结点橙色指针指向的边，可以找到另一个与$A$结点相连的结点$D$。

再如：$B$结点`firstedge`指向`0`和`1`相连的边，其中`B`结点在整个结点中是绿色`1`结点，其绿色指针指向的就是`B`结点下一个边结点，即`2`$C$结点，同样下一个绿色`1`结点是`B`结点，再顺着绿色指针指向`E`结点。此时绿色指针域为`NULL`。

总结：边结点存放的该结点下标是什么颜色就找这个颜色指针指向的边界点。直到指针指向NULL。另一个颜色就是该结点相连的结点下标。

总之用邻接多重表存放无向图很方便，想要找到和某个顶点相连的边是很方便的，同时每一条只会对应一个边界点，所以不用再像邻接表那也同时维护两份冗余的数据，删除顶点、删除边等操作效率高很多。

如删除`AB`之间连接的边，我们只需要顺着`A`中`firstedge`指向的边结点`0|1`，顺着对应颜色橙色找到下一个与`A`相连的边结点`0|3`，将`firstedge`指针指向这个`0|3`边结点即可。如下图：

<img src="https://image.sybblogs.fun/img-common/202311162329577.png" alt="邻接多重表数据删除" style="zoom:25%;" />

如果要删除`E`整个结点，只需要将`E`边指向的边结点`4|1`和`2|4`删除，再将指向这两个边结点的`2|1`和`2|3`边结点对应指针域指向NULL即可。

<img src="https://image.sybblogs.fun/img-common/202311162334767.png" alt="邻接多重表数据删除结点" style="zoom:25%;" />

采用邻接多重表的空间复杂度是：$O(|V|+|E|)$，

### 2.6 总结

|              |                邻接矩阵                 |                   邻接表                   |    十字链表    |   邻接多重表   |
| ------------ | :-------------------------------------: | :----------------------------------------: | :------------: | :------------: |
| 空间复杂度   |               $O(|V|^2)$                | 无向图$O(|V|+2|E|)$<br/>有向图$O(|V|+|E|)$ |  $O(|V|)+|E|$  |  $O(|V|+|E|)$  |
| 找相邻边     | 遍历对应行或列<br/>时间复杂度为$O(|V|)$ |      找有向图的入边必须遍历整个邻接表      |     很方便     |     很方便     |
| 删除边与顶点 |  删除很方便，删除顶点需要大量移动数据   |        无向图中删除边或顶点都不方便        |     很方便     |     很方便     |
| 适用于       |                 稠密图                  |                系数图和其他                | 只能存储有向图 | 只能存储无向图 |
| 表示方式     |                  唯一                   |                   不唯一                   |     不唯一     |     不唯一     |

## 3. 图的基本操作

考研常考邻接矩阵和邻接表这两中结构。所以这里主要讲这两种存储结构的基本操作。

- $Adjacent(G,x,y)$： 判断图`G`是否存在边`<x, y>`或`(x,y)`。<a id="id1"></a>

  <img src="https://image.sybblogs.fun/img-common/202311172017993.png" alt="判断结点的边" style="zoom:25%;" />

  1. 对于邻接矩阵存储无向图：

     判断很方便，如上图要找`B`和`D`之间是否有边，只需要`B`行和`D`列的交点是否为`1`。时间复杂度只有$O(1)$。

  2. 对于邻接表存储无向图：

     要找`B`和`D`之间是否有边，我们要先遍历`B`的边结点指针有没有`D`结点，也就是后面链表`data`域有没有`3`。最好情况是要找的目标结点就是`*first`指针指向的第一个结点，此时时间复杂度是$O(1)$。最坏情况遍历完整个`B`的边结点也没有发现要找的结点，而和`B`连接的边最多可能有`n-1`条，所以最坏的时间复杂度是$O(|V|)$。即邻接表存储无向图找两个结点的边时间复杂度是$O(1)\sim O(|V|)$。

  3. 邻接矩阵和邻接表存储有向图分析同上。

- $Neighbors(G,x)$：列出图`G`中与结点`x`邻接的边。

  <img src="https://image.sybblogs.fun/img-common/202311172017993.png" alt="判断结点的边" style="zoom:25%;" />

  1. 对于邻接矩阵存储无向图：

     只需要遍历该结点的行或列即可，以行为例，假设矩阵某一行的一个值为`1`则表示该节点与该列的结点有邻边。时间复杂度为$O(|V|)$

  2. 对于邻接表存储无向图：

     要找当前结点只需要遍历结点`*first`指向的边链表即可，与该结点连接的边链表所有值即该结点的邻边。时间复杂度是$O(1)\sim O(|V|)$

  3. 对于邻接矩阵存储有向图方法同上，而邻接表存储时候我们需要考虑**入边和出边**：

     <img src="https://image.sybblogs.fun/img-common/202311172037783.png" alt="x结点邻接的边" style="zoom:25%;" />

     对于出边，同样只用遍历结点`*first`指向的边链表即可，时间复杂度是$O(1)\sim O(|V|)$。

     而对于入边，由于邻接表的缺点只能遍历所有`data`的`*first`指向的边结点链表，这样时间复杂度较高，是$O(|E|)$。

     所以列出图`G`中与结点`x`邻接的边这个操作**用邻接矩阵**存储有向图是更优秀的方案。但如果邻接表存储的是稀疏图，可能优于邻接矩阵。

- $InsertVertex(G,x)$在图`G`中插入顶点`x`。

  <img src="https://image.sybblogs.fun/img-common/202311172045139.png" alt="插入顶点x" style="zoom: 25%;" />

  1. 对于邻接矩阵存储无向图

     只需要在`data`后面写入新的结点`x`即可。由于矩阵已经完成了初始化，所以`x`结点的行和列都是`0`。所以时间复杂度为$O(1)$。

     [邻接矩阵插入新元素：]()

     <img src="https://image.sybblogs.fun/img-common/202311172057168.png" alt="邻接矩阵插入新元素" style="zoom: 25%;" />

  2. 对于邻接表存储无向图：

     同样只需要在`data`域中写入`x`即可，`*first`指针指向`NULL`。同样时间复杂度为$O(1)$。

     <img src="https://image.sybblogs.fun/img-common/202311172059499.png" alt="邻接表插入新元素" style="zoom:25%;" />

  3. 邻接矩阵和邻接表存储有向图分析同上。

- $DeleteVertex(G,x)$：从图`G`中删除顶点`x`。

  <img src="https://image.sybblogs.fun/img-common/202311172101544.png" alt="删除x顶点" style="zoom:25%;" />

  1. 对于邻接矩阵存储无向图

     一个简单方法是，在`data`中删除这个结点后，再把矩阵跟这个结点相关的行和列都变为`0`即可。对于如何在`data`中删除这个结点，可以设置一个`bool`变量，为`0`这表示该结点已经删除。由于只需要删除一行一列的数据只需要在$O(|V|)$的时间复杂度即可完成。

  2. 对于邻接表存储无向图

     我们在`data`中删除该顶点后，除了要将该结点的`*first`置空，同时要将其他顶点`*first`边链表中包含该删除顶点下标的链表结点也要删除。如下删除`C`顶点：

     <img src="https://image.sybblogs.fun/img-common/202311172110391.png" alt="删除x顶点2" style="zoom:25%;" />

     同样的最好情况是后面只有一个边，只需要$O(1)$复杂度即可完成。最坏情况是当前删除结点后面又尽可能多的边，即和其他顶点都有边，此时还需要在其他顶点中依次遍历该删除结点的下标，所以时间复杂度为$O(|E|)$。

  3. 对于邻接矩阵存储有向图方法同上，而邻接表删除顶点时候我们需要考虑**入边和出边**

     删除顶点的出边很方便只要删除`*first`指向的边链表即可。而要删除入边，那就需要遍历整个邻接表找`*first`指向的边链表包含被删除顶点下标的结点删除即可。

     删除出边时间复杂度是$O(1)\sim O(|V|)$。删除入边时间复杂度是$O(|E|)$。

     所以列出图`G`中删除顶点`x`这个操作**用邻接矩阵**存储有向图是更优秀的方案。但如果邻接表存储的是稀疏图，可能优于邻接矩阵。

- $AddEdge(G,x,y)$：若无向边`(x, y)`或有向边`<x, y>`不存在，则向图`G`中添加该边。(`x,y`之间没有变，则添加一条)

  1. 对于邻接矩阵存储无向图

     直接将矩阵中`x`行`y`列元素设置为`1`即可。时间复杂度为$O(1)$。

  2. 对于邻接表存储无向图

     假如添加`C`和`F`之间的一条边，需要在各自结点`*first`指针指向的边链表中添加**对方**的下标即可。建议使用头插法插入效率更高。时间复杂度只有$O(1)$。

  3. 邻接矩阵和邻接表存储有向图分析同上。

- ==$FirstNeighbor(G,x)$==：求图`G`中顶点`x`的第一个邻接点，若有则返回顶点号。若`x`没有邻接点或图中不存在`x`，则返回`-1`

  <img src="https://image.sybblogs.fun/img-common/202311172017993.png" alt="判断结点的边" style="zoom:25%;" />

  1. 对于邻接矩阵存储无向图

     只需要扫描该顶点对应的行找到第一个`1`即为当前结点第一个邻接点。最好情况下时间复杂度是$O(1)$，最坏情况是$O(|V|)$

  2. 对于邻接表存储无向图

     只需要找到当前顶点`*first`指向的第一个边结点即可。只需要$O(1)$时间复杂度。

  3. 对于邻接矩阵存储有向图

     对于出边要扫描该顶点对应的行；入边要扫描列。

  4. 对于邻接表存储有向图

     找出边方法只需要找到当前顶点`*first`指向的第一个边结点即可。时间复杂度是$O(1)$。

     找入边比较麻烦有可能遍历完所有顶点的边链表都没有指向该结点的边，时间复杂度为$O(1)\sim O(|E|)$

- ==$NextNeighbor(G,x,y)$==：假设图`G`中顶点`y`是顶点`x`的一个邻接点，返回除`y`之外顶点`x`的下一个邻接点的顶点号，若`y`是`x`的最后一个邻接点，则返回`-1`

  <img src="https://image.sybblogs.fun/img-common/202311172017993.png" alt="判断结点的边" style="zoom:25%;" />

  1. 对于邻接矩阵存储无向图

     找邻接点的下一个邻接点只需要扫描当前矩阵行的下一个为`1`的顶点即可。时间复杂度是$O(1)\sim O(|V|)$。

  2. 对于邻接表存储无向图

     只需要找到当前顶点`*first`指向的第二个边结点即可。只需要$O(1)$时间复杂度。

  3. 邻接矩阵和邻接表存储有向图分析同上。

- $GetEdgeValue(G,x,y)$： 获取图`G`中边`(x, y)`或`<x, y>`对应的权值。

  $SetEdgeValue(G,x,v)$： 设置图`G`中边`(x, y)`或`<x, y>`对应的权值为`v`。

  这两个操作同上<a href="#id1">$Adjacent(G,x,y)$</a>，其核心在于找边

此外，还有图的遍历算法，包括深度优先遍历和广度优先遍历。

## 4. 图的广度优先搜索

树的广度优先搜索是层次遍历。图的广度优先搜索和树的类似。如下无向图：

<img src="https://image.sybblogs.fun/img-common/202311261525355.png" alt="无向图的广度优先搜索" style="zoom:25%;" />

从顶点`2`出发，可以遍历到顶点`1`和顶点`6`，接着再根据顶点`1`和`6`找到其他顶点，即`5,3,7`三个顶点。接着再从这三个顶点出发找到更下一层的`4,8`两个顶点。这个过程和树很类似。两个结构对比如下：

<img src="https://image.sybblogs.fun/img-common/202311261531027.png" alt="树和图BFS区别" style="zoom:25%;" />

树搜索不存在"回路"，搜索相邻的结点时，不可能搜到已经访问过的结点。树BFS算法步骤如下：
①若树非空，则根节点入队
②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
③重复②直到队列为空

图在搜索相邻的顶点时，有可能搜到已经访问过的顶点。如上无向图，通过`6`顶点可以访问到`2,3,7`三个顶点，但此时`2`结点已经访问过了，仍会再次访问。解决方法也很简单，只需要给各个结点一个标记，来标记结点有没有被访问即可。

### 4.1 图的BFS实现

图的BFS算法如下：<a id="2-4.1-1"></a>

1. 找到与一个顶点相邻的所有顶点
2. 标记哪些顶点被访问过
3. 需要一个辅助队列

- `FirstNeighbor(G,x)`：求图G中顶点$x$的第一个邻接点，若有则返回顶点号。若$x$没有邻接点或图中不存在$x$，则返回$-1$。
- `NextNeighbor(G,x,y)`：假设图G中顶点$y$是顶点$x$的一个邻接点，返回除$y$之外顶点$x$的下一个邻接点的顶点号，若$y$是$x$的最后一个邻接点，则返回$-1$。
- 定义一个`bool visited[MAX_VERTEX_NUM];`记录访问标记数组，初始值全为`false`。

实现代码如下：

~~~c
bool visited[MAX_VERTEX_NUM]; // 访问标记数组.
//广度优先遍历
void BFS(Graph G,int v){	//从顶点v出发，广度优先遍历图G
    visit(v);				//访问初始顶点v
    visited[v]=TRUE;		//对v做已访问标记
    Enqueue(Q,v);			//顶点v入队列Q
    while(!isEmpty(Q)){
        v=FrontQueue();
        DeQueue(Q,v); 		//顶点v出队列
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
            //检测v所有邻接点
            if(!visited[w] ){		//w为v的尚未访问的邻接顶点
                visit(w);			//访问顶点W
                visited[w]=TRUE;	//对w做已访问标记
                EnQueue(Q,w); 		//顶点w入队列
            }
    }
}
~~~

图存储结构：

<img src="https://image.sybblogs.fun/img-common/202311261730033.png" alt="图BFS代码原理" style="zoom:25%;" />

`visited`数组：

|         |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| visited | false | false | false | false | false | false | false | false |

假如先从`2`顶点开始遍历：

1. 先访问`2`号顶点，再将`2`号顶点对应的`visited`数组设为`true`

   |         |   1   |  2   |   3   |   4   |   5   |   6   |   7   |   8   |
   | :-----: | :---: | :--: | :---: | :---: | :---: | :---: | :---: | :---: |
   | visited | false | true | false | false | false | false | false | false |

2. 之后将`2`号顶点入队，进入`while`循环，判断队列是否为`NULL`，不为`NULL`将队中`2`顶点出队，进入`for`循环

3. `for`循环中先获取与`2`顶点相邻顶点`1`，访问`1`号顶点后将对应`visited`数组设为`true`，再入队。`NextNeighbor(G,v,w)`再获取邻接点下一个顶点即`6`，同样，访问后数组设置为`true`后再入队。此时`6`顶点已经为`2`顶点最后一个邻接点，结束循环，进入外层`while`循环。

   |         |  1   |  2   |   3   |   4   |   5   |  6   |   7   |   8   |
   | :-----: | :--: | :--: | :---: | :---: | :---: | :--: | :---: | :---: |
   | visited | true | true | false | false | false | true | false | false |

4. 此时队列为：`1,6`

5. 循环1，2，3步，得到该无向图的BFS序列为：2，1，6，5，3，7，4，8

同样，从顶点`1`出发得到的广度优先序列为：1，2，5，6，3，7，4，8

对于BFS算法，如果图的存储结构不一样，得到的遍历序列也可能不一样。但对于邻接矩阵来说，它的存储方式是唯一的，所以其BFS遍历顶点其他邻接点时，一定是从小到大遍历。	

### 4.2 图BFS遍历非连通图

有以下非连通图：

<img src="https://image.sybblogs.fun/img-common/202311262023603.png" alt="BFS非连通图" style="zoom:25%;" />

上面的代码不能访问`9,10,11`顶点。这个问题可以通过`visited`数组解决。解决代码如下：

~~~c
bool visited[MAX_VERTEX_NUM]; 	// 访问标记数组.
void BFSTraverse(Graph G){ 		//对图G进行广度优先遍历
    for(i=0; i<G.vexnum;++i)
        visited[i]=FALSE;		//访问标记数组初始化
    InitQueue(Q);				//初始化辅助队列Q
    for(i=1;i<G.vexnum;++i)		//从1号顶点开始遍历
        if(!visited[i])			//对每个连通分量调用一次BFS
            BFS(G,i);			//vi未访问过，从vi开始BFS
}

//广度优先遍历
void BFS(Graph G,int v){	//从顶点v出发，广度优先遍历图G
    visit(v);				//访问初始顶点v
    visited[v]=TRUE;		//对v做已访问标记
    Enqueue(Q,v);			//顶点v入队列Q
    while(!isEmpty(Q)){
        DeQueue(Q,v); 		//顶点v出队列
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
            //检测v所有邻接点
            if(!visited [w] ){		//w为v的尚未访问的邻接顶点
                visit(w);			//访问顶点W
                visited[w]=TRUE;	//对w做已访问标记
                EnQueue(Q,w); 		//顶点w入队列
            }
    }
}
~~~

以上代码在`BFSTraverse`函数中会先从`1`号顶点开始遍历，对每个连通分量检查是否访问，没有访问则调用BFS。

假如从`1`号结点开始访问，`BFSTraverse`函数第一次调用BFS会遍历`1~8`顶点，此时`visited`数组如下：

<img src="https://image.sybblogs.fun/img-common/202311262033958.png" alt="非连通图遍历" style="zoom:25%;" />

接着`BFSTraverse`函数会一直遍历直到发现没有访问的顶点`9`，接着从`9`号顶点开始继续调用BFS，之后BFS函数会访问`10,11`顶点。此时所有顶点访问完毕，结束循环。

==结论==：对于无向图，调用BFS函数的次数$=$连通分量数。

### 4.3 图的BFS算法复杂度分析

<img src="https://image.sybblogs.fun/img-common/202311262053118.png" alt="BFS算法复杂度分析" style="zoom:25%;" />

- 空间复杂度:最坏情况，辅助队列大小为$O(|V|)$

- 时间复杂度：

  - 邻接矩阵存储的图：

    访问$|V|$个顶点需要$O(|V|)$的时间。而查找每个顶点的邻接点都需要$O(|V|)$的时间，而总共有$|V|$个顶点时间复杂度$= O(|V|^2)$

  - 邻接表存储的图：

    访问$|V|$个顶点需要$O(|V|)$的时间查。找各个顶点的邻接点共需要$O(|E|)$的时间，时间复杂度$= O(|M|+|E|)$

这里显然不能分析BFS函数最深层的`for`循环来确定程序的复杂度，因为假设一个图所有顶点之间都没有边相连，则此时BFS深层的`for`循环执行$0$次。事实上BFS函数调用此时为$O(|V|)$次。

### 4.4 广度优先生成树与森林

#### 广度优先生成树

<img src="https://image.sybblogs.fun/img-common/202311262100015.png" alt="广度优先生成树" style="zoom:25%;" />

上面BFS遍历序列中，红色的边表示顶点第一次被访问的时候是从哪个边过去的。如上面`4`号顶点第一次访问时候是从`3`号顶点的边过去的。用这种方式，$n$个顶点的图要标红$n-1$条边。

如果把上面没有标红边去掉，则得到以下图：

<img src="https://image.sybblogs.fun/img-common/202311262103846.png" alt="广度优先生成树2" style="zoom:25%;" />

这个图实际上变为了树，因为里面已经没有回路出现了。这个树就是广度优先生成树。

转换成生成树如下：

<img src="https://image.sybblogs.fun/img-common/202311262115167.png" alt="广度优先生成树3" style="zoom:25%;" />

同样的，通过邻接表存储的图生成树不唯一。

#### 广度优先生成森林

<img src="https://image.sybblogs.fun/img-common/202311262122137.png" alt="广度优先生成森林" style="zoom:25%;" />

同样对非连通图的广度优先遍历，可得到广度优先生成森林：

<img src="https://image.sybblogs.fun/img-common/202311262123529.png" alt="广度优先生成森林2" style="zoom:25%;" />

## 5. 图的深度优先搜索

图的DFS与树一致，树的DFS是用先根遍历实现的：

~~~c
//树的先根遍历
void Pre0rder(TreeNode *R) {
    if (R!=NULL){
        visit(R) 				//访问根节点
            while(R还有下一个子树T)
                Pre0rder(T);	//先根遍历下一棵子树 
    }
}
~~~

<img src="https://image.sybblogs.fun/img-common/202311271406308.png" alt="树的先根遍历" style="zoom:25%;" />

以上树的先根遍历序列是：1，2，5，6，3，4，7，8

### 5.1 图的DFS实现

由于树的特性树的遍历新找到的结点肯定是没被访问过的结点。但图遍历的新结点有可能是已经被访问的。所以同广度优先搜索一样，同样要设置一个`visited`数组标记顶点有没有访问过。

<img src="https://image.sybblogs.fun/img-common/202311271410335.png" alt="图的DFS" style="zoom:25%;" />

DFS遍历上面无向图，需要先初始化`visited`数组为`false`：

|         |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| visited | false | false | false | false | false | false | false | false |

代码实现如下：

~~~c
bool visited [MAX_VERTEX_NUM]; 		// 访问标记数组
void DFS(Graph G,int v){			//从顶点v出发，深度优先遍历图G
    visit(v);						//访问顶点v
    visited[v]=TRUE;				//设已访问标记
    for(w=FirstNeighbor(G,v);w>=0;w=nextNeighbor(G,v,w))
        if(!visited[w]){ 			//w为u的尚未访问的邻接顶点
            DFS(G,w);
        }
}
~~~

代码执行步骤如下：

1. 假设从`2`号顶点出发，先访问`2`号，再将其对应`visited`数组设置为`true`；接着进入`for`循环内部，先获取`2`号顶点下一个邻接点`1`，`1`号邻接点显然没有被访问，进入递归函数`DFS`，递归遍历`1`号顶点。

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271422796.png" alt="图的DFS步骤1" style="zoom: 50%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271422086.png" alt="图的DFS步骤2" style="zoom:25%;" />

2. 重复执行第一步操作，在进入`for`循环后获取`1`号邻接点`2`，`2`顶点已经访问，所以不会进入递归，再和`1`号邻接的点为`5`，`5`号顶点进入递归

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271425312.png" alt="图的DFS步骤3" style="zoom:25%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271425344.png" alt="图的DFS步骤4" style="zoom:25%;" />

3. 重复第一步操作，`5`号顶点访问完毕后，由于没有邻接点，本层递归执行结束，依次出栈：由于`1`号顶点`5`顶点已经是最后一个邻接点，所以`1`号顶点出栈；`2`号顶点已经处理了第一个邻接点，接着进入第二次循环处理邻接点`6`，`6`顶点没有访问进入递归。

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271427105.png" alt="图的DFS步骤5" style="zoom:25%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271430902.png" alt="图的DFS步骤6" style="zoom: 50%;" />

4. 访问`6`号顶点并设置`visited`数组后，进入`for`循环。第一个邻接点是`2`，已经访问过，接着访问下一个邻接点`3`，顶点`3`没有被访问过，同样进入递归。

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271433600.png" alt="图的DFS步骤7" style="zoom:25%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271433952.png" alt="图的DFS步骤8" style="zoom:25%;" />

5. 访问`3`号顶点设置`visited`数组后，进入`for`循环。其第一个邻接点是`4`号顶点，没有被访问进入递归。

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271435894.png" alt="图的DFS步骤9" style="zoom:25%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271435774.png" alt="图的DFS步骤10" style="zoom:25%;" />

6. 访问完`4`号顶点后，由于其第一个邻接点`3`已经被访问过，所以访问下一个邻接点`7`，进入递归。

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271437175.png" alt="图的DFS步骤11" style="zoom:25%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271438913.png" alt="图的DFS步骤12" style="zoom:25%;" />

7. 访问完`7`号顶点后，与`7`相邻的顶点只有`8`没有被访问，进入递归

   `visited`数组：

   <img src="https://image.sybblogs.fun/img-common/202311271439473.png" alt="图的DFS步骤13" style="zoom:25%;" />

   函数调用栈：

   <img src="https://image.sybblogs.fun/img-common/202311271439651.png" alt="图的DFS步骤14" style="zoom:25%;" />

8. 在访问完`8`号顶点后，由于与之相邻的邻接点都已经被访问过，所以循环结束，本次递归结束，依次出栈：`7`号顶点与之相邻的顶点都被访问完，同样结束出栈；其他层递归过程类似，全部出栈。

所以从`2`号顶点出发得到的DFS序列为：2，1，5，6，3，4，7，8

### 5.2 图DFS遍历非连通图

有以下非连通图：

<img src="https://image.sybblogs.fun/img-common/202311262023603.png" alt="BFS非连通图" style="zoom:25%;" />

上面的代码并不能访问`9,10,11`顶点。这个问题可以通过`visited`数组解决。解决代码如下：

~~~c
bool visited[MAX_VERTEX_NUM];		//访问标记数组
void DFSTraverse(Graph G){			//对图G进行深度优先遍历
    for(v=0; v<G.vexnum; ++v)
        visited[v]=FALSE;			//初始化已访问标记数据
    for(v=0;v<G.vexnum; ++v)		//本代码中是从v=0开始遍历
        if(!visited[v])
            DFS(G,v);
}
void DFS(Graph G,int v){			//从顶点v出发，深度优先遍历图G
    visit(v);						//访问顶点v
    visited [v]=TRUE;				//设已访问标记
    for(w=FirstNeighbor(G,v);W>=0;w=NextNeighor(G,v,w))
        if(!visited[w]){ 			//w为u的尚未访问的邻接顶点
            DFS(G,w);
        }
}
~~~

以上代码在`DFSTraverse`函数中会先从`1`号顶点开始遍历，对每个连通分量检查是否访问，没有访问则调用DFS。

假如从`1`号结点开始访问，`DFSTraverse`函数第一次调用DFS会遍历`1~8`顶点，此时`visited`数组如下：

<img src="https://image.sybblogs.fun/img-common/202311262033958.png" alt="非连通图遍历" style="zoom:25%;" />

接着`DFSTraverse`函数会一直遍历直到发现没有访问的顶点`9`，接着从`9`号顶点开始继续调用DFS，之后DFS函数会访问`10,11`顶点。此时所有顶点访问完毕，结束循环。

其他顶点出发得到的遍历序列(邻接表存储不唯一)：

从`2`出发的深度优先遍历序列：2，1，5，6，3，4，7，8

从`3`出发的深度优先遍历序列：3，4，7，6，2，1，5，8

从`1`出发的深度优先遍历序列：1，2，6，3，4，7，8，5

### 5.3 图的DFS算法复杂度分析

- 空间复杂度：来自函数调用栈，最坏情况，递归深度为$O(|V|)$

- 时间复杂度：无论是邻接矩阵还是邻接表其时间复杂度计算方法都可以归结为：访问各结点所需时间$+$探索各条边所需时间

  - 邻接矩阵存储的图：

    访问$|V|$个顶点需要$O(|N|)$的时间，查找每个顶点的邻接点都需要$O(|V|)$的时间，而总共有$|V|$个顶点所以时间复杂度$=O(|V|^2)$

  - 邻接表存储的图：
    访问$|V|$个顶点需要$O(|V|)$的时间，查找各个顶点的邻接点共需要$O(|E|)$的时间，时间复杂度$=O(|V|+|E|)$

### 5.4 深度优先生成树与森林

- 深度优先生成树

  如果通过某一条边找到了一个还没有被访问的顶点，那么这条边标记为红色，上面的DFS遍历后标记如下：

  <img src="file://C:/Users/Acid/OneDrive/%E5%9B%BE%E7%89%87/%E6%9C%AC%E6%9C%BA%E7%85%A7%E7%89%87/408/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91.png?lastModify=1701066820" alt="深度优先生成树" style="zoom:25%;" />

  去掉没有标记红色的边，得到的就是一个没有回路的无向图，此时可以转换为树，这个树就被称为深度优先生成树。

  <img src="file://C:/Users/Acid/OneDrive/%E5%9B%BE%E7%89%87/%E6%9C%AC%E6%9C%BA%E7%85%A7%E7%89%87/408/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%912.png?lastModify=1701066820" alt="深度优先生成树2" style="zoom:25%;" />

  同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一， 深度优先生成树也唯一

  同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一

- 深度优先生成森林

  <img src="https://image.sybblogs.fun/img-common/202311271511015.png" alt="深度优先生成森林" style="zoom:25%;" />

  同样对非连通图的深度优先遍历，可得到深度优先生成森林：

  <img src="https://image.sybblogs.fun/img-common/202311271513893.png" alt="深度优先生成森林2" style="zoom:25%;" />

### 5.5 图的遍历与图的连通性

- 无向图：

  对无向图进行`BFS/DFS`遍历，调用`BFS/DFS`函数的次数=连通分量数

  而对于连通图，只需调用1次`BFS/DFS`。

  对有向图进行BFS/DFS遍历 调用BFS/DFS函数的次数要具体问题具体分析 若起始顶点到其他各顶点都有路径, 则只需调用1次 BFS/DFS函数

- 有向图：

  对有向图进行`BFS/DFS`遍历，调用`BFS/DFS`函数的次数要具体问题具体分析：
  ①若起始顶点到其他各顶点都有路径，则只需调用$1$次`BFS/DFS`函数
  ②对于强连通图，从任一结点出发都只需调用$1$次`BFS/DFS`

  [强连通图：]()

  <img src="https://image.sybblogs.fun/img-common/202311271520284.png" alt="强连通图1" style="zoom:25%;" />

## 6. 图的应用

### 6.1 最小生成树

前面介绍过<a href="#2-1-1">生成树</a>的概念。生成树的概念是：包含图中全部顶点的一个极小连通子图。边要尽可能的少，但要保持连通。

定义是：对于一个带权连通无向图$G=(V, E)$，生成树不同，每棵树的权(即树中所有边.上的权值之和)也可能不同。设$R$为$G$的所有生成树的集合，若$T$为$R$中边的权值之和最小的生成树，则$T$称为$G$的最小生成树(Minimum-Spanning-Tree, MST)。

有以下无向图：

<img src="https://image.sybblogs.fun/img-common/202311271530257.png" alt="最小代价树" style="zoom:25%;" />

P城要进行道路规划。道路规划要求：所有地方都连通，且成本尽可能的低。

图中边上的数字是修一条路所需成本。所以最小生成树就是一颗边上权之和最小的树。

最小生成树特点：

1. 最小生成树可以有多个。但边的权值之和总是唯一且最小的。
2. 最小生成树的边数$=$顶点数$-1$。砍掉一条则不连通，增加一条边则会出现回路
3. 如果一个连通图本身就是一棵树，则其最小生成树就是它本身
4. 只有连通图才有生成树，非连通图只有生成森林

#### 普利姆(Prim)算法

算法核心：

从某一个顶点开始构建生成树；

每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。

上图最小生成树生成方式如下：

1. 先从`P城`开始，与之连通的边权值最小的为`1`，即$P城——学校$。

   <img src="https://image.sybblogs.fun/img-common/202311272018843.png" alt="最小代价树思路步骤1" style="zoom:25%;" />

2. 接着能和$P城——学校$，相连的最小边为`4`，即`矿场`和`渔村`，两个选一个$P城——矿场$。

   <img src="https://image.sybblogs.fun/img-common/202311272020683.png" alt="最小代价树思路步骤2" style="zoom:25%;" />

3. 接着找能和$P城——学校——矿场$相连的最小边，为`2`，即$矿场——渔村$

   <img src="https://image.sybblogs.fun/img-common/202311272023994.png" alt="最小代价树思路步骤3" style="zoom:25%;" />

4. 找能和$P城——学校——矿场——渔村$相连，最小边为`5`，即$农场——P城$

   <img src="https://image.sybblogs.fun/img-common/202311272024377.png" alt="最小代价树思路步骤4" style="zoom:33%;" />

5. 最后能与$P城——学校——矿场——渔村——农场$相连的最小边为`3`，即$农场——电站$

   <img src="https://image.sybblogs.fun/img-common/202311272026139.png" alt="最小代价树思路步骤5" style="zoom:25%;" />

如果在第2步时选$P城——渔村$，最后的最小生成树权值和仍为`15`：

<img src="https://image.sybblogs.fun/img-common/202311272031025.png" alt="最小代价树思路步骤6" style="zoom:25%;" />

代码实现思路如下：

<img src="https://image.sybblogs.fun/img-common/202311272129464.png" alt="最小生成树的Prim算法实现思想" style="zoom:33%;" />

初始从$V_0$开始创建两个数组：

<img src="https://image.sybblogs.fun/img-common/202311272130647.png" alt="最小生成树的Prim算法实现思想1" style="zoom: 25%;" />

由于初始从$V_0$开始，所以刚开始`isJoin`中$V_0$对应标记为`true`(√)。`lowCost`数组中由于$V_4$和$V_5$没有直接与$V_0$相连的边，故权值设置为$\infty$。

1. 第1轮：循环遍历所有个结点，找到顶点对应`lowCast`值最低的，且还没加入树的顶点。显然$V_3$的`lowCoast`值最低，将其与$V_0$连接，`isJoin`的$V_3$标记位`true`。

   <img src="https://image.sybblogs.fun/img-common/202311272137268.png" alt="最小生成树的Prim算法实现思想2" style="zoom:25%;" />

   <img src="https://image.sybblogs.fun/img-common/202311272139631.png" alt="最小生成树的Prim算法实现思想3" style="zoom: 25%;" />

   同时再次循环遍历，更新还没加入的各个顶点的`lowCast`值。还没有连接顶点是$V_1$，$V_2$，$V_4$和$V_5$。连接$V_0$和$V_3$后，剩下未连接顶点最小权值发生变化。具体做法是检查未连接顶点与新连接的顶点$V_3$之间有没有边，有的话对比是否比$V_0$边上的权值更下。$V_1$到$V_3$权值变为`5`，$V_2$到$V_4$变为`4`，$V_4$和$V_5$变为`6`和`4`。

   变化后的数组如下：

   <img src="https://image.sybblogs.fun/img-common/202311272143075.png" alt="最小生成树的Prim算法实现思想4" style="zoom:25%;" />

2. 第二轮循环同第一轮，先找到顶点对应`lowCast`值最低的，且还没加入树的顶点。$V_2$号顶点最低，权值为`4`，将其加入到$V_0——V_3$树中。

   <img src="https://image.sybblogs.fun/img-common/202311272145109.png" alt="最小生成树的Prim算法实现思想5" style="zoom: 25%;" />

   <img src="https://image.sybblogs.fun/img-common/202311272145396.png" alt="最小生成树的Prim算法实现思想6" style="zoom:25%;" />

   再次循环遍历，更新还没加入的各个顶点的`lowCast`值。新加入的$V_2$只有$V_5$与其有边，且$V_5$与$V_2$边权为`2`比$V_5——V_3$边的权`4`更小，所以更新`lowCast`与$V_5$对应的值改为`2`：

   <img src="https://image.sybblogs.fun/img-common/202311272150998.png" alt="最小生成树的Prim算法实现思想7" style="zoom:25%;" />

3. 第三轮循环继续之前操作。

#### 克鲁斯卡尔(Kruskal)算法

算法核心：

每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)，直到所有结点都连通。

用Kruskal得到上图最小生成树方式如下：

1. 先找到权值最小的边，为`1`，这条边两边顶点是`学校`，`P城市`且没有连通，连通这两个顶点

   <img src="https://image.sybblogs.fun/img-common/202311272117469.png" alt="最小代价树思路步骤7" style="zoom:25%;" />

2. 接着在剩下边中找权值最小的，即`2`，两边顶点是`矿场`和`渔场`且没有连通，连接这两个点

   <img src="https://image.sybblogs.fun/img-common/202311272119799.png" alt="最小代价树思路步骤8" style="zoom:33%;" />

3. 剩下边中最小的是`3`，两边顶点是`农场`和`电站`，且没有连通

   <img src="https://image.sybblogs.fun/img-common/202311272120691.png" alt="最小代价树思路步骤9" style="zoom:25%;" />

4. 接着权值最小的是`4`，两个为`4`的边任意选一条即可

   <img src="https://image.sybblogs.fun/img-common/202311272122351.png" alt="最小代价树思路步骤10" style="zoom:33%;" />

5. 剩余权值最小的边是`4`，但由于`矿场`已经连通`P城`，所以跳过。接着选剩下边中最小的`5`将`农场`和`P城`连接

   <img src="https://image.sybblogs.fun/img-common/202311272125633.png" alt="最小代价树思路步骤11" style="zoom:33%;" />

代码实现思路如下：

<img src="https://image.sybblogs.fun/img-common/202311272154273.png" alt="Kruskal最下生成树算法思路1" style="zoom:33%;" />

首先初始化将各条边按权值排序

<img src="https://image.sybblogs.fun/img-common/202311272153728.png" alt="Kruskal最下生成树算法思路" style="zoom:25%;" />

1. 第1轮：检查第$1$条边的两个顶点是否连通(是否属于同一个集合，可以参考之间的<a href="#1-1">并查集</a>)

   第一个边的权值是`1`，连接的是$V_0$和$V_3$两个顶点，通过并查集查询两个顶点不是在同一集合中，则将其连接。

   <img src="https://image.sybblogs.fun/img-common/202311272157924.png" alt="Kruskal最下生成树算法思路2" style="zoom:33%;" />

   连接后将$V_0$和$V_3$合并为一个集合中

2. 第二个边的权值是`2`，连接的是$V_2$和$V_5$两个顶点，通过并查集查询两个顶点不是在同一集合中，则将其连接连，接后将$V_2$和$V_5$合并为一个集合中。

   <img src="https://image.sybblogs.fun/img-common/202311272158886.png" alt="Kruskal最下生成树算法思路3" style="zoom:33%;" />

3. 第三个边的权值是`3`，连接的是$V_1$和$V_4$两个顶点，通过并查集查询两个顶点不是在同一集合中，则将其连接连，接后将$V_1$和$V_4$合并为一个集合中。

   <img src="https://image.sybblogs.fun/img-common/202311272159349.png" alt="Kruskal最下生成树算法思路4" style="zoom:33%;" />

4. 第四个边的权值是`4`，连接的是$V_2$和$V_3$两个顶点，通过并查集查询两个顶点不是在同一集合中，则将其连接连，接后将$V_2$和$V_3$合并为一个集合中。

   <img src="https://image.sybblogs.fun/img-common/202311272200164.png" alt="Kruskal最下生成树算法思路5" style="zoom:33%;" />

5. 第五个边的权值是`4`，连接的是$V_3$和$V_5$两个顶点，通过并查集查询两个顶点已经在同一集合中，则跳过

6. 后面同上。

#### 两个算法比较

- 普利姆(Prim)算法：

  时间复杂度：$O(|V|^2)$，适合用于边稠密图。

- 克鲁斯卡尔(Kruskal)算法：

  时间复杂度: $O(|E|\log2|E|)$，适合用于边稀疏图。

### 6.2 最短路径问题

有以下无向图：

<img src="https://image.sybblogs.fun/img-common/202311272204451.png" alt="最短路径问题" style="zoom:33%;" />

第一个问题是：

`G港`是个物流集散中心，经常需要往各个城市运东西，求运送距离最近路径。这种问题可以归类为单源(从一个顶点出发)最短路径问题。

解决方法用：BFS算法(无权图)、==Dijkstra算法==(带权图、无权图)解决。

第二个问题是：

各个城市之间也需要互相往来，相互之间怎么走距离最近?这类问题归类为：每对顶点间的最短路径。

解决方法是：Floyd算法(带权图、无权图)。

#### BFS算法解决最短路径

有以下无权的无向图：

<img src="https://image.sybblogs.fun/img-common/202311272209856.png" alt="BFS解决最短路径问题" style="zoom:25%;" />

注：无权图可以视为一种特殊的带权图，只是每条边的权值都为$1$.

假设从顶点`2`出发BFS算法遍历过程参考<a href="#2-4.1-1">图的BFS实现</a>。通过BFS遍历便可以得到`2`顶点到各个顶点的距离。

修改BFS算法的`visit(w)`方法：

~~~c
void BFS_MIN_Distance(Graph G,int u){
    //d[i]表示从u到i结点的最短路径
    for( i=0;i<G.vexnum;++i){
        d[i]=0x3f3f3f3f; //初始化路径长度为无穷大
        path[i]=-1; //最短路径从哪个顶点过来
    }
    d[u]=0;
    visited[v]=TRUE;		//对v做已访问标记
    Enqueue(Q,v);			//顶点v入队列Q
    while(!isEmpty(Q)){
        v=DeQueue(Q,v); 		//顶点v出队列
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
            //检测v所有邻接点
            if(!visited [w] ){		//w为v的尚未访问的邻接顶点
                d[w]=d[u]+1;		//路径长度加1	
                path[w]=u;			//最短路径应从u到w	
                visited[w]=TRUE;	//对w做已访问标记
                EnQueue(Q,w); 		//顶点w入队列
            }
    }
}
~~~

第12行和12行修改后的代码。其中`d[]`数组是存放顶点`w`到遍历初始顶点`u`之间的长度；`path[]`数组作用存放当前遍历顶点的前一个顶点位置。两个数组初始化如下：

<img src="https://image.sybblogs.fun/img-common/202311272216890.png" alt="BFS解决最短路径问题1" style="zoom:25%;" />

执行步骤如下：

1. 假设从顶点`u=2`开始遍历，会先将顶点`2`的`path`对应的值设置为`0`，接着`visited`设置为`true`，并将`2`号顶点入队。

2. 遍历`2`顶点的邻接点为`1`和`6`，访问这两个顶点时，由于`d[u]=0`，所以这两个顶点的`d[w]=d[u]+1=1`，其前一个顶点`2`，故`path[w]=u`

3. 同样操作同上，执行完所有遍历操作后得到的`d[]`和`path[]`数组如下：

   <img src="https://image.sybblogs.fun/img-common/202311272227595.png" alt="BFS解决最短路径问题2" style="zoom:25%;" />

求得`d[]`和`path[]`数组后使用：假设要找`2`顶点到`8`号顶点的路径：

`2`到`8`的最短路径长度$=d[8]=3$
通过`path`数组可知，`2`到`8`的最短路径为: $8\leftarrow7\leftarrow6\leftarrow2$

同时通过BFS得到的广度优先生成树，其树每个结点在第几层也直接反应了，其到初始顶点的距离。

<img src="https://image.sybblogs.fun/img-common/202311272231901.png" alt="BFS解决最短路径问题3" style="zoom:25%;" />

BFS缺点：只能用于不带权的图，或所有边的权值都相同的图。

#### Dijkstra算法解决最短路径

可以解决带权图单源问题(从一点到另外几个点的最短路径)。其实现方法和`Prim`算法十分相似。

求下图从$V_0$点到其他顶点的最短路径。

<img src="https://image.sybblogs.fun/img-common/202312041602419.png" alt="dijkstra算法" style="zoom:25%;" />

==其实核心思路是：==起始顶点初始化后，找剩余顶点中`dist`值最小的顶点$V_i$。$V_i$将其`final`值设置为`true`，接着遍历其所有邻接点中`final=false `的顶点。之后判断从当前顶点$V_i$到各个邻接点权值是否小于邻接点原本的`dist`值，小于则替换该值，并将`path`值设置为$V_i$的位置即`path[]=i`。

初始化：从$V_0$开始，初始化三个数组信息如下：

1. 首先从$V_0$开始，由于$V_0$前面没有顶点，所以`path[0]=-1`。$V_0$邻边是$V_1$和$V_4$，所以将初始化`dist[1]=10`和`dist[4]=5`，前驱`path[1]=0`，`path[4]=0`。而另外两个点$V_1$和$V_4$没有与$V_0$连接的边所以`dist[2]`和`dist[3]`为$\infty$，`path[2]`和`path[3]`为`-1`。

   `final[5]`：标记各个顶点是否已经找到最短路径。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | true  | false | false | false | false |

   `dist[5]`：最短路径的长度。

   | $V_0$ | $V_1$ |  $V_2$   |  $V_3$   | $V_4$ |
   | :---: | :---: | :------: | :------: | :---: |
   |   0   |  10   | $\infty$ | $\infty$ |   5   |

   `path[5]`：路径上的前驱

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | $-1$  |  $0$  | $-1$  | $-1$  |  $0$  |

循环执行以下步骤：

1. 第$1$轮：循环遍历所有结点，找到还没确定最短路径，且`dist`最小的顶点$V_i$，令`final[i]=ture`。即：

   首先找到`final`数组不为`true`，并且`dist`数组值最小的点$V_i=V_4$；

2. 找到$V_4$后先将其`final[4]=true`，表明这个顶点已经找到最短路径。其最短路径是`dist[4]=5`，其直接前驱是`path[4]=0`即$V_0$​。检查所有邻接自$V_i$的顶点，若其`final`值为`false`，则更新`dist`和`path`信息。即：

   检查和$V_4$相连的顶点$V_1$、$V_2$和$V_3$这几个顶点中`final`为`false`的点从$V_4$过来有没有可能比之前的`dist`值更小。$V_1$原本`dist[1]=10`，但从$V_4$`dist[4]=5`到到$V_1$的值为$8$小于当前`dist[1]=10`，所以修改$V_1$`dist[1]=8`，`path[1]=4`。同样$V_2$和$V_3$从$V_4$点经过路径长度为`14`和`7`，小于之前的$\infty$，所以`dist[2]=14`，`dist[3]=7`，`path[2]=4`，`path[3]=4`。处理完后数组信息如下：

   `final[5]`：标记各个顶点是否已经找到最短路径。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | true  | false | false | false | true  |

   `dist[5]`：最短路径的长度。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   |   0   |   8   |  14   |   7   |   5   |

   `path[5]`：路径上的前驱

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | $-1$  |   4   |   4   |   4   |  $0$  |

3. 第二轮循环同上。剩下`final`数组不为`true`，并且`dist`数组值最小的点$V_i=V_3$；先将其`final[4]=true`，表明这个顶点已经找到最短路径。其最短路径是`dist[3]=7`，其直接前驱是`path[3]=4`即$V_4$。接着与$V_3$邻接点是$V_0$和$V_2$，但$V_0$的`final`值为`true`，所以跳过直接修改$V_2$，若从$V_3$点到$V_2$，所需的权值为`13`，小于`dsit[2]=14`，所以将$V_2$​的`dist[2]=13`，`path[2]=3`。处理完后数组信息如下：

   `final[5]`：标记各个顶点是否已经找到最短路径。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | true  | false | false | true  | true  |

   `dist[5]`：最短路径的长度。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   |   0   |   8   |  13   |   7   |   5   |

   `path[5]`：路径上的前驱

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | $-1$  |   4   |   3   |   4   |  $0$  |

4. 第三轮，找剩下`final=flase`，且`dist`最小的顶点，为$V_1$。将其`fianl`值设置为`true`，并遍历其邻接点中`final`为`false`的邻接顶点，即$V_2$，从$V_1$到$V_2$的权值为`8+1=9`，小于$V_2$的`dist[2]=13`，故修改$V_2$​的`dist[2]=9`，`path[2]=1`。处理完后数组信息如下：

   `final[5]`：标记各个顶点是否已经找到最短路径。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | true  | true  | false | true  | true  |

   `dist[5]`：最短路径的长度。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   |   0   |   8   |   9   |   7   |   5   |

   `path[5]`：路径上的前驱

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | $-1$  |   4   |   1   |   4   |  $0$  |

5. 最后一轮处理只剩$V_2$​，将其`final`值设置为`true`即可。处理完后数组信息如下：

   `final[5]`：标记各个顶点是否已经找到最短路径。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | true  | true  | true  | true  | true  |

   `dist[5]`：最短路径的长度。

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   |   0   |   8   |   9   |   7   |   5   |

   `path[5]`：路径上的前驱

   | $V_0$ | $V_1$ | $V_2$ | $V_3$ | $V_4$ |
   | :---: | :---: | :---: | :---: | :---: |
   | $-1$  |   4   |   1   |   4   |  $0$  |

得到上面的数组使用方法如下：

从$V_0$到$V_2$的最短(带权)路径长度为：`dist[2]=9`，通过`path[]`数组可知，路径为：$V_0\rightarrow V_4\rightarrow V_1\rightarrow V_2$

代码实现思路如下：

若从$V_0$开始，令`final[0]=ture`；`dist[0]=0`；`path[0]=-1`。其余顶点`final[k]=false`；从起始顶点$V_0$到$k$顶点的长度，如果不存在连接的边，则设置为$\infty$或者为其它值：`dist[k]=arcs[0][k]`。没有和$V_0$相连的顶点设置为$-1$：
`path[k]=(arcs[0][k]==`$\infty$`)? -1:0`

$n-1$轮处理：循环比例所有顶点，找到还没有确定最短路径，且`dist`值最小的顶点$V_i$，令`final[i]=ture`。并检查所有邻接自$V_i$的顶点，对于邻接自$V_i$的顶点$V_j$，若`final[j]=false`且`dist[i]+arcs[i][j]<dist[j]`，则令`dist[j]=dist[i]+arcs[i][j]`；`path[j]=i`。

注意：`arcs[i][j]`表示$V_i$到$V_j$的弧的权值。

时间复杂度：循环遍历所有顶点，找到还没有确定最短路径，且`dist`最小的值，需要$O(n)$。而总共需要$n-1$轮处理，所以整个时间复杂度为：$O(n^2)$也即$O(|V|^2)$。

如果带权图中有带负权值的图：

<img src="https://image.sybblogs.fun/img-common/202312041913409.png" alt="dijkstra算法2" style="zoom:25%;" />

用Dijkstra算法得到的数组如下：

`final[3]`：标记各个顶点是否已经找到最短路径。

| $V_0$ | $V_1$ | $V_2$ |
| :---: | :---: | :---: |
| true  | true  | true  |

`dist[3]`：最短路径的长度。

| $V_0$ | $V_1$ | $V_2$ |
| :---: | :---: | :---: |
|   0   |  10   |   7   |

`path[3]`：路径上的前驱

| $V_0$ | $V_1$ | $V_2$ |
| :---: | :---: | :---: |
| $-1$  |   0   |   0   |

从$V_0$到$V_2$最短路径为`dist[2]=7`，但实际上如果从$V_0\rightarrow V_1\rightarrow V_2$，其路径长度为`10-(-5)=5`。故**Dijkstra算法不适用于有负权值的带权图**。

#### Floyd算法解决最短路径

可以求出每一对顶点之间的最短路径。其核心思想是使用动态规划思想，将问题的求解分为多个阶段。如：

对于$n$个顶点的图$G$，求任意一对顶点$V_i\rightarrow V_j$之间的最短路径可分为如下几个阶段:

1. 初始：不允许在其他顶点中转，最短路径是?
2. 若允许在$V_0$中转，最短路径是?
3. 若允许在$V_0$、$V_1$ 中转，最短路径是?
4. 若允许在$V_0$、$V_1$、$V_2$中转，最短路径是?
5. 若允许在$V_0$、$V_1$、 $V_2\cdots V_{n-1}$中转，最短路径是?

其执行代码如下：

~~~c
for(int k=0;k<n;k++){////考虑以k作为中转点
    for(int i=0; i<n; i++) {//遍历整个矩阵， i为行号，j为列号
        for (int j=0; j<n; j++){
            if (A[i][j]>A[i][k]+A[k][j]){//以k为中转点的路径是否比原先的路径更短
                A[i][j]=A[i][k]+A[k][j];//更新最短路径长度
                path[i][j]=k;//中转点
            }
        }
    }
}
~~~

求以下带权图每对顶点之间的最短路径：

<img src="https://image.sybblogs.fun/img-common/202312042047419.png" alt="floyd算法求最短路径" style="zoom: 25%;" />

<img src="https://image.sybblogs.fun/img-common/202312042048315.png" alt="floyd算法求最短路径2" style="zoom:25%;" />

1. 若以$V_0$为中转点，即$k=0$，此时没有一个点指向$V_0$所以没有一个点的路径需要更新。

2. 若允许在$V_0,V_1$处中转，以$V_1$为中转点，即$k=1$，$A[2][3]>A[2][1]+A[1][3]$，即顶点$V_2$到$V_1$，再从$V_1$到$V_3$的路径比$V_2$到$V_3$路径更短。此时修改$A[2][3]=2$且`path[2][3]=1`

   同时$A[2][4]>A[2][1]+A[1][4]$，即顶点$V_2$到$V_1$，再从$V_1$到$V_4$的路径比$V_2$到$V_4$路径更短。此时修改$A[2][4]=6$且`path[2][4]=1`修改后的数组如下：

   <img src="https://image.sybblogs.fun/img-common/202312042100015.png" alt="floyd算法求最短路径3" style="zoom:25%;" />

3. 若允许在$V_0,V_1,V_2$处中转，且以$V_2$为中转点，即$k=2$，$A[0][1]>A[0][2]+A[2][1]$，此时修改$A[0][1]=2$且`path[0][1]=2`

   同时，$A[0][3]>A[0][2]+A[2][3]$，此时修改$A[0][3]=3$且`path[0][3]=2`。注意此时$V_2$到$V_3$之间是没有路径的，但由于之前将$V_2$到$V_3$值最短路径做了修改，即$V_2\rightarrow V_1\rightarrow V_3$。所以这里默认在这个基础上$V_2$到$V_3$的是有路径的。

   接着$A[0][4]>A[0][2]+A[2][4]$，此时修改$A[0][4]=7$且`path[0][4]=2`。

   <img src="https://image.sybblogs.fun/img-common/202312042109959.png" alt="floyd算法求最短路径4" style="zoom:25%;" />

4. 若允许在$V_0,V_1,V_2,V_3$处中转，且以$V_3$为中转点，即$k=3$，$A[0][4]>A[0][3]+A[3][4]$，此时修改$A[0][4]=4$且`path[0][4]=3`

   同时，$A[1][4]>A[1][3]+A[3][4]$，此时修改$A[1][4]=2$且`path[1][4]=3`。

   接着$A[2][4]>A[2][3]+A[3][4]$，此时修改$A[2][4]=3$且`path[2][4]=3`。

   <img src="https://image.sybblogs.fun/img-common/202312042114459.png" alt="floyd算法求最短路径5" style="zoom:25%;" />

5. 当以$V_4$为中转点时，没有要修改的值。

使用上面两个数组方法：找$V_0$到$V_4$两个顶点的最短路径：$A[0][4]=4$。`path`数组找路径如下：

- $V_0\rightarrow V_4$
- $V_0\rightarrow V_3\rightarrow V_4$
- $V_0\rightarrow V_2\rightarrow V_3\rightarrow V_4$
- $V_0\rightarrow V_2\rightarrow V_1\rightarrow V_3\rightarrow V_4$

这个过程可以通过遍历`path[]`数组递归实现，代码实现如下：

~~~c
void printPath(int i,int j){
    if(path[i][j]==-1) cout<<i;
    else{
        printPath(i,path[i][j]);
        printPath(path[i][j],j);
    }
}
~~~

Floyd算法的事件复杂度是$O(n^3)$，所以一般情况下三阶矩阵情况多。并且**Floyd算法可以解决带负权值的带权图**。但Floyd算法不能解决带有**负权回路的图**。因为这种图可能没有最短路径。如下：

<img src="https://image.sybblogs.fun/img-common/202312042141140.png" alt="floyd算法求最短路径6" style="zoom:25%;" />

从图上可知有两条边的权值为`7<-9`，这样的图又形成了回路，走的越多权值越小。所以没有最短路径。

### 6.3 总结

<img src="https://image.sybblogs.fun/img-common/202312042145458.png" alt="最短路径问题总结" style="zoom:25%;" />

## 7. 有向无环图(DAG图)

有向无环图：若一个有向图中不存在环， 则称为有向无环图，简称DAG图(Directed Acyclic Graph)

<img src="https://image.sybblogs.fun/img-common/202312042148372.png" alt="有向无环图" style="zoom:25%;" />

### 7.1 DAG应用——有向无环图表达式

有向无环图表达式：有表达式$((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)$.其树形存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202312042229238.png" alt="有向无环图1" style="zoom: 25%;" />

这些树结点存在有重复的部分，我们可以将其合并：

<img src="https://image.sybblogs.fun/img-common/202312042231828.png" alt="有向无环图2" style="zoom:25%;" />

合并后的图是一个有向无环图。

具体步骤如下：

1. 把各个操作数不重复地排成一排
2. 标出各个运算符的生效顺序(先后顺序有点出入无所谓)
3. 按顺序加入运算符，注意分层
4. 自底向上逐层检查同层的运算符是否可以合体

有表达式(符号运算优先级已经标记，可不唯一)：

<img src="https://image.sybblogs.fun/img-common/202312042234689.png" alt="有向无环图表达式" style="zoom:25%;" />

- 先把表达式中操作数去重排列

  <img src="https://image.sybblogs.fun/img-common/202312042235282.png" alt="有向无环图表达式1" style="zoom:25%;" />

- 运算符连接操作数，但注意层次。如操作符需要用到下一层两个操作数运算结果，则这个操作符应该在操作数符号运算的上一层。

  <img src="https://image.sybblogs.fun/img-common/202312042238338.png" alt="有向无环图表达式2" style="zoom:25%;" />

- 倒数第二层右边三个加法都是$c+d$的操作，所以可以合并。

  <img src="https://image.sybblogs.fun/img-common/202312042241744.png" alt="有向无环图表达式3" style="zoom:25%;" />

  倒数第三层右边两个乘法都是对$(c+d)*e$的操作，所以可以合并。而再往上操作符都是单独的，所以不可能合并。故这个DAG图如下：

  <img src="https://image.sybblogs.fun/img-common/202312042243193.png" alt="有向无环图表达式4" style="zoom:25%;" />

如果运算顺序合理更改后，得到的DAG结点数同样和上面结点数一样都是$12$。

### 7.2 DAG应用——拓扑排序

`AOV`网(Activity On Vertex NetWork，用顶点表示活动的网)：用`DAG`图(有向无环图)表示一个工程。顶点表示活动，有向边$<V_i, V_j>$表示活动$V_i$必须先于活动$V_j$进行。注意`AOV`网不能有环路。

<img src="https://image.sybblogs.fun/img-common/202312052132065.png" alt="AOV网" style="zoom:25%;" />

这是一个表示"番茄炒蛋"工程的`AOV`网。上面`切番茄`有个入边，表示其执行这个步骤前要先执行入边对应的顶点，即`切番茄`前要`洗番茄`。

拓扑排序本质是：找到做事的先后顺序。拓扑排序定义：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：①每个顶点出现且只出现一次。②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点$B$到顶点$A$的路径。

上面项目可以先`准备厨具`也可以先`买菜`：

<img src="https://image.sybblogs.fun/img-common/202312052209081.png" alt="拓扑排序" style="zoom:25%;" />

接着`买菜`：

<img src="https://image.sybblogs.fun/img-common/202312052210835.png" alt="拓扑排序1" style="zoom:25%;" />

此时`洗番茄`或者`打鸡蛋`，这里选`洗番茄`：

<img src="https://image.sybblogs.fun/img-common/202312052211667.png" alt="拓扑排序2" style="zoom:25%;" />

之后`切番茄`也可以`打鸡蛋`：

<img src="https://image.sybblogs.fun/img-common/202312052212667.png" alt="拓扑排序3" style="zoom:25%;" />

之后的顺序就是：`打鸡蛋`、`下锅炒`、`吃`

所以这个工程的拓扑排序是：准备厨具、买菜、洗番茄、切番茄、打鸡蛋、下锅炒、吃

#### 拓扑排序代码实现

通过上面这个例子可以归纳处拓扑排序实现方式：

①从`AOV`网中选择一个没有前驱(入度为$0$)的顶点并输出。
②从网中删除该顶点和所有以它为起点的有向边。
③重复①和②直到当前的`AOV`网为空或当前网中不存在无前驱的顶点为止。

同时每个`AOV`网都有一个或多个拓扑排序序列。拓扑排序代码实现如下：

~~~c
#define MaxVertexNum 100//图中顶点数目的最大值
typeder struct ArcNode{		//边表结点
    int adjvex;				//该弧所指向的顶点的位置
    struct ArcNode * nextarc;//指向下一条弧的指针
    //InfoType info; 		//网的边权值
} ArcNode;
typedef struct VNode{		//顶点表结点
    VertexType data;		//顶点信息
    ArcNode *firstarc;		//指向第一条依附该顶点的弧的指针
}VNode,AdjList[MaxVertexNum];
typedef struct{
    AdjList vertices;		//邻接表
    int vexnum, arcnum;		//图的顶点数和弧数
} Graph;					//Graph是以邻接表存储的图类型

bool TopologicalSort(Graph G){
    InitStack(S);				//初始化栈， 存储入度为0的顶点
    for(int i=0; i<G.vexnum;i++)
        if(indegree[i]==0)
            Push(S,i);			//将所有入度为0的顶点进栈
    int count=0;				//计数，记录当前已经输出的顶点数
    while(!IsEmpty(S)){			//栈不空，则存在入度为0的顶点
        Pop(S,i);				//栈顶元素出栈
        print [count++]=i;		//输出顶点i
        for(p=G.vertices[i].firstarc;p;p=p->nextarc){//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈s
            v=p->adjvex;
            if(!(--indegree[v]))
                Push(S,v); 		//入度为0， 则入栈
        }
    }//while
    if (count<g.vexnum)
        return false;			//排序失败，有向图中有回路
    else
        return true;			//拓扑排序成功
}
~~~

上面代码执行方式如下：

有一`AOV`网：

<img src="https://image.sybblogs.fun/img-common/202312052231729.png" alt="拓扑排序4" style="zoom:25%;" />

其邻接表存储结构如下：

<img src="https://image.sybblogs.fun/img-common/202312052245015.png" alt="拓扑排序8" style="zoom:25%;" />

初始化数组`indegree[]`(保存当前顶点的入度信息)`print[]`(记录拓扑序列)和栈$/$队列`s`(保存度为$0$的顶点)如下：

<img src="https://image.sybblogs.fun/img-common/202312052232973.png" alt="拓扑排序5" style="zoom:25%;" />

- 代码$19\sim21$行第一个`for`循环会将所有入度为$0$的顶点入栈。可以通过`indegree[]`数组发现顶点入度为$0$的顶点有`0`和`1`。

  <img src="https://image.sybblogs.fun/img-common/202312052237840.png" alt="拓扑排序6" style="zoom:25%;" />

- 在`while`循环中会将栈顶元素出栈并保存到`print[]`数组中。就是将入度为$0$的顶点放入拓扑序列中。

  <img src="https://image.sybblogs.fun/img-common/202312052241591.png" alt="拓扑排序7" style="zoom:25%;" />

- `while`中的`for`循环将与`2`号顶点相连的顶点的`indegree`对应值`-1`，即将`3`和`4`的`indegree`值`-1`。这在逻辑上相当于删除`2`号结点的出边。之后判断`3`和`4`号顶点的`indegree`值是否为$0$，如果为$0$则入栈。

- `while`循环第二次循环弹出`0`号顶点，重复以上操作。最后要判断`count`的值是否等于结点数`vexnum`的值。如果小于，证明图中有环路，排序失败。

最后拓扑排序序列为：2，0，1，3，4

若采用邻接表时间复杂度是：$O(|V|+|E|)$。但使用邻接矩阵时间复杂度是：$O(|V|^2)$

#### 逆拓扑排序

对一个`AOV`网，如果采用下列步骤进行排序，则称之为逆拓扑排序：
①从`AOV`网中选择一个没有==后继(出度为$0$)==的顶点并输出。
②从网中删除该顶点和所有以它为终点的有向边。
③重复①和②直到当前的`AOV`网为空。

<img src="https://image.sybblogs.fun/img-common/202312052132065.png" alt="AOV网" style="zoom:25%;" />

上面图的逆拓扑排序为：吃、下锅炒、切番茄、洗番茄、打鸡蛋、准备厨具、买菜。

注意逆拓扑排序当删除一个顶点后，需要同时删除指向这个顶点的边。如果采用邻接表存储，找一个顶点指向的边较为复杂需要遍历整个邻接表，显然十分低效。而如果采用邻接矩阵当删除一个顶点后想要找到这个顶点对应的边，只需要遍历这一列即可。

同样这里可以使用逆邻接表方式存储图，即邻接表保存的是入边信息，而逆邻接表存放的是出边的信息。逆邻接表存储如下：

<img src="https://image.sybblogs.fun/img-common/202312052307825.png" alt="拓扑排序9" style="zoom:25%;" />

如上面`3`顶点，其邻接表存放的入边顶点，即`1`顶点和`2`顶点同时指向了`3`顶点。这样也十分方便。

#### DFS实现拓扑排序

DFS实现逆拓扑排序：在顶点退栈前输出。

实现方式如下：

~~~c
void DFSTraverse(Graph G){		//对图G进行深度优先遍历
    for(v=0;v<G. vexnum; ++v)
        visited [v]=FALSE;		//初始化已访问标记数据
    for(v=0; v<G.vexnum; ++v)	//本代码中是从v=0开始遍历
        if( !visited[v])
            DFS(G,v);
}
void DFS(Graph G,int v){		//从顶点v出发，深度优先遍历图G
    visit(v);					//访问顶点v
    visited[v]=TRUE;			//设已访问标记
    for(w=FirstNeighbor(G,v);W>=0;w=NextNeighor(G,v,W))
        if( !visited[w]){		//w为u的尚未访问的邻接顶点
            DFS(G,W);
        }
    print(v);
}
~~~

上面代码相对于正常DFS算法新加一行` print(v);`。执行大致步骤如下：

1. 先通过`0`号顶点，进入递归，一直递归到`4`号顶点，此时`4`号顶点没有邻接点，所以打印第一个顶点是`4`。此时栈如下：

   <img src="https://image.sybblogs.fun/img-common/202312052316119.png" alt="DFS实现逆拓扑排序" style="zoom:25%;" />

2. `4`号顶点打印完毕后，出栈，栈顶`3`号顶点唯一邻接点`4`已经访问过，所以打印出栈。

   对于栈中`1`号顶点和`0`号顶点同样依次出栈打印。

3. 接着`DFSTraverse()`函数中`for`循环会对没有进行访问`2`号顶点调用`DFS()`函数，由于`2`号顶点所有邻接点均已访问，所以直接打印结束。

所以用DFS逆拓扑排序序列为：4，3，1，0，2

如果有回路情况下可以加一个形参`flag`来记录当前递归调用次数，如果次数大于顶点数`vexnum`则表示有环路存在，退出循环。也可以通过`if(NextNeighor(G,v,W)&&visited[w])`，即下一个邻接点存在，并且还被访问过，就代表图有回路存在。

## 8. 关键路径

AOE网：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销(如完成活动所需的时间)， 称之为用边表示活动的网络，简称AOE网(Activity On Edge NetWork)

<img src="https://image.sybblogs.fun/img-common/202312061604390.png" alt="AOE网" style="zoom:25%;" />

上面图是一个AOE网，上面图入边指向的顶点表示，前一个出边的顶点需要在入边顶点之前完成。也就是说上图`V_1`顶点开始之后，才能进行`打鸡蛋`和`洗番茄`的操作。只有$V_3$之前边上的事件和顶点都执行完毕，才能进行$V_3$顶点的事件。所以AOE网有以下性质：

1. 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；
2. 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。
3. 在AOE网中仅有一个入度为$0$的顶点，称为开始顶点(源点)，它表示整个工程的开始；也仅有一个出度为$0$的顶点，称为结束顶点(汇点)，它表示整个工程的结束。

==关键路径==：从源点到汇点的有向路径可能有多条，所有路径中，具有**最大路径长度的路径称为关键路径**，而把关键路径上的活动称为关键活动。完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。

上面图有两条路径：$V_1\rightarrow V_3\rightarrow V_4$与$V_1\rightarrow V_2\rightarrow V_3\rightarrow V_4$

显然第二个路径$V_1\rightarrow V_2\rightarrow V_3\rightarrow V_4$路径长度最大，所以是关键路径。

求关键求法：

- 先求事件$ve(k)$的最早发生时间$ve(k)$：决定 了所有从以开始的活动能够开工的最早时间。如上图：`洗番茄`最早开工时间是`1`分钟，`切番茄`要$3$分钟并且必须要等`洗番茄`完成后进行，所以`切番茄`最早开工时间是`3+1=4`，而`打鸡蛋`这个事件可以在`洗番茄`和`切番茄`时同时进行，所以$V_3$事件，最早开始事件是$4$分钟。最后，`炒菜`需要两分钟，所以$V_4$`结束`最早时间是`4+2=6`分钟。

  <img src="https://image.sybblogs.fun/img-common/202312061638443.png" alt="求关键路径步骤" style="zoom: 25%;" />

- 活动$a_i$的最早开始时间$e(i)$：指该活动弧的起点所表示的事件的最早发生时间。即出边顶点最早开始时间就是活动$a_i$最早开始时间。如：$V_2$最早开始时间是$V_1$即$1$，$V_3$最早开始时间是$V_2$即$1$，$V_4$最早开始时间是$V_3$即$4$。

  <img src="https://image.sybblogs.fun/img-common/202312061643868.png" alt="求关键路径步骤2" style="zoom:25%;" />

- 事件$v_k$的最迟发生时间$vl(k)$：它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。

- 活动$a_i$的最迟开始时间$l(i)$：它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。

  如：打鸡蛋这个活动，后面的事件$V_3$必须在`4`这个时刻开始，而打鸡蛋又需要两分钟时间，所以打鸡蛋这个活动最晚可以`2`这个时刻开始。而像切番茄这个活动，总共要消耗`3`的时间，而$V_3$事件必须要在`4`这个时间发生，所以切番茄活动必须在$4-3=1$这个时间进行。下面绿色标记的是活动最迟开始时间：

  <img src="https://image.sybblogs.fun/img-common/202312061711085.png" alt="求关键路径步骤3" style="zoom:25%;" />

- 将活动最早开始时间和最晚开始时间放在一起(红色最早开始时间，绿色最晚开始时间)：

  <img src="https://image.sybblogs.fun/img-common/202312061713827.png" alt="求关键路径步骤4" style="zoom:25%;" />

  上图只有打鸡蛋这个活动可以在$0$时刻立即开始或者`2`分钟后开始，剩下的活动最早开始时间和最晚开始时间都是一样的，即这些活动时间都不能延后。

- 将活动$a_i$的时间余量$d(i)=l(i)-e(i)$，即最晚开始时间减去最早开始时间就是活动$a_i$的时间余量。若$a_i$活动时间余量为$0$则表示$a_i$是关键活动。

- 由关键活动组成的路径就是关键路径。

求关键路径步骤：

<img src="https://image.sybblogs.fun/img-common/202312061719439.png" alt="求关键路径步骤5" style="zoom:25%;" />

1. 求所有事件的最早发生时间$ve()$
2. 求所有事件的最迟发生时间$vl()$
3. 求所有活动的最早发生时间$e( )$
4. 求所有活动的最迟发生时间$l()$
5. 求所有活动的时间余量$d( )$。$d(i)=0$的活动就是关键活动，由关键活动可得关键路径。

所有事件的最早发生时间$ve()$和所有活动的最早发生时间等价$e()$。所有事件的最迟发生时间$vl()$需要从最后一个顶点逆向推导每个事件的最迟发生时间$vl()$。在有了所有事件的最迟发生时间$vl()$后可以推出所有活动的最迟发生时间$l()$。最后由所有活动的最早发生时间$e( )$和所有活动的最迟发生时间$l()$可以算出所有活动的时间余量$d( )$。

算法实现步骤：

<img src="https://image.sybblogs.fun/img-common/202312061719439.png" alt="求关键路径步骤5" style="zoom:25%;" />

求上图的关键路径：

- 求所有事件的最早发生时间$ve()$

  按拓扑排序序列，依次求各个顶点的$ve(k)$：
  $ve(源点)=0$
  $ve(k) = \max\{ve(j) + Weight(v_j,v_k)\}$，$v_j$为$v_k$的任意前驱

  上图拓扑序列为：$V_1$，$V_3$，$V_2$，$V_5$，$V_4$，$V_6$

  而$ve(1)=0$，$ve(3)=ve(1)+a_2=2$，$ve(2)=ve(1)+a_1=3$，$ve(5)=ve(2)+a_4=6$，$ve(4)=\max\{ve(2) +2,ve(3)+4\}$，$ve(6)=\max\{ve(5)+1, ve(4)+2, ve(3)+3\}=8$

  <img src="https://image.sybblogs.fun/img-common/202312062112604.png" alt="求关键路径步骤6" style="zoom:25%;" />

- 求所有事件的最早发生时间$vl()$

  按逆拓扑排序序列，依次求各个顶点的$vl(k)$：
  $vl(汇点)= ve(汇点)$
  $vl(k)=\min\{v(j)-Weight(v_k, v_j)\}$，$v_j$为$v_k$的任意后继

  上图逆拓扑序列：$V_6$，$V_4$，$V_5$，$V_2$，$V_3$，$V_1$

  $vl(6)=8$，$vl(5)=vl(6)-a_8=7$，$vl(4)=vl(6)-a_7=6$，$vl(2)=\min\{vl(5)-a_4,vl(4)-a_3\}=4$

  $vl(3)=\min\{vl(4)-a_5,vl(6)-a_6\}=2$，$vl(1)=\min\{vl(2)-a_1,vl(3)-a_2\}=0$

  <img src="https://image.sybblogs.fun/img-common/202312062125482.png" alt="求关键路径步骤7" style="zoom:25%;" />

- 求所有活动的最早发生时间$e()$

  若边$<v_k, v_j>$表示活动$a_i$，则有$e(i) = ve(k)$

  <img src="https://image.sybblogs.fun/img-common/202312062127963.png" alt="求关键路径步骤8" style="zoom:25%;" />

- 求所有活动的最迟发生时间$l()$

  若边$<v_k, v_j>$表示活动$a_i$，则有$l(i) = vl(j) - Weight(v_k, v_j)$

  弧指向顶点的最晚发生时间$vl()-$这条弧的权值。

  <img src="https://image.sybblogs.fun/img-common/202312062132565.png" alt="求关键路径步骤9" style="zoom:25%;" />

- 求所有活动的时间余量$d()$

  $d(i)= l(i)-e(i)$

  <img src="https://image.sybblogs.fun/img-common/202312062133543.png" alt="求关键路径步骤10" style="zoom:25%;" />

  由上表$d(k)$可知：$a_2,a_5,a_7$这些活动时间余量为$0$，代表关键活动，所以关键路径为：

  <img src="https://image.sybblogs.fun/img-common/202312062135812.png" alt="求关键路径步骤11" style="zoom:25%;" />

关键活动、关键路径特性：

1. 若关键活动耗时增加，则整个工程的工期将增长
2. 缩短关键活动的时间，可以缩短整个工程的工期
3. 当缩短到一定程度时，关键活动可能会变成非关键活动
4. 可能有多条关键路径，只**提高一条关键路径上的关键活动速度并不能缩短整个工程的工期**，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。

# 十. 查找

查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找

查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成

关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。

例子：

<img src="C:\Users\Acid\OneDrive\图片\本机照片\408\查找概念.png" alt="查找概念" style="zoom: 25%;" />



查找表：学生成绩信息(线性结构、可顺序可链式存储)
数据元素(记录)：每个学生的信息
关键字：学号

查找表的常见操作：①查找符合条件的数据元素。②插入、删除某个数据元素

如果只进行①操作就是静态查找表，那仅仅关注查找速度即可。

<img src="https://image.sybblogs.fun/img-common/202312062203042.png" alt="静态查找表" style="zoom:25%;" />

如果查找同时也要进行②的操作，就是动态查找表。除了查找速度，也要关注插$/$删操作是否方便实现。

<img src="https://image.sybblogs.fun/img-common/202312062204883.png" alt="动态查找表" style="zoom:25%;" />

## 1. 查找算法评价指标

查找长度：在查找运算中， 需要对比关键字的次数称为查找长度

平均查找长度(TASL , Average Search Length)：所有查找过程中进行关键字的比较次数的平均值。ASL计算方法如下：

<img src="https://image.sybblogs.fun/img-common/202312062207112.png" alt="查找算法平均查找长度" style="zoom:25%;" />

通常认为查找任何元素概论相同。评价一个查找算法的效率时，通常考虑查找成功$/$查找失败两种情况的ASL。

## 2. 顺序查找

顺序查找， 又叫线性查找，通常用于线性表。

算法思想：从头查到尾。

### 2.1 代码实现

实现代码$1$：

~~~c
typedef struct{//查找表的数据结构(顺序表)
    ElemType *elem;//动态数组基址
    int TableLen;//表的长度
}SSTable;
//顺序查找
int Search_Seq(SSTable ST, ElemType key){
    int i;
    for(i=0;i<ST.TableLen && ST.elem[i]!=key; ++i);
    //查找成功，则返回元素下标;查找失败，则返回-1
    return i==ST.TableLen? -1:i;
}
~~~

查找成功情况：

<img src="https://image.sybblogs.fun/img-common/202312062219790.png" alt="顺序查找实现" style="zoom:25%;" />

查找失败情况：

<img src="https://image.sybblogs.fun/img-common/202312062220266.png" alt="顺序查找失败" style="zoom:25%;" />

实现代码$2$：

~~~c
typedef struct{//查找表的数据结构(顺序表)
    ElemType *elem;//动态数组基址
    int TableLen;//表的长度
}SSTable;
//顺序查找
int Search_Seq(SSTable ST, ElemType key){
    ST.elem [0]=key;	//"哨兵”，将查找元素key放入表头
    int i;
    for( i=ST. TableLen;ST.elem[i] !=key;--i); //从后往前找
    return i; //查找成功， 则返回元素下标;查找失败，则返回0
}
~~~

查找成功：

<img src="https://image.sybblogs.fun/img-common/202312062223045.png" alt="顺序查找成功2" style="zoom:25%;" />

查找失败：

<img src="https://image.sybblogs.fun/img-common/202312062224500.png" alt="顺序查找失败2" style="zoom:25%;" />

这种算法优点是：无需判定是否越界，效率更高。

### 2.2 查找效率分析

以实现代码$2$为例：

假设查找的概率都相等即$p_i=\frac{1}{n}$，则查找每一个成功概率是：$1·\frac{1}{n}+2·\frac{1}{n}+\cdots$，则
$$
ASL_{成功}=\frac{1+2+3+\cdots+n}{n}=\frac{n+1}{2}
$$
查找失败情况是每个元素都要对比，对比$n+1$次
$$
ASL_{失败}=n+1
$$

### 2.3 顺序查找的优化(有序表)

优化一：

如果查找表中的元素有序存放(递增$/$递减)

<img src="https://image.sybblogs.fun/img-common/202312062251044.png" alt="查找的优化" style="zoom:25%;" />

那么我们只用判断查找的元素在哪个区间内即可。加入要查找`21`元素，当我们遍历到`29`号元素时，`21<29`所以后面的就没必要查找。

<img src="C:\Users\Acid\OneDrive\图片\本机照片\408\查找的优化2.png" alt="查找的优化2" style="zoom:25%;" />

此时共有$n+1$种情况，所以查找每个元素失败概率变为$p_i=\frac{1}{n+1}$，则
$$
ASL_{失败}=\frac{1+2+3+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
$$
优化二：

如果每个元素被查概率不相等情况下，可以将被查概率大的放在靠前位置。

<img src="https://image.sybblogs.fun/img-common/202312062302726.png" alt="被查概率" style="zoom:25%;" />

被查元素：

<img src="https://image.sybblogs.fun/img-common/202312062303243.png" alt="被查元素" style="zoom:25%;" />

此时
$$
ASL_{成功}=1*0.4+ 2*0.28 + 3*0.15+ 4*0.1 + 5*0.05 + 6*0.02= 2.18
$$
但对于查找失败情况仍和之前一样。

## 3. 二分查找(折半查找)

二分查找：仅适用于有序的顺序表。这是因为顺序表具有随机访问的特性，而链表没有。

### 3.1 查找步骤及实现

如下顺序表查找：

<img src="https://image.sybblogs.fun/img-common/202312081034210.png" alt="二分查找" style="zoom:25%;" />

给定数组元素是$\{7,10,13,16,19,29,32,33,37,41,43\}$，查找元素是$33$

查找步骤是：

1. 先用`low`和`high`两个指针分别指向数组的头部和尾部。而第一轮要检查元素是`low`和`high`中间的元素，用指针`mid=(low+high)/2`指向。即指向`5`位置上的`29`元素。而要查找的`33`元素大于`29`所以只有可能在`mid`指针右边。

   <img src="https://image.sybblogs.fun/img-common/202312081041408.png" alt="二分查找过程" style="zoom:25%;" />

2. 所以将值改为`low=mid+1`，即`32`元素所在的位置。同样`mid`指针指向`mid=(low+high)/2`的位置，即位置`8`所在的`37`元素。

   而元素`33`小于`37`，所以只可能在`mid`指针的左边。

   <img src="https://image.sybblogs.fun/img-common/202312081047918.png" alt="二分查找过程2" style="zoom:25%;" />

3. 将值改为`high=mid+1`，此时`mid=[(low+high)/2]=6`，所以`mid`指向`6`位置的`32`元素。

   <img src="https://image.sybblogs.fun/img-common/202312081051294.png" alt="二分查找过程3" style="zoom:25%;" />

4. 而`33>32`，所以只可能在`mid`指针的右边。即`low=mid+1=7`，同样`mid=(low+high)/2=7`，而位置`7`所在元素是`33`满足查找条件，查找成功。

   <img src="https://image.sybblogs.fun/img-common/202312081058072.png" alt="二分查找过程4" style="zoom:25%;" />

看一个查找失败步骤：

给定数组元素是$\{7,10,13,16,19,29,32,33,37,41,43\}$，查找元素是$12$

前面查找过程一致，最后一步`mid`指向位置`1`所在`10`元素。而此时查找元素`12`仍然大于`10`，所以查找元素会在`mid`指针的右边。此时仍然会执行`low=mid+1`这个操作，之后`low>high`本来在左边指针跑到右边，所以查找失败，即在数组种没有查找到`12`这个元素。

<img src="https://image.sybblogs.fun/img-common/202312081101268.png" alt="二分查找失败过程1" style="zoom:25%;" />

代码实现如下：

~~~c
//折半查找
typedef struct{				//查找表的数据结构(顺序表)
    ElemType *elem;			//动态数组基址
    int TableLen;			//表的长度
}SSTable;
//方法一：
int Binary_Search(SSTable L,ElemType key){
    int low=0,high=L.TableLen-1,mid;
    while(low<=high){
        mid=(low+high)/2;	//取中间位置
        if(L.elem[mid]==key)
            return mid;		//查找成功则返回所在位置
        else if(L.elem[mid]>key)
            high=mid-1;		//从前半部分继续查找
        else
            low=mid+1;		//从后半部分继续查找
        return -1; 			//查找失败，返回-1
    }
}
//方法二：
int Binary_Search(SSTable L,ElemType key){
    int low=-1,high=TableLen;
    while(low+1!=high){
        mid=(low+high)/2;
        if(L.elem[mid]==key)
            return mid;
        else if(L.elem[mid]>key)
            high=mid;
        else
            low=mid;
        return -1;
    }
}
~~~

### 3.2 查找的效率分析

上面例子中的表：

<img src="https://image.sybblogs.fun/img-common/202312081112659.png" alt="查找效率分析" style="zoom:25%;" />

刚开始`mid`指针指向`5`所在位置`29`元素。此时有三种可能性：要么查找元素大于，要么小于，要么等于。如果小于就在`mid`左边查找，如果大于就在`mid`右边查找。

<img src="https://image.sybblogs.fun/img-common/202312081114316.png" alt="查找效率分析1" style="zoom:25%;" />

如果查找的元素小于`29`，那么此时`mid`指向`13`，如果大于`29`，`mid`指向`37`元素。如果仍然不是这两个元素中的任意一个，则继续上面操作。第三轮查找情况如下：

<img src="https://image.sybblogs.fun/img-common/202312081117880.png" alt="查找效率分析2" style="zoom:25%;" />

如果仍没有找到元素，则进入第四轮循环：

<img src="https://image.sybblogs.fun/img-common/202312081118747.png" alt="查找效率分析3" style="zoom:25%;" />

最后一轮如果查找失败，只需要补上失败区间即可：

<img src="https://image.sybblogs.fun/img-common/202312081131536.png" alt="查找效率分析4" style="zoom:33%;" />

上面元素如果在紫色方框内，则表示查找失败。

对于这个例子，ASL查找成功平均效率：有`11`个元素所以每个元素查找到的概率是$p_i=\frac{1}{11}$，且第一层有一个元素且是第一次查找$1*1$，第二层有两个元素且是第二次查找$1*2$，第三层有四个元素且是第三次查找$3*4$，第四层有四个元素且是第四次查找$4*4$。故
$$
ASL_{成功}=(1*1+2*2+3*4+4*4)/11=3
$$
而ASL查找失败平均效率：有`12`个查找失败的元素所以概率$p_i=\frac{1}{12}$。第三层失败元素有四个，且要查找三次。第四次失败元素有八个，且要查找四次。故
$$
ASL_{失败}=(3*4+4*8)/12=11/3
$$

### 3.3 二分查找判定树构造

<img src="https://image.sybblogs.fun/img-common/202312081300723.png" alt="二分查找构造判定树" style="zoom:25%;" />

如果当前`low`和`high`之间有**奇数个**元素，则`mid`分隔后，左右两部分元素个数相等。

如果当前`low`和`high`之间有偶数个元素，则`mid`分隔后(这里是向下取整)，左半部分比右半部分少一个元素。

<img src="https://image.sybblogs.fun/img-common/202312081302234.png" alt="二分查找构造判定树偶数元素" style="zoom:25%;" />

上图分割后构造树如下：

<img src="https://image.sybblogs.fun/img-common/202312081303893.png" alt="二分查找偶数元素判定树" style="zoom:25%;" />

二分查找构造树特点：

- 综上所述，二分查找的判定树中，若$mid=[(low + high)/2]$，则对于任何一个结点，必有：
  右子树结点数$-$左子树结点数$=0$或$1$。

- 一个二分查找判定树一定是平衡二叉树。任何一个左子树和右子树之差不超过$1$。因此，只有最下面一层是不满的。
- 二分查找判定树中当元素个数为$n$时树高$h= [\log_2(n+ 1)]$
- 判定树的失败结点个数：$n+1$(等于成功结点的空链域数量)

二分查找对比顺序查找：

二分查找判定树树高$h= [\log_2(n+ 1)]$，查找成功的ASL$\le h$，查找失败的ASL$\le h$，故二分查找的时间复杂度为$O(\log_2n)$。而顺序查找时间复杂度为$O(n)$。显然二分查找可能优于顺序查找，但**不一定完全优于顺序查找**。如下：

<img src="https://image.sybblogs.fun/img-common/202312081320632.png" alt="二分查找对比顺序查找" style="zoom:25%;" />



使用顺序查找第一次就可以找到元素`7`，使用二分查找显然次数更多。

## 4. 分块查找

有以下数组：

<img src="https://image.sybblogs.fun/img-common/202312081447628.png" alt="分块查找" style="zoom:25%;" />

数组中各个元素可以根据元素位置不同分成一个个小区间。如下：

<img src="https://image.sybblogs.fun/img-common/202312081448050.png" alt="分块查找数组划分区间" style="zoom:25%;" />

划分不同区间后，数组变得有序，可以建立上级索引表。索引表当中保存每个分块的最大关键字和分块的存储区间。

<img src="https://image.sybblogs.fun/img-common/202312081450971.png" alt="分块查找建立上级索引" style="zoom: 25%;" />

不难看出分块查找特点是：块内无序，块间有序。其中索引表元素是区间数组块上的最大值。

### 4.1 分块查找实现

其算法过程如下：

1. 在索引表中确定待查记录所属的分块(可顺序、可折半)
2. 在块区间内顺序查找

假如查找元素是`30`，有两种方法：

- 顺序表查找：通过查找上级索引表，找到大于查找元素`30`的第一个索引元素。再根据`30`区间在数组中对比`6`到`8`这三个元素对应值是否包含`30`即可。
- 二分查找找元素同样计算`mid=(low+high)/2`指针指向的是`30`这个索引数组元素，而`30=30`，故查找数组下标区间`6`到`8`这三个元素对应值是否包含`30`即可。

假如查找元素是`19`，二分查找步骤如下：

<img src="https://image.sybblogs.fun/img-common/202312081516518.png" alt="折半查找进行分块查询" style="zoom:25%;" />

1. 如上图第一次查找`mid`指向的是索引表中`30`元素，由于`30>19`，故查找元素可能在索引表左边，所以`high=mid-1`，`mid=(low+high)/2=0`。

   <img src="https://image.sybblogs.fun/img-common/202312081527423.png" alt="折半查找进行分块查询1" style="zoom: 25%;" />

2. 此时索引表`mid`指向的元素是`10<19`，所以`low=mid+1`，`mid=(low+high)/2=1`

   <img src="https://image.sybblogs.fun/img-common/202312081529906.png" alt="折半查找进行分块查询2" style="zoom:25%;" />

3. 索引表`mid`指向的元素是`20>19`，故查找元素可能在索引表左边，所以`high=mid-1=0`，此时`low>high`，所以二分查找结束。我们在`low`指向的分块中查找元素，当前`low`指向`20`元素区间是`2,5`，故在数组中找下标`2`到`5`之间的元素是否包含`19`。

   <img src="https://image.sybblogs.fun/img-common/202312081533033.png" alt="折半查找进行分块查询3" style="zoom:25%;" />

   注意：若索引表中不包含目标关键字(要查找的元素)，则折半查找索引表最终停在`low>high`的位置，此时要在low所指分块中查找。

   这样做原因在于，索引表保存的是区间块上的最大值，而我们要找的元素要比索引元素小才有可能在数组区间中找到。即要保证**找第一个比查找元素大的索引元素**。

再看一个二分查找失败例子，假如查找元素是`54`，二分查找最后一步如下：

<img src="https://image.sybblogs.fun/img-common/202312081540762.png" alt="折半查找进行分块查询4" style="zoom:25%;" />

查找元素`54`大于表中所有元素，所以二分查找`low`指针一直往右移，当最后一次移动时`low`超出索引表范围，所以查找失败。

### 4.2 分块查找效率分析

<img src="https://image.sybblogs.fun/img-common/202312081610283.png" alt="分块查找效率分析" style="zoom:25%;" />

共有$14$个元素，各自被查概率为$\frac{1}{14}$

若索引表采用顺序查找，则查元素`7`需要$2$次、查元素`10`需要$3$次、查元素$13$需要$3$次

若索引表采用折半查找，则查元素`30`需要$4$次、而查元素`27`需要次数并不是$2$次，因为我们要找的是第一个比查找元素`27`大的索引元素，虽然索引表第一个被查元素`30>27`，但有可能索引表之前的元素仍有比`27`大的元素，这样`30`就不是第一个比查找元素大的元素了。正确查找步骤是：

1. `low`指向元素$10$，`high`指向元素`50`，`mid`指向`30`，由于`30>27`，`high=mid-1`指向`20`
2. 重新计算`mid=(low+high)/2=0`，指向元素`10`，而`10<27`，故`low=mid+1`指向`20`
3. `mid=(low+high)/2=1`指向`20`，此时`20<27`，故`low=mid+1`指向`30`，由于`low>high`，所以二分查找结束，查找区间为`low`所在的数组区间。`low`指向`30`，且区间为`[6,8]`
4. 根据区间`[6,8]`查找数组对应下标区间，发下第一个元素即`27`查找成功。

所以查元素`27`需要次数是$4$次。

而计算查找成功ASL值，我们需要把所有元素查找次数计算出来，并相加，再除元素总个数。对于顺序表分块查找相对来说可以计算，但对于二分查找显然不可能计算这么多元素的查找次数。所以考试只考顺序查找次数进行ASL计算。

而计算查找失败的ASL值，由于分块查询具有块内无序的特点，所以查找失败情况更加复杂。故不做讨论。

以上是分块不均匀情况，考试常考分块均匀情况下计算分块查找效率：

<img src="https://image.sybblogs.fun/img-common/202312081632543.png" alt="分块均匀情况计算查找效率" style="zoom:25%;" />

假设，长度为$n$的查找表被均匀地分为$b$块，每块$s$个元素。设索引查找和块内查找的平均查找长度分别为$L_I$、$L_S$, 则分块查找的平均查找长度为
$$
ASL=L_I+L_S
$$

- 若采用顺序查找的方式查找索引表，由于$b$个分块，则索引查找平均查找长度为：
  $$
  L_I=\frac{(1+2+\cdots+b)}{b}=\frac{b+1}{2}
  $$
  由于每块有$s$个元素，而查找块内元素的平均查找长度为：
  $$
  L_S=\frac{(1+2+\cdots+s)}{s}=\frac{s+1}{2}
  $$
  故$ASL=L_I+L_S$，即
  $$
  ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}
  $$
  其中由于长度为$n$的查找表被均匀地分为$b$块，每块$s$个元素。故$n=sb$。

  那么此时在什么情况下可以使ASL的平均长度最少：
  $$
  \begin{equation*}
  	\begin{aligned}
  \\
  &ASL=\frac{s^2+2s+n}{2s}=\frac{1}{2}s+1+\frac{n}{2s}\\
  \\
  &ASL'=\frac{1}{2}-\frac{n}{2s^2}\\
  \\
  &当\frac{1}{2}-\frac{n}{2s^2}=0,得s=\sqrt{n}\\
  \\
  &故当s=\sqrt{n}时,得极小值点,极小值为:\\
  \\
  &ASL\Big|_{s=\sqrt{n}}=(\frac{1}{2}s+1+\frac{n}{2s})\Big|_{s=\sqrt{n}}=\sqrt{n}+1
  	\end{aligned}
  \end{equation*}
  $$
  故分块查找平均查找长度当把$n$个元素分为$\sqrt{n}$块，而每个分块内有$\sqrt{n}$个元素，可以保证查找长度最少为$\sqrt{n}+1$。

  若$n=10000$，则将$n$分为$\sqrt{n}$块，即$100$块，而每个块内有$100$个元素，这样平均查找长度最小，为$\sqrt{n}+1=101$。

- 用二分查找查索引表，则$L_I=\lceil\log_2(b+1)\rceil$，$L_S=\frac{(1+2+\cdots+s)}{s}=\frac{s+1}{2}$

  则
  $$
  ASL=\lceil\log_2(b+1)\rceil+\frac{s+1}{2}
  $$

## 5. 二叉排序树

二叉排序树，又称叉查找树(BST Binary Search Tree)一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：

1. 左子树上所有结点的关键字均小于根结点的关键字
2. 右子树上所有结点的关键字均大于根结点的关键字
3. 左子树和右子树又各是一棵二叉排序树

即左子树结点值$<$根结点值$<$右子树结点值。根据这个特性进行中序遍历，可以得到一个递增的有序序列。如下：

<img src="https://image.sybblogs.fun/img-common/202309252332527.png" alt="二叉排序树" style="zoom:25%;" />

### 5.1 二叉排序树查找

若树非空，目标值与根结点的值比较：

若相等，则查找成功

若小于根结点，则在左子树上查找，否则在右子树上查找。

查找成功，返回结点指针，查找失败返回$NULL$

例如要查找关键字为$30$得结点：

<img src="https://image.sybblogs.fun/img-common/202312081740763.png" alt="二叉排序树查找" style="zoom:25%;" />

查找步骤：

- 根结点`19<30`，所以结点可能在根结点右侧。

- 右侧结点`50>30`，所以结点在该结点左侧。

  <img src="https://image.sybblogs.fun/img-common/202312081742906.png" alt="二叉排序树查找成功" style="zoom:25%;" />

查找实现代码如下：

~~~c
//二叉排序树结点
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild, *rchild;
}BSTNode,*BSTree;

//在二叉排序树中查找值为key的结点
BSTNode *BST_Search(BSTree T,int key){
    while(T!=NULL&&key!=T->key){ 		//若树空或等于根结点值，则结束循环
        if(key<T->key) T=T->lchild;		//小于，则在左子树上查找
        else T=T->rchild;				//大于，则在右子树上查找
    }
    return T;
}
~~~

递归实现方法：

~~~c
//在二叉排序树中查找值为key 的结点(递归实现)
BSTNode *BSTSearch(BSTree T,int key){
    if (T==NULL)
        return NULL;			//查找失败
    if (key==T->key)
        return T;				//查找成功
    else if (key < T->key)
        return BSTSearch(T->lchild,key);//在左子树中找
    else
        return BSTSearch(T->rchild,key);//在右子树中找
}
~~~

采用非递归方式，最坏得空间复杂度$O(1)$；而采用递归方式，最坏时间复杂度$O(h)$

### 5.2 二叉排序树的插入

若原二叉排序树为空，则直接插入结点；否则，若关键字$k$小于根结点值，则插入到左子树，若关键字$k$大于根结点值，则插入到右子树。

<img src="https://image.sybblogs.fun/img-common/202312081740763.png" alt="二叉排序树查找" style="zoom:25%;" />

代码实现如下：

~~~c
//在二叉排序树插入关键字为k的新结点(递归实现)
int BST_Insert(BSTree &T,int k){
    if(T==NULL){			//原树为空， 新插入的结点为根结点
        T=(BSTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=NULL;
        T->rchild=NULL;
        return 1; 			//返回1, 插入成功
    }
    else if(k==T->key)		//树中存在相同关键字的结点，插入失败
        return 0;
    else if(k<T->key)		//插入到T的左子树
        return BST_ Insert(T->lchild, k);
    else					//插入到T的右子树
        return BST_Insert(T->rchild,k);
}
~~~

同样构造二叉排序树得的过程就是不断插入新结点的过程。构造代码如下：

~~~c
//按照str[] 中的关键字序列建立二叉排序树
void Creat_BST(BSTree &T,int str[],int n){
    T=NULL;//初始时T为空树
    int i=0;
    while(i<n){//依次将每个关键字插入到二叉排序树中
        BST_Insert(T,str[i]);
        i++;
    }
}
~~~

例1：按照序列$str=\{50, 66, 60, 26, 21, 30, 70, 68\}$建立BST

结果如下：

<img src="https://image.sybblogs.fun/img-common/202312081800040.png" alt="二叉排序树建立" style="zoom:25%;" />

例2：按照序列$str=\{50, 26, 21, 30, 66, 60, 70,68\}$建立BST

结果同上：

<img src="https://image.sybblogs.fun/img-common/202312081800040.png" alt="二叉排序树建立" style="zoom:25%;" />

例3：按照序列$str=\{26, 21, 30, 50, 60, 66, 68, 70\}$建立BST

结果如下：

<img src="https://image.sybblogs.fun/img-common/202312081802848.png" alt="二叉排序树建立2" style="zoom:25%;" />

由此可知不同的关键字序列可能得到同款二叉排序树。也可能得到不同款二叉排序树。

### 5.3 ==二叉排序树的删除==

分三种情况：<a id='3-5.3'></a>

- 若被删除结点$z$是叶结点，则直接删除，不会破坏二叉排序树的性质。

- 若结点$z$只有一棵左子树或右子树，则让$z$的子树成为$z$父结点的子树，替代$z$的位置。

  <img src="https://image.sybblogs.fun/img-common/202312081806137.png" alt="二叉排序树删除" style="zoom:25%;" />

  删除$z$后的结点：

  <img src="https://image.sybblogs.fun/img-common/202312081807969.png" alt="二叉排序树删除2" style="zoom:25%;" />

- 若结点$z$有左、右两棵子树，则令$z$的直接后继(或直接前驱)替代$z$，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况。

  具体来说就是：将该结点右子树当中，中序遍历被访问的第一个结点(即$z$的右子树中最左下的结点，该结点一定没有左子树)。

  <img src="https://image.sybblogs.fun/img-common/202312081813847.png" alt="二叉排序树删除3" style="zoom:25%;" />

  将$p$结点替换$z$结点后，由于原先$p$结点没有左子树，此时问题就转换成了第二个问题：结点$z$只有一棵左子树或右子树，则让$z$的子树成为$z$父结点的子树，替代$z$的位置。

  <img src="https://image.sybblogs.fun/img-common/202312081816091.png" alt="二叉排序树删除4" style="zoom:25%;" />

  或者可以用直接前驱替代$z$结点，即找到左子树中最大的值，即$z$结点左子树中最右下的结点(该结点一定没有右子树)。

  <img src="https://image.sybblogs.fun/img-common/202312081819945.png" alt="二叉排序树删除6" style="zoom:25%;" />

### 5.4 ==二叉排序树查找效率分析==

查找长度：在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。

<img src="https://image.sybblogs.fun/img-common/202312081822942.png" alt="二叉排序树查找效率分析" style="zoom:25%;" />

对于上图查找成功的平均查找长度ASL(Average Search Length)：$ASL_{成功}=(1*1 + 2*2 + 3*4 + 4*1)/8= 2.625$

<img src="https://image.sybblogs.fun/img-common/202312081823849.png" alt="二叉排序树查找效率分析2" style="zoom: 25%;" />

对于上图查找成功的平均查找长度ASL(Average Search Length)：$ASL_{成功}=(1*1+ 2*2 + 3*1 + 4*1 + 5*1 + 6*1+ 7*1)/8= 3.75$

下面看查找失败平均查找长度：

<img src="https://image.sybblogs.fun/img-common/202312081830522.png" alt="二叉排序树查找效率分析失败情况" style="zoom:25%;" />

紫色方框区域为有可能查找失败区域，其中第三层失败结点有$7$个，第四层失败结点有$2$个。故$ASL_{失败}=(3*7 + 4*2)/9=3.22$

<img src="https://image.sybblogs.fun/img-common/202312081832910.png" alt="二叉排序树查找效率分析失败情况2" style="zoom:25%;" />

上图查找失败平均查找长度：$ASL= (2*3 +3+4+5+6+7*2)/9 = 4.22$

虽然上面两个树结点都一样，但查找长度不同，所以二叉排序树查找效率很大程度上由这棵树的高度决定。

对于二叉排序树最好情况：$n$个结点的二叉树最小高度为$\lfloor \log_2n\rfloor+ 1$。平均查找长度$O(\log_2n)$

对于二叉排序树最坏情况：每个结点只有一个分支，树高$h=结点数n$。平均查找长度$O(n)$

所以在构建二叉排序树时，尽量保证树上任一结点的左子树和右子树的深度之差不超过1，即建立平衡二叉树。

## 6. 平衡二叉树

平衡二叉树( Balanced Binary Tree)，简称平衡树(AVL树)：树上任一结点的左子树和右子树的高度之差不超过$1$。

某结点平衡因子$=$左子树高$-$右子树高

<img src="https://image.sybblogs.fun/img-common/202312100221952.png" alt="平衡二叉树结点平衡因子" style="zoom:25%;" />

上图根结点左子树高度为$2$，右子树高度为$3$，所以结点平衡因子$=2-3=-1$。这个$-1$就是这棵树根结点的平衡因子。

 平衡二叉树结点的平衡因子的值只可能是$-1$、$0$或$1$。如果有任一结点的平衡因子绝对值大于$1$就不是平衡二叉树。

二叉树平衡树的结构如下：

~~~c
//平衡二叉树结点
typedef struct AVLNode{
    int key;//数据域
    int balance;//平衡因子
    struct AVLNode *lchild,*rchild;
}AVLNode,*AVLTree;
~~~

上图平衡二叉树在按照二叉排序树方法插入新结点后，会变得不平衡

<img src="https://image.sybblogs.fun/img-common/202312100232634.png" alt="平衡二叉树插入新结点后不平衡" style="zoom:25%;" />

让这个平衡二叉树恢复平衡的办法是从插入点往回找到第一个不平衡结点，调整以该结点为根的子树。则其他祖先节点都会恢复平衡。

### 6.1 调整最小不平衡子树

调整最小不平衡子树$A$，分四种情况：

| 情况 |               具体原因                |
| :--: | :-----------------------------------: |
|  LL  | 在$A$的左孩子的左子树中插入导致不平衡 |
|  RR  | 在$A$的右孩子的右子树中插入导致不平衡 |
|  LR  |  在$A$的左孩子的右子树插入导致不平衡  |
|  RL  | 在$A$的右孩子的左子树中插入导致不平衡 |

#### 调整最小不平衡子树(LL)

当根结点**左子树的左孩子结点(LL)**上插入一个新结点导致$A$为根结点的树不平衡情况。

<img src="https://image.sybblogs.fun/img-common/202312100321246.png" alt="调整最小不平衡子树" style="zoom:25%;" />

上图方框的结点抽象表示为子结点，其高度为$H$。目标是目标是要恢复平衡并保持二叉排序树特性。

根据前面的章节可知二叉排序树特性：左子树结点值$<$根结点值$<$右子树结点值。故$BL<B<BR<A<AR$。根据这一特性恢复平衡的具体做法是：由于在结点$A$的左孩子$(L)$的左子树$(L)$上插入了 新结点，$A$的平衡因子由$1$增至$2$，导致以$A$为根的子树失去平衡，需要一次向右的旋转操作。

1. 即将$A$的左孩子$B$向右上旋转代替$A$成为根结点。
2. 将$A$结点向右下旋转成为$B$的右子树的根结点
3. 而$B$的原右子树则作为$A$结点的左子树。

<img src="https://image.sybblogs.fun/img-common/202312131531789.png" alt="调整最小不平衡子树结果" style="zoom:25%;" />

代码实现核心：

~~~c
f->lchild = p->rchild;
p->rchild=f;
gf->lchild/rchild= p;
~~~

> gf是A结点的父结点，f代表A结点，p代表B结点。

<img src="https://image.sybblogs.fun/img-common/202312131545396.png" alt="RR代码结构" style="zoom:25%;" />

#### 调整最小不平衡子树(RR)

当根结点**右子树的右孩子结点(RR)**上插入一个新结点导致$A$为根结点的树不平衡情况。

<img src="https://image.sybblogs.fun/img-common/202312131536768.png" alt="调整最小不平衡子树RR" style="zoom:25%;" />

同样，二叉排序树特性：左子树结点值$<$根结点值$<$右子树结点值。可知$AL<A<BL<B<BR$。根据这一特性恢复平衡的具体做法是：由于在结点$A$的右孩子$(R)$的右子树$(R)$， 上插入了新结点，$A$的平衡因子由$-1$减至$-2$，导致以$A$为根的子树失去平衡，需要一次向左的旋转操作。

1. 将$A$的右孩子$B$向左上旋转代替$A$成为根结点
2. 将$A$结点向左下旋转成为$B$的左子树的根结点
3. $B$的原左子树则作为$A$结点的右子树

<img src="https://image.sybblogs.fun/img-common/202312131540669.png" alt="调整最小不平衡子树RR结果" style="zoom:25%;" />

代码实现核心：

~~~c
f->rchild = p->lchild;
p->lchild=f;
gf->lchild/rchild= p;
~~~

> gf是A结点的父结点，f代表A结点，p代表B结点。

<img src="https://image.sybblogs.fun/img-common/202312131545396.png" alt="RR代码结构" style="zoom:25%;" />

#### 调整最小不平衡子树(LR)

当根结点**左子树的右孩子结点(LR)**上插入一个新结点导致$A$为根结点的树不平衡情况。

<img src="https://image.sybblogs.fun/img-common/202312131553435.png" alt="调整最小不平衡子树LR" style="zoom:25%;" />

为了便于理解，这里将`BR`结点展开。假设$BR$结点是一个以`C`为根的树，其左子树是`CL`高度为`H-1`，右子树是`CR`高度为`H-1`。

<img src="https://image.sybblogs.fun/img-common/202312131555740.png" alt="调整最小不平衡子树LR分解" style="zoom: 50%;" />

这里将新插入的结点放在`CR`结点，也可以放在`CL`结点。那么恢复平衡的具体做法是**先左后右双旋转**：

由于在$A$的左孩子$(L)$的右子树$(R)$上插入新结点，$A$的平衡因子由$1$增至$2$，导致以$A$为根的子树失去平衡，需要进行两次旋转操作先左旋转后右旋转：

1. 先将$A$结点的左孩子$B$的右子树的根结点$C$向左上旋转提升到$B$结点的位置
2. 然后再把该$C$结点向右上旋转提升到$A$结点的位置

<img src="https://image.sybblogs.fun/img-common/202312131600837.png" alt="调整最小不平衡子树LR结果" style="zoom:25%;" />

旋转之后亦然满足排序树特性：$BL<B<CL<C< CR<A<AR$

#### 调整最小不平衡子树(RL)

当根结点**右子树的左孩子结点(RL)**上插入一个新结点导致$A$为根结点的树不平衡情况。

<img src="https://image.sybblogs.fun/img-common/202312131633253.png" alt="调整最小不平衡子树RL" style="zoom: 33%;" />

同样，为了便于理解，这里将`BR`结点展开。假设$BL$结点是一个以`C`为根的树，其左子树是`CL`高度为`H-1`，右子树是`CR`高度为`H-1`。将新插入的结点放在`CL`结点，也可以放在`CR`结点。

<img src="https://image.sybblogs.fun/img-common/202312131634618.png" alt="调整最小不平衡子树RL分解" style="zoom:25%;" />

恢复平衡的具体做法是**先右后左双旋转**：由于在$A$的右孩子$(R)$的左子树$(L)$上插入新结点，$A$的平衡因子由$-1$减至$-2$，导致以$A$为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。

1. 先将$A$结点的右孩子$B$的左子树的根结点$C$向右上旋转提升到$B$结点的位置
2. 然后再把该$C$结点向左上旋转提升到$A$结点的位置

<img src="https://image.sybblogs.fun/img-common/202312131641538.png" alt="调整最小不平衡子树RL结果" style="zoom:25%;" />

旋转之后仍满足排序树特性：$AL<A<CL<C<CR<B<BR$

#### 平衡二叉树查找效率分析

若树高为$h$，则最坏情况下，查找一个关键字最多需要对比$h$次，即查找操作的时间复杂度不可能超过$O(h)$。所以查找效率分析实际就是分析一颗平衡二叉树高度有多高。

基于平衡二叉树特性：树上任一一结点的左子树和右子树的高度之差不超过$1$。可以假设以$n_h$表示高度为$h$的平衡树中含有的最少结点数，则高度为$h$的平衡二叉树最少结点数为：
$$
n_h=n_{h-1}+n_{h-2}+1
$$
即根结点$+$左子树高度($n_{h-1}$)$+$右子树高度($n_{h-2}$)，注意保证左右子树结点最少。所以根据这个公式可以推出常见高度为$h$平衡二叉树最少结点数：
$$
n_0=0,n_1=1,n_2=2\\
\\
n_3=n_2+n_1+1=4\\
\\
n_4=n_3+n_2+1=7\\
\\
n_5=n_4+n_3=12
$$
故一个平衡二叉树最少结点$n=9$，那么它的最大高度$h_{\max}=4$。即这样一颗平衡二叉树查找一个关键字最多需要对比$4$次。

可以证明含有$n$个结点的平衡二叉树的最大深度为$O(\log_2n)$，==平衡二叉树==的==平均查找长度为$O(\log_2n)$==。

#### 总结

只有左孩子插入结点才进行右旋操作，只有右孩子插入结点才进行右旋操作。

<img src="https://image.sybblogs.fun/img-common/202312131652062.png" alt="调整最小不平衡子树总结" style="zoom:25%;" />

看个例子，有以下二叉排序树，由于再添加结点`67`变为非平衡二叉树

<img src="https://image.sybblogs.fun/img-common/202312131655983.png" alt="调整最小不平衡子树例子" style="zoom:25%;" />

恢复平衡的办法是从插入点往回找到第一个不平衡结点，即`70`。调整以该结点为根的子树：

1. 首先观察这是一个LL类型的最小不平衡子树
2. 采用右旋操作，将`68`结点成为根结点，`70`结点成为`68`结点的右子树。

结果如下：

<img src="https://image.sybblogs.fun/img-common/202312131659246.png" alt="调整最小不平衡子树例子结果" style="zoom:25%;" />

插入操作导致最小不平衡子树的高度$+1$，经过调整后高度恢复，则祖先平衡因子也会恢复正常。

例$2$：有以下二叉排序树

<img src="C:\Users\Acid\OneDrive\图片\本机照片\408\调整最小不平衡子树例2.png" alt="调整最小不平衡子树例2" style="zoom:25%;" />

插入结点`57`

<img src="https://image.sybblogs.fun/img-common/202312131708418.png" alt="调整最小不平衡子树例2插入" style="zoom:25%;" />

此时平衡二叉树变为非平衡二叉树，其第一个不平衡结点为`66`。不平衡原因是在其左孩子的右子树中插入新结点，所以是LR类型。

解决方法是：让`66`结点的左孩子的右孩子`60`结点先左旋，再右旋。熟练方法是左旋右旋之后`60`会成为根结点，而`50`和`66`为根结点的左孩子和右孩子。之后让`60`原本的左子树(`55`和`57`)与右子树(63)，按照二叉排序树规则插入即可。

<img src="https://image.sybblogs.fun/img-common/202312131712745.png" alt="调整最小不平衡子树例2结果" style="zoom:25%;" />

### 6.2 平衡二叉树的删除

同调整最小不平衡子树类似，平衡二叉树的删除操作在删除结点后，要保持二叉排序树的特性不变(左$<$中$<$右)。若删除结点后导致结点不平衡，则需要调整平衡。

平衡二叉树删除操作具体步骤：

1. 删除结点(方法同<a href='#3-5.3'>二叉排序树</a>)

   - 若删除的结点是叶子，直接删。
   - 若删除的结点只有一个子树，用子树顶替删除位置
   - 若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除。

2. 若删除后出现不平衡现象，则从被删除结点开始网上找到**最小不平衡子树**，找不到就完结撒花

3. 如果找到最小不平衡子树，高度最高的儿子结点和孙子结点

4. 根据孙子的位置，调整平衡(平衡调整四种情况：$LL/RR/LR/RL$)

   - 孙子结点在$LL$：儿子结点右单旋
   - 孙子结点在$RR$：儿子结点左单旋
   - 孙子结点在$LR$：孙子结点先左旋，再右旋
   - 孙子结点在$RL$：孙子结点先右旋，再左旋

5. 如果调整完后，不平衡特性向上传导，则继续②

   对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡(不平衡向上传递)

删除下面平衡二叉树的`32`结点：

<img src="https://image.sybblogs.fun/img-common/202312201721576.png" alt="平衡二叉树删除结点" style="zoom:25%;" />

- 因为`32`结点是叶子结点，所以直接删除，删除后出现二叉树出现不平衡现象。找最小不平衡子树为`44`结点

  <img src="https://image.sybblogs.fun/img-common/202312201723383.png" alt="平衡二叉树删除结点1" style="zoom:25%;" />

- 找最小不平衡子树下面最高儿子结点`78`和孙子结点`50`

  <img src="https://image.sybblogs.fun/img-common/202312201724489.png" alt="平衡二叉树删除结点2" style="zoom:25%;" />

- 接着根据孙子所在位置选择平衡方法。`50`结点是$RL$情况，所以要先右旋，再左旋。

  <img src="https://image.sybblogs.fun/img-common/202312201725094.png" alt="平衡二叉树删除结点3" style="zoom:25%;" />

  先右旋：

  <img src="https://image.sybblogs.fun/img-common/202312201726696.png" alt="平衡二叉树删除结点4" style="zoom:25%;" />

  再左旋：

  <img src="https://image.sybblogs.fun/img-common/202312201727127.png" alt="平衡二叉树删除结5" style="zoom:25%;" />

- 此时最小不平衡子树恢复平衡

整个平衡二叉树如下：

<img src="https://image.sybblogs.fun/img-common/202312201730955.png" alt="平衡二叉树删除结7" style="zoom:25%;" />

通过上图可以观察出，由于右侧树做了恢复调整，由于树高变矮，所以不平衡性向上传到。处理方法是从第二步开始：

- 从刚刚调整的树的根`50`出发，往上找最小不平衡子树，是`33`。对这棵最小不平衡树再做调整

  <img src="https://image.sybblogs.fun/img-common/202312201734415.png" alt="平衡二叉树删除结8" style="zoom:25%;" />

- 找最小不平衡子树下面最高儿子结点`10`和孙子结点`20`

  <img src="https://image.sybblogs.fun/img-common/202312201735467.png" alt="平衡二叉树删除结9" style="zoom:25%;" />

- 接着根据孙子结点`20`所在位置选择平衡方法。`20`结点是$LR$情况，所以孙子结点要先左旋，再右旋。

  先左旋：

  <img src="https://image.sybblogs.fun/img-common/202312201737708.png" alt="平衡二叉树删除结10" style="zoom:25%;" />

  再右旋：

  <img src="https://image.sybblogs.fun/img-common/202312201812943.png" alt="平衡二叉树删除结11" style="zoom:25%;" />

整棵树恢复平衡。

平衡二叉树的删除操作时间复杂度是$O(\log_2n)$

## 7. 红黑树

红黑树和平衡二叉树在增查删三个基本操作上的时间复杂度一样，都是$O(\log_2n)$。

由于平衡二叉树的插入和删除两个操作很容易破坏平衡性，需要频繁调整树的形态。而红黑树在插入或删除时不会破坏`红黑`特性，无需频繁调整树的形态，即便需要调整一般都在常数级时间内完成。

使用场景：

- 平衡二叉树($AVL$)：适用于以查为主、很少插入$/$删除的场景。
- ==红黑树==：适用于频繁插入、删除的场景，实用性更强。实用场景中一般都用红黑树。

红黑树是二叉排序树：左子树结点值$\le$根结点值$\le$右子树结点值。

**红黑树原则$/$特点：**

1. 每个结点或是红色，或是黑色
2. 根节点是黑色
3. 叶结点(外部结点、NULL结点、失败结点)均是黑色的
4. 不存在两个相邻的红结点(即红结点的父节点和孩子结点均是黑色)
5. 对每个结点，从该节点到任一叶子结点的简单路径上，所含黑结点的数目相同

<img src="https://image.sybblogs.fun/img-common/202312201846499.png" alt="红黑树" style="zoom:25%;" />

红黑树结构定义：

~~~c
struct RBnode {		//红黑树的结点定义
    int key;		//关键字的值
    RBnode* parent;	//父节点指针
    RBnode* lChild;	//左孩子指针
    RBnode* rChild;	//右孩子指针
    int color; 		//结点颜色， 如:可用0/1表示黑/红， 也可使用枚举型enum表示颜色
};
~~~

黑结点的高度：从某一结点出发（不包含该结点）到达任意空叶结点的路径上黑结点总数。由于红黑树特点我们只用看一条路径就可以知道该结点的黑结点高度。

若根节点黑高为$h$，内部结点数(关键字)最少有$2h-1$个.

<img src="https://image.sybblogs.fun/img-common/202312202155000.png" alt="红黑树黑高" style="zoom:25%;" />

**根据红黑树特点可以得到以下性质：**

1. 由上面`4,5`特点可以推出：从根节点到叶结点的最长路径不大于最短路径的$2$倍。即红黑树左右高度之差不会超过$2$倍。

2. 有$n$个内部节点的红黑树高度$h\le2\log_2(n+1)$

   证明：若红黑树总高度$=h$，则根结点黑高$\ge\frac{h}{2}$，因此内部结点数$n\ge 2^{\frac{h}{2}}-1$，由此推出$h\le2\log_2(n+1)$

红黑树的查找与BST、AVL 相同，从根出发，左小右大，若查找到一个空叶节点，则查找失败。

### 7.1 红黑树的插入

红黑树的插入和平衡二叉树有很多相似地方。

插入步骤：

- 先查找，确定插入位置（原理同二叉排序树），插入新结点
- 新结点是根，则染为黑色。如果新结点非根，则染为红色。
- 若插入新结点后树依然满足红黑树的定义，则插入结束
- 若插入新结点不满足红黑树定义，则需要进行调整，使其能重新满足红黑树定义。

如何调整：

- 找新插入结点的父结点的兄弟结点。

- 如果兄弟结点是黑色：旋转$+$染色。具体做法仍要判断新插入的结点从爷结点开始的类型：

  插入结点是$LL$型：父结点**右单旋**和爷结点交换，之后对两个结点**颜色取反**。

  插入结点是$RR$型：父结点**左单旋**和爷结点交换，之后对两个结点**颜色取反**。

  插入结点是$LR$型：新结点先左旋再右旋，儿子结点和爷结点交换，之后对两个结点**颜色取反**。

  插入结点是$RL$型：新结点先右旋再左旋，儿子结点和爷结点交换，之后对两个结点**颜色取反**。

- 如果兄弟结点是红色：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

注意：新结点在插入的时候如果需要调整一般都是违背了"不存在两个相邻的红结点"这一原则。

例子：从一棵空的红黑树开始，插入：20，10，5，30，40，57，3，2，4，35，25，18，22，23，24，19，18

1. 根结点必须是黑色，所以$20$结点插入：

   <img src="https://image.sybblogs.fun/img-common/202312211220124.png" alt="红黑树插入" style="zoom: 33%;" />

   上面蓝色框是新插入结点，下面两个叶子结点是`NULL`结点。

2. 为了保证某节点到叶子结点任意一条简单路径上黑色结点数量都相同，这一特性我们要将插入的非根结点都设置为**红色**。

   插入$10$结点：

   <img src="https://image.sybblogs.fun/img-common/202312211225007.png" alt="红黑树插入1" style="zoom: 33%;" />

3. 接着插入$5$结点：

   <img src="https://image.sybblogs.fun/img-common/202312211225965.png" alt="红黑树插入2" style="zoom: 33%;" />

   此时发现破环了，"不存在两个相邻的红结点"这一原则，需要进行调整，使其能重新满足红黑树定义。

   新结点$5$的父结点的兄弟结点是$NULL$，即黑色。并且新结点$4$相对于爷结点$20$是$LL$型，调整方法是：父结点右单旋和爷结点交换，之后对两个结点颜色取反。

   先右单旋：

   <img src="https://image.sybblogs.fun/img-common/202312211233778.png" alt="红黑树插入3" style="zoom: 33%;" />

   再对两个结点颜色取反：

   <img src="https://image.sybblogs.fun/img-common/202312211233986.png" alt="红黑树插入4" style="zoom: 33%;" />

4. 接着插入$30$

   <img src="https://image.sybblogs.fun/img-common/202312211234665.png" alt="红黑树插入5" style="zoom: 33%;" />

   新结点插入后破环了红黑树定义，违反了"不存在两个相邻的红结点"这一原则。

   新结点$30$的父结点的兄弟结点是$5$，即红色。调整方法是：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

   颜色取反：

   <img src="https://image.sybblogs.fun/img-common/202312211245325.png" alt="红黑树插入6" style="zoom: 33%;" />

   爷结点变为新结点，再判断红黑树是否满足定义。

   <img src="https://image.sybblogs.fun/img-common/202312211247095.png" alt="红黑树插入7" style="zoom: 33%;" />

   发现违背"根节点是黑色"这一原则。将新结点改为黑色即可。

   <img src="https://image.sybblogs.fun/img-common/202312211249925.png" alt="红黑树插入8" style="zoom: 33%;" />

5. 接着插入$40$结点

   <img src="https://image.sybblogs.fun/img-common/202312211251588.png" alt="红黑树插入9" style="zoom: 33%;" />

   同样是违背了"不存在两个相邻的红结点"这一原则。

   新结点$40$的父结点的兄弟结点是$NULL$，即黑色。并且新结点$40$相对于爷结点$20$是$RR$型，调整方法是：父结点**左单旋**和爷结点交换，之后对两个结点**颜色取反**。

   左单旋：

   <img src="https://image.sybblogs.fun/img-common/202312211254992.png" alt="红黑树插入10" style="zoom: 33%;" />

   颜色取反：

   <img src="https://image.sybblogs.fun/img-common/202312211255755.png" alt="红黑树插入11" style="zoom: 33%;" />

6. 插入结点$57$，同样违背了"不存在两个相邻的红结点"这一原则。

   <img src="https://image.sybblogs.fun/img-common/202312211256103.png" alt="红黑树插入12" style="zoom: 33%;" />

   新结点$57$的父结点的兄弟结点是$20$，即红色。调整方法是：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

   颜色取反：

   <img src="https://image.sybblogs.fun/img-common/202312211258279.png" alt="红黑树插入13" style="zoom: 33%;" />

   此时，$30$是新插入的结点，再次判断红黑树发现满足定义。

7. 接着插入$3$结点，满足红黑树定义，不需要调整。

   <img src="https://image.sybblogs.fun/img-common/202312211301227.png" alt="红黑树插入14" style="zoom: 33%;" />

8. 插入结点$2$，违背了"不存在两个相邻的红结点"这一原则。

   <img src="https://image.sybblogs.fun/img-common/202312211302335.png" alt="红黑树插入15" style="zoom: 33%;" />

   新结点$2$的父结点的兄弟结点是$NULL$，即黑色。并且新结点$2$相对于爷结点$5$是$LL$型，调整方法是：父结点右单旋和爷结点交换，之后对两个结点颜色取反。

   右单旋：

   <img src="https://image.sybblogs.fun/img-common/202312211304724.png" alt="红黑树插入16" style="zoom: 33%;" />

   颜色取反：

   <img src="https://image.sybblogs.fun/img-common/202312211304285.png" alt="红黑树插入17" style="zoom: 33%;" />

9. 接着插入结点$4$，同样违背了"不存在两个相邻的红结点"这一原则。

   <img src="https://image.sybblogs.fun/img-common/202312211305163.png" alt="红黑树插入18" style="zoom: 33%;" />

   新结点$4$的父结点的兄弟结点是$2$，即红色。调整方法是：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

   颜色取反：

   <img src="https://image.sybblogs.fun/img-common/202312211307803.png" alt="红黑树插入19" style="zoom: 33%;" />

   此时，$3$是新插入的结点，再次判断红黑树发现满足定义。

10. 接着插入的结点$35$，$25$，$18$都没有违背红黑树定义。

    <img src="https://image.sybblogs.fun/img-common/202312211309249.png" alt="红黑树插入20" style="zoom: 33%;" />

11. 插入结点$22$，违背了"不存在两个相邻的红结点"这一原则。

    <img src="https://image.sybblogs.fun/img-common/202312211310535.png" alt="红黑树插入21" style="zoom: 50%;" />

    新结点$22$的父结点的兄弟结点是$18$，即红色。调整方法是：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

    颜色取反：

    <img src="https://image.sybblogs.fun/img-common/202312211311150.png" alt="红黑树插入22" style="zoom: 50%;" />

    $20$变为新结点，再次检查发现同样违背了"不存在两个相邻的红结点"这一原则。其父结点的兄弟结点是$3$，即红色。调整方法是：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

    颜色取反：

    <img src="https://image.sybblogs.fun/img-common/202312211313883.png" alt="红黑树插入23" style="zoom: 50%;" />

    新结点变为$10$，再次检查发现违背了"根节点是黑色"这一原则，将根结点$10$颜色取反即可

    <img src="https://image.sybblogs.fun/img-common/202312211315735.png" alt="红黑树插入24" style="zoom: 50%;" />

12. 插入结点$23$，发现违背了"不存在两个相邻的红结点"这一原则。

    <img src="https://image.sybblogs.fun/img-common/202312211316508.png" alt="红黑树插入25" style="zoom: 33%;" />

    新结点$23$的父结点的兄弟结点是$NULL$，即黑色。并且新结点$23$相对于爷结点$25$是$LR$型，调整方法是：新结点先左旋再右旋，儿子结点和爷结点交换，之后对两个结点**颜色取反**。

    先左旋：

    <img src="https://image.sybblogs.fun/img-common/202312211320095.png" alt="红黑树插入26" style="zoom:25%;" />

    再右旋：

    <img src="https://image.sybblogs.fun/img-common/202312211321161.png" alt="红黑树插入27" style="zoom:25%;" />

    颜色取反：

    <img src="https://image.sybblogs.fun/img-common/202312211322320.png" alt="红黑树插入28" style="zoom:25%;" />

13. 接着插入结点$24$，违背了"不存在两个相邻的红结点"这一原则。

    <img src="https://image.sybblogs.fun/img-common/202312211323735.png" alt="红黑树插入29" style="zoom:25%;" />

    新结点$24$的父结点的兄弟结点是$22$，即红色。调整方法是：则父结点，父结点的兄弟节点、爷结点颜色取反$+$爷结点变为新结点，再判断新结点能不能满足红黑树定义。如果不能再接着重复上面调整方法。

    颜色取反：

    <img src="https://image.sybblogs.fun/img-common/202312211324547.png" alt="红黑树插入30" style="zoom:25%;" />

    此时新结点变为$23$，再次检查发现同样违背了"不存在两个相邻的红结点"这一原则。其父结点的兄弟结点$40$，即黑色。并且新结点$23$相对于爷结点$25$是$LR$型，调整方法是：新结点先左旋再右旋，儿子结点和爷结点交换，之后对两个结点**颜色取反**。

    先左旋：

    <img src="https://image.sybblogs.fun/img-common/202312211328716.png" alt="红黑树插入31" style="zoom:25%;" />

    再右旋：

    <img src="https://image.sybblogs.fun/img-common/202312211329451.png" alt="红黑树插入32" style="zoom:25%;" />

    颜色取反：

    <img src="https://image.sybblogs.fun/img-common/202312211329072.png" alt="红黑树插入33" style="zoom:25%;" />

14. 插入$19$结点

    <img src="https://image.sybblogs.fun/img-common/202312211640918.png" alt="红黑树插入34" style="zoom: 33%;" />

15. 最后结点$18$可以插入红黑树内$18$结点左子树或者右子树

    <img src="https://image.sybblogs.fun/img-common/202312211641026.png" alt="红黑树插入35" style="zoom:25%;" />

    新结点$18$的父结点的兄弟结点是$NULL$，即黑色。并且新结点$18$相对于爷结点$18$是$RL$型，调整方法是：新结点先右旋再左旋，儿子结点和爷结点交换，之后对两个结点**颜色取反**。

    先右旋：

    <img src="https://image.sybblogs.fun/img-common/202312211645624.png" alt="红黑树插入36" style="zoom:25%;" />

    再左旋：

    <img src="https://image.sybblogs.fun/img-common/202312211645797.png" alt="红黑树插入37" style="zoom: 33%;" />

    颜色取反：

    <img src="https://image.sybblogs.fun/img-common/202312211646347.png" alt="红黑树插入38" style="zoom: 33%;" />

将所有元素插入红黑树完毕。

### 7.3 红黑树的删除

重要考点：

①红黑树删除操作的时间复杂度$=O(\log_2n)$

②在红黑树中删除结点的处理方式和"二叉排序树的删除"一样

③按②删除结点后，可能破坏"红黑树特性"，此时需要调整结点颜色、位置，使其再次满足"红黑树特性"。

## 8. B树

由前面的二叉排序树可以知道，二叉树中每个结点都可以将查找范围缩小到两个区间内。

<img src="https://image.sybblogs.fun/img-common/202312081830522.png" alt="二叉排序树查找效率分析失败情况" style="zoom:25%;" />

而B树就是拥有更多分支结点的树。具体定义如下：

$B$树，又称**多路平衡查找树**，$B$树中所有结点的孩子个数的最大值称为$B$树的阶，通常用$m$表示。一棵$m$阶$B$树或为空树，或为满足如下特性的m叉树：

1. 在$m$叉查找树中，规定除了根节点外，**任何结点至少有$\lceil m/2\rceil$个分叉，并且至少含有$\lceil m/2\rceil-1$个关键字**，至多含有$m-1$个关键字。

   这样构造出来的多叉树就是B树。这样规定是因为若每个结点内关键字太少，导致树变高，要查更多层结点，导致效率低。

2. $m$叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同。

3. 若根结点不是终端结点，则至少有两棵子树。

4. 树中每个结点至多有$m$棵子树，即至多含有$m-1$个关键字。

5. 所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。

<img src="https://image.sybblogs.fun/img-common/202312211746073.png" alt="B树定义" style="zoom:25%;" />

假设有一颗$5$叉树，则其每个结点至少有$\lceil 5/2\rceil=3$个分支，至少含有$\lceil 5/2\rceil-1=2$个关键字。

<img src="https://image.sybblogs.fun/img-common/202312211715943.png" alt="B树" style="zoom:25%;" />

上面是一个$5$叉查找树。其代码定义结构如下：

~~~c
//5叉排序树的结点定义
struct Node {
    ElemType keys[4];//最多4个关键字
    struct Node * child[5]; //最多5个孩子
    int num;//结点中有几个关键字
};
~~~

查找步骤如下：查找$9$元素

1. 从根结点出发，根结点关键字$22>9$，所以只可能在根结点左子树。
2. 左子树有$5$，$11$两个关键字，遍历所有关键字$11>9>5$，所以可能在关键字$5$和$11$中间指针指向子树。
3. 最下一层子树关键字是$6,8,9$遍历关键字成功找到元素。

注：如果一个结点包含关键字有多个，可以用折半查找。

再查找$41$元素：

1. 根结点$22<41$，所以只可能再根结点右子树
2. 右子树结点内关键字有$36,45$，遍历$36<41<45$。故可能在关键字$36$和$45$中间指针指向子树。
3. 最下一层子树关键字$40,42$，而$40<41<42$，所以可能在两个关键字中间指针指向子树
4. 而中间指针最后指向$NULL$，是失败结点，返回查找失败，未找到。

==$m$阶$B$树的核心特性==：

1. 根节点的子树数$\in[2, m]$，关键字数$\in[1, m-1]$。其他结点的子树数$\in\Big[\lceil m/2\rceil, m\Big]$；关键字数$\in\Big[\lceil m/2\rceil-1, m-1\Big]$
2. 对任一结点，其所有子树高度都相同
3. 关键字的值：子树$0<$关键字$1<$子树$1<$关键字$2<$子树$2<\dots$ (类比二叉查找树左$<$中$<$右)。即每个结点指针和关键字之间存储结构。

**B树的高度**（这里计算B树的高度不计算叶子结点(失败结点)）：

含$n$个关键字的$m$阶$B$树，最小高度：让每个结点尽可能的满，有$m-1$个关键字， $m$个分叉，则有
$$
\begin{equation*}
	\begin{aligned}
&n\le(m-1)(1+m+m^2+m^3+\cdots+m^{h-1})=m^h-1\\
\\
&\therefore h\ge \log_m(n+1)
	\end{aligned}
\end{equation*}
$$
含$n$个关键字的$m$阶$B$树，最大高度：让各层的分叉尽可能的少，即根节点只有$2$个分叉，其他结点只有$\lceil \frac{m}{2}\rceil$个分叉。
各层结点至少有：第一层有$1$个结点、第二层有$2$个结点、第三层$2\lceil\frac{m}{2}\rceil\cdots$第$h$层$2(\lceil\frac{m}{2}\rceil)^{h-2}$。
第$h+1$层共有叶子结点(失败结点)$2(\lceil\frac{m}{2}\rceil)^{h-1}$个。
$n$个关键字的B树必有$n+1$（$n$个关键字将数据域切分为$n+1$个区间）个叶子结点，则$n+1\ge2(\lceil\frac{2}{m}\rceil)^{h-1}$，即$h\le\log_{\lceil\frac{2}{m}\rceil}\frac{n+1}{2}+1$

还可以从另一个角度分析：

含$n$个关键字的$m$阶$B$树，最大高度：即让每个结点包含的关键字、分叉尽可能的少。记$k=\lceil \frac{m}{2}\rceil$

<img src="https://image.sybblogs.fun/img-common/202312212229881.png" alt="B树高度" style="zoom:25%;" />

$h$层的$m$阶$B$树至少包含关键字总数$1+2(k-1)(k^0+k^1+k^2+\cdots+k^{h-2}) = 1+2(k^{h-1}-1)$

若关键字总数少于这个值，则高度一定小于$h$，因此$n\ge1+2(k^{h-1}-1)$化简可得：
$$
h\le\log_{k}\frac{n+1}{2}+1=\log_{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}+1
$$
总结：**含$n$个关键字的$m$阶$B$树，最大高度和最小高度：**
$$
\log_{m}(n+1)\le h\le\log_{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}+1
$$

### 8.1 B树的插入

插入核心要求：

1. 结点关键字个数$\lceil\frac{m}{2}\rceil-1\le n\le m-1$。即$2\le n\le4$
2. 每个结点符合有序的特性

插入步骤：

> 在插入key后，若导致原结点关键字数超过上限，则从中间位置$(\lceil\frac{m}{2}\rceil)$将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置$(\lceil\frac{m}{2}\rceil)$的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度会增加$1$。

下面演示$5$阶$B$树的插入：

首先插入$25,38,49,60$三个关键字，插入后如下：

<img src="https://image.sybblogs.fun/img-common/202312241707316.png" alt="B树插入" style="zoom:25%;" />

接着再插入$80$，由于5阶B树每个结点关键字个数最多为$4$，所以$80$关键字导致原结点关键字数超过上限，**则从中间位置$(\lceil\frac{m}{2}\rceil)$将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置$(\lceil\frac{m}{2}\rceil)$的结点插入原结点的父结点。**

<img src="https://image.sybblogs.fun/img-common/202312241712540.png" alt="B树插入1" style="zoom:25%;" />

- 此时中间位置关键字为$49$，则$49$称为新的根结点，$25,38$为其左子树；$60,80$为其右子树

  <img src="https://image.sybblogs.fun/img-common/202312241713206.png" alt="B树插入2" style="zoom:25%;" />

接着**新元素一定是插入到最底层"终端节点"，用"查找"来确定插入位置。**

- 插入新关键字$90$，$90>49$，所以插入位置在关键字$49$的右子树；$60<80<90$插入最右边

  <img src="https://image.sybblogs.fun/img-common/202312241717229.png" alt="B树插入3" style="zoom:25%;" />

关键字$99$和$88$插入操作相同

<img src="https://image.sybblogs.fun/img-common/202312241727877.png" alt="B树插入4" style="zoom:25%;" />

当$88$关键字插入后导致结点关键字超出$5$阶B树上限，所以和上面一样，结点中间的关键字$88$提到上一层结点上。$60,80$为其左子树；$90,99$为其右子树

<img src="https://image.sybblogs.fun/img-common/202312241731831.png" alt="B树插入5" style="zoom:25%;" />

继续插入关键字$83,70$，这两个关键字不影响B树平衡所以直接插入

<img src="https://image.sybblogs.fun/img-common/202312251540905.png" alt="B树插入6" style="zoom:25%;" />

接着插入关键字$70$

<img src="https://image.sybblogs.fun/img-common/202312251541455.png" alt="B树插入7" style="zoom:25%;" />

- 当$70$关键字插入后导致结点关键字超出$5$阶B树上限，所以和上面一样，结点中间的关键字$80$提到上一层结点上，同时上一层结点也要内关键字满足B树特点，故插入在$49,88$中间的位置。$60,70$为其左子树；$83,87$为其右子树。

  <img src="https://image.sybblogs.fun/img-common/202312251545903.png" alt="B树插入8" style="zoom: 33%;" />

继续插入$92,93,94$三个关键字

<img src="https://image.sybblogs.fun/img-common/202312251546273.png" alt="B树插入9" style="zoom:25%;" />

- 当$94$关键字插入后导致结点关键字超出$5$阶B树上限，所以和上面一样，结点中间的关键字$93$提到上一层结点上。$90,92$为其左子树；$94,99$为其右子树。

  <img src="https://image.sybblogs.fun/img-common/202312251548233.png" alt="B树插入10" style="zoom:25%;" />

插入关键字$73,74,75$

<img src="https://image.sybblogs.fun/img-common/202312251549858.png" alt="B树插入11" style="zoom:25%;" />

- 当$75$关键字插入后导致结点关键字超出$5$阶B树上限，所以和上面一样，结点中间的关键字$73$提到上一层结点上，同时上一层结点也要内关键字满足B树特点，故插入在$49,80$中间的位置。$60,70$为其左子树；$74,75$为其右子树。

  <img src="https://image.sybblogs.fun/img-common/202312251551739.png" alt="B树插入12" style="zoom:25%;" />

- 此时发现刚刚插入关键字$75$的父结点，关键字超出$5$阶B树上限。继续将其中间关键字$80$提到上一层新的结点。$49,73$为其左子树，$88,93$为其右子树。

  <img src="https://image.sybblogs.fun/img-common/202312251559503.png" alt="B树插入13" style="zoom:25%;" />

### 8.2 B树的删除

删除关键字操作分情况：

- 如果删除的关键字位于终端结点，且不会破坏B树关键字个数特性，**可以直接删除**。如上面$5$阶B树删除关键字$60$，由于位于终端节点且不会破环结点关键字个数$2\le n\le4$的特性。所以直接删除。

  <img src="https://image.sybblogs.fun/img-common/202312251604892.png" alt="B树插入14" style="zoom:25%;" />

- 如果删除的关键字位于根结点，可以**找该关键字的直接前驱或直接后继，顶替这个位置**。直接前驱：当前关键字左侧指针所指子树中"最右下"的元素。直接后继：当前关键字右侧指针所指子树中"最左下"的元素。

  如删除$80$关键字，$80$关键字直接前驱是$77$，直接后继是$82$，所以这两个关键字任选一个替代$80$的位置即可。

  <img src="https://image.sybblogs.fun/img-common/202312251608975.png" alt="B树的删除2" style="zoom:25%;" />

  所以，对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作。

- 如果删除的关键字位于终端结点，但删除完后破坏B树关键字个数特性，则：

  如果兄弟结点够借：若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右(或左) 兄弟结点的关键字个数还很宽裕，则需要调整该结点、**右(或左)兄弟结点及其双亲结点(父子换位法)**。再具体一点做法是(这里是中序遍历)：

  1. 当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺
  2. 当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺

  如：删除关键字$38$后，将右兄弟节点的$70$，顶替双亲结点$49$的位置，$49$关键字顶替$38$位置。

  <img src="https://image.sybblogs.fun/img-common/202312251614844.png" alt="B树的删除3" style="zoom:25%;" />

  删除$90$关键字，其结点右兄弟结点$94,99$，其左兄弟结点关键字多。所以用$90$的前驱$88$顶替$90$的位置，前驱的前驱$87$顶替$88$的位置。

  <img src="https://image.sybblogs.fun/img-common/202312251621224.png" alt="B树的删除4" style="zoom:25%;" />

- 如果删除的关键字位于终端结点，删除完后破坏B树关键字个数特性，且其左右兄弟结点关键字都不够替换时，**则将删除关键字的结点与左（或右）兄弟结点及双亲结点中的关键字进行合并**。在合并过程中，双亲结点中的关键字个数会减$1$。如果双亲结点关键字个数减少到$\lceil\frac{m}{2}\rceil-1$，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。

  如：删除$49$关键字，双亲结点$70$顶替$49$位置，$71,72$关键字放在$70$后面位置。

  <img src="https://image.sybblogs.fun/img-common/202312251625506.png" alt="B树的删除5" style="zoom:25%;" />

  此时可以看到，父结点就剩一个关键字$73$，低于B树关键字个数，所以也要进行合并。具体将$82$关键字插入$73$后面，$87,93$插入再$82$后面

  <img src="https://image.sybblogs.fun/img-common/202312251627098.png" alt="B树的删除6" style="zoom:25%;" />

  由于父结点内没有关键字，可以删除该结点

  <img src="https://image.sybblogs.fun/img-common/202312251628267.png" alt="B树的删除7" style="zoom:25%;" />

## 9. $B^+$树

$b^+$树和分块查找很相似，每个结点内部分块，都保存对应指针指向结点的最大值。

一颗$m$阶$B^+$需要满足以下条件：

1. **非叶根结点至少有两棵子树**，其他每个分支结点**至少**有$\lceil\frac{m}{2}\rceil$棵子树。和$B$树一样可以理解为：要追求"绝对平衡"，即所有子树高度要相同。

2. 每个分支结点最多有$m$棵子树(孩子结点)。

3. 所有分支结点中仅包含它的各个**子结点中关键字的最大值**及指向其子结点的指针。

4. **结点的子树个数与关键字个数相等**。这是与$B$树最多区别。如：一个结点有两个关键字，则$B^+$树有两个分支，$B$树有三个分支。

5. 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。

   <img src="https://image.sybblogs.fun/img-common/202312251642957.png" alt="B+树叶子结点" style="zoom: 33%;" />

如下是一颗$4$阶的$B^+$树：

<img src="https://image.sybblogs.fun/img-common/202312251643773.png" alt="B+树" style="zoom:25%;" />

### 9.1 $B^+$树的查找

如下是一颗$4$阶的$B^+$树：

<img src="https://image.sybblogs.fun/img-common/202312251643773.png" alt="B+树" style="zoom:25%;" />

查找关键字$9$：

1. 从根节点开始$9<15$，所以只可能在$15$关键字指向的结点$3,9,15$内出现。

   <img src="https://image.sybblogs.fun/img-common/202312251647704.png" alt="B+树叶子查找1" style="zoom:25%;" />

2. 接着遍历这一层结点，发现有关键字$9$，但$B^+$树没有遍历到叶子结点内记录的信息不算查找成功，所以接着查找$9$指向的结点$6,8,9$

3. 这一层是叶子结点，从左往右依次遍历，找打关键字$9$，读取其对应指针内的记录即可。而如果是$B$树，到这里就查找成功，不用再找下一层的叶子结点。

   <img src="https://image.sybblogs.fun/img-common/202312251651249.png" alt="B+树叶子查找2" style="zoom:25%;" />

   $B$树的记录：

   <img src="https://image.sybblogs.fun/img-common/202312251705368.png" alt="B的记录" style="zoom:25%;" />

$B^+$树中，无论查找成功与否，最终一定都要走到最下面一层结点。

除了上面介绍的多路查找，还可以进行顺序查找。因为叶子结点有一个指针$P$，该指针连接所有叶子结点，所以可以直接从$P$结点往后茶找每个结点中的关键字，知道找到对应的关键字即可。

### 9.2 $B^+$树与$B$树区别

|                          $m$阶$B$树                          |                         $m$阶$B^+$树                         |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|              结点中的$n$个关键字对应$n+1$棵子树              |               结点中的$n$个关键字对应$n$棵子树               |
| 每个结点关键字个数不能低于$\lceil\frac{m}{2}\rceil-1$，不能大于$m-1$，但根结点个数可以只有一个 | 每个结点关键字个数不能低于$\lceil\frac{m}{2}\rceil$，不能大于$m$，但根结点个数可以只有一个 |
|           在B树中，各结点中包含的关键字是不重复的            | 叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中 |
|        B树的结点中都包含了关键字对应的记录的存储地址         | 叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。 |

$B^+$树比$B$树查询效率更高：在$B^+$树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得$B^+$树的阶更大，树高更矮，读磁盘次数更少，查找更快。

<img src="https://image.sybblogs.fun/img-common/202312251713842.png" alt="B+树总结" style="zoom:25%;" />

## 10. 哈希表

散列表(Hash Table)，又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。

例：有一堆数据元素，关键字分别为$\{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79\}$，散列函数为$H(key)=key\%13$，这个函数会将关键字范围限定在$0\sim 12$范围内。

具体步骤是让每个关键字对$13$取余，所得的值就是数组下标索引值，将关键字放入索引对应的数组位置即可。但取余操作会有以下两种情况：

1. 若不同的关键字通过散列函数映射到同一个值，则称它们为"同义词"
2. 通过散列函数确定的位置已经存放了其他元素，则称这种情况为"冲突"

解决哈希冲突，是哈希表的关键。

### 10.1 拉链法解决哈希冲突

用拉链法(又称链接法、链地址法)处理冲突：把所有"同义词"存储在一个链表中。这也是实际开发中常用的方法。

<img src="https://image.sybblogs.fun/img-common/202312251725079.png" alt="拉链发解决哈希冲突" style="zoom:25%;" />

如上面，散列函数为$H(key)=key\%13$，关键字分别为$\{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79\}$。其中关键字$14$和$1$对$13$取余，所得的值都为$1$，出现哈希冲突，用拉链法就是将关键字通过链表的形式放在同一个索引位置。

存储所有关键字后哈希表结构如下：

<img src="https://image.sybblogs.fun/img-common/202312251728757.png" alt="拉链发解决哈希冲突1" style="zoom:25%;" />

拉链法的查找方法是，首先基于散列函数计算出被查找关键字的哈希值。根据哈希值找到对应数组索引位置，如果存放的是链表则遍历看是否有被查找关键字。

如，上面哈希表查找关键字$27$，首先对$27\%13=1$，接着遍历数组索引$1$内存放的链表

<img src="https://image.sybblogs.fun/img-common/202312251731050.png" alt="拉链发查找" style="zoom:25%;" />

这里要引入查找长度概念：在查找运算中， 需要对比关键字的次数称为查找长度。上面查找$27$关键字的查找长度为$3$。如果查找计算的哈希值对应数组索引位置内记录的链表为$NULL$，则表示查找失败，且此时查找失败的查找长度为$0$。

如上哈希表的平均查找长度$ASL=\frac{1\times6+2\times4+3\times1+4\times}{12}=1.75$。分子代表的是所有关键字需要查找的次数总和，分母表示关键字个数。$1\times6$表示第一行有$6$个元素，$2\times4$表示第二行有$4$个元素。

哈希表查找失败的平均查找长度$ASL=\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{13}=0.92$。分子代表每个索引处查找失败的对比次数，也就是哈希表所有关键字的总数；分母表示数组总长度，每个索引位置可能需要查找的概率为$\frac{1}{13}$。

上面这个$ASL_{失败}$就是**装填因子$\alpha=$表中记录数$/$散列表长度**。装填因子值越大代表散列表装的关键字越多。

通过上面对查找长度和平均查找长度的计算，可以知道哈希冲突会导致查询效率变低。且查找长度越大，代表冲突越大，查找效率越低。

最理想情况：只要哈希函数设计的足够好，哈希查找的时间复杂度可达到$O(1)$。即查找长度都为$1$。

如果拉链法中链表元素采用顺序存储方式，可以提高查找效率。

### 10.2 常见的哈希函数

哈希函数的设计可以直接决定一个哈希表的查找效率，所以哈希函数设计很重要，下面介绍几种常见的哈希函数。

#### 除留余数法

$H(key)=key\%p$，散列表的长度为$m$，取一个不大于$m$但最接近或等于$m$的质数$p$。

例如：散列表表长$13$，则散列函数$H(key)=key\%13$

散列表表长$15$，则散列函数$H(key)=key\%13$。因为不大于$15$但接近于$15$的质数是$13$。

这样设计的原因是：质数分布更均匀，冲突更少。参见《数论》。大致原因是和数的公因子多，所以冲突概率更高。

#### 直接定址法

$H(key)=key$或$H(key)=a*key+b$

其中，$a$和$b$是常数。这种方法计算最简单，且不会产生冲突。它**适合关键字的分布基本连续的情况**，若关键字分布不连续，空位较多，则会造成存储空间浪费。

例如：存储同一个班级的学生信息，班内学生学号为$(1120112176\sim 1120112205)$，即有三十个学生，学号后三位从$176$开始。此时的哈希函数为：$H(key)=key-1120112176$。每个学号都和第一个人的学号相减的值即为数组索引位置。存储如下：

<img src="https://image.sybblogs.fun/img-common/202401021458356.png" alt="直接定址法" style="zoom:25%;" />

#### 数字分析法

选取数码分布较为均匀的若干位作为散列地址。

设关键字是r进制数(如十进制数)，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等，而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合,若更换了关键字，则需要重新构造新的散列函数。

例如：以"手机号码"作为关键字设计散列函数

<img src="https://image.sybblogs.fun/img-common/202401021509928.png" alt="数字分析法" style="zoom:25%;" />

#### 平方取中法

取关键字的平方值的中间几位作为散列地址。

具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

例如：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数

<img src="https://image.sybblogs.fun/img-common/202401021539181.png" alt="平方取中法" style="zoom:25%;" />

尽管这里表的长度十万，但还是有冲突的可能性。要完全解决哈希冲突，方法是设计的表要足够长，但这样空间复杂度也会很高，所以散列查找是一个典型的"空间换时间的"算法。

### 10.3 开放定址法解决哈希冲突

所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：
$$
H_i=(H(key)+d_i)\%m
$$
其中$i=0,1,2\cdots,k(k\le m-1)$，$m$表示散列表表长。$d_i$为增量序列。$i$可以理解为第$i$次发生冲突。

关于增量序列$d_i$计算有三种：

- 线性探测法
- 平方探测法
- 伪随机序列法

开放地址法删除关键字：**删除关键字不能只是简单的删除而是标记删除**

#### ==线性探测法==

$d_i=0,1,2,3,\cdots,m-1$；即发生冲突时，每次往后探测相邻的下一个单元是否为空。

例：有一堆数据元素，关键字分别为$\{19,14,23,1,68,20,84,27,55,11,10,79\}$，哈希函数是$H(key)=key\%13$

冲突处理函数为：$H_i=(H(key)+d_i)\%16$

- 前三个关键字没有发生冲突直接放入

  <img src="https://image.sybblogs.fun/img-common/202401031454969.png" alt="开放定址法" style="zoom:25%;" />

- 关键字$1$，$H(1)=1\%13=1$，发生冲突；采用线性探测法，由于第一次发生冲突$d_1=1$。$H_1=(1+1)\%16=2$，没有冲突直接放入索引为$2$位置

  <img src="https://image.sybblogs.fun/img-common/202401031459977.png" alt="开放定址法1" style="zoom:25%;" />

- 接着关键字$68,20$不会发生冲突，直接放入。

  <img src="https://image.sybblogs.fun/img-common/202401031501672.png" alt="开放定址法2" style="zoom:25%;" />

- 关键字$84$，$H(84)=84\%13=6$，发生冲突；第一次发生冲突$d_1=1$。$H_1=(6+1)\%16=7$，仍然冲突；第二次发生冲突$d_2=2$。$H_2=(6+2)\%16=8$。没有冲突放入

  <img src="https://image.sybblogs.fun/img-common/202401031503250.png" alt="开放定址法2" style="zoom:25%;" />

- 之后方法类似。但要注意的是本题中哈希函数值域是$[0,12]$，冲突处理函数值域是$[0,15]$

  <img src="https://image.sybblogs.fun/img-common/202401031509368.png" alt="开放定址法4" style="zoom:25%;" />

查找方法和插入方法一样，例如查找$27$关键字：

$27\%13=1$，数组索引为$1$的位置关键字是$14$查找失败。接着$H_1=(1+1)\%16=2$，索引$2$位置是关键字$1$，查找失败。$H_2=(1+2)\%16=3$，索引$3$处的关键字是$68$，查找失败。$H_3=(1+3)\%16=4$，索引为$4$位置是关键字$27$，查找成功。故$27$的查找长度是$4$。

注意如果$H_i$结果索引值指向位置关键字是空的，此时查找失败，但也要算作一次比较次数。所以在查找失败情况下，越早遇到空位置就可以越早确定查找失败，查找效率会提高。

删除关键字：**删除关键字不能只是简单的删除还要标记删除**

例如：删除关键字$1$。查找关键字$27$

<img src="https://image.sybblogs.fun/img-common/202401031521450.png" alt="开放定址法5" style="zoom:25%;" />

计算$H(27)=27\%13=1$，$1$位置发生冲突；计算$H_1=(1+1)\%13=2$，$2$的位置是空，所以按照上面条件：`索引值指向位置关键字是空的，此时查找失败`。但明显可以看到$27$这个关键字真是存在，故采用"开放定址法"时，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个"删除标记"，进行逻辑删除。

这种方法也有弊端：假设将表的前$8$个关键字删除，再找关键字$79$：

<img src="https://image.sybblogs.fun/img-common/202401031527330.png" alt="开放定址法6" style="zoom:25%;" />

此时发现，虽然前$8$个关键字都删除了，但由于是逻辑删除，仍会进行对比$9$次才能找到$79$这个关键字。所以这个哈希表看起来很满，但实际上很空。很多关键字在逻辑上被删除了。

查找成功平均查找长度：先算出每个关键字能被查找到的次数，再关键字的长度即可。

<img src="https://image.sybblogs.fun/img-common/202401031531833.png" alt="开放定址法查找成功平均查找长度" style="zoom:25%;" />
$$
ASL_{成功}=\frac{1+1+1+2+4+1+1+3+3+1+3+9}{12}=2.5
$$
查找失败平均查找长度：如果刚开始是在索引$0$的位置，那么查找第一次就会失败。如果是$1$位置，我们要将$1$后面所有关键字都对比才能确定失败，所以是$13$，其他位置以此类推。最后相加除哈希映射区间长度。这里哈希函数区间长度$13$。故
$$
ASL_{失败}=\frac{1+13+12+11+10+9+8+\cdots+2}{13}=7
$$
可以看出线性探测法查找效率很低，因为线性探测法很容易造成同义词、非同义词的"聚集(堆积)"现象，严重影响查找效率。出现这一现象根本原因是冲突后再探测一定是放在某个连续的位置。

#### ==平方探测法==

平方探测法可以有效解决聚集的问题。

$d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$时，称为平方探测法，又称二次探测法其中$k\le\frac{m}{2}$

例：哈希函数是$H(key)=key\%13$，采用平方探测法处理冲突。冲突处理函数为：$H_i=(H(key)+d_i)\%16$

<img src="https://image.sybblogs.fun/img-common/202401031648184.png" alt="平方探测法" style="zoom:25%;" />

上面$6$个关键字都哈希函数值都是$6$，产生冲突，采用平方探测法解决：

- 关键字$19$，冲突一次，所以$H_1=(6+1)\%27=7$，位置$7$没有元素无冲突直接放入。

  <img src="https://image.sybblogs.fun/img-common/202401031651349.png" alt="平方探测法1" style="zoom:25%;" />

- 关键字$32$，哈希值是$6$，由于$7$位置有元素，所以冲突两次$H_2=(6-1)\%27=5$，位置$5$没有元素无冲突直接放入。

  <img src="https://image.sybblogs.fun/img-common/202401031653484.png" alt="平方探测法2" style="zoom:25%;" />

- 后序元素方法类似。

  $45$关键字：$H_3=(6+4)\%27=10$

  $58$关键字：$H_4=(6-4)\%27=2$

  $71$关键字：$H_5=(6+9)\%27=15$

  $84$关键字：$H_6=(6-9)\%27=-3$，倒数第三个位置，即$24$

查找方法同插入方法，都是取余后根据冲突次数计算$H_i$。

==注意==：当采用开放定址法时，哈希表的长度必须是一个可以用$4i+3$表示的质数。只有满足这个条件才能探测到所有位置。

#### 伪随机序列法

$d_i$是一个伪随机序列，如$d_i=0,5,24,11,\cdots$

这个随机序列就是计算冲突函数$H-i$中$d_i$的值。

### 10.4 再哈希法

除了原始的哈希函数$H(key)$之外，多准备几个哈希函数，当哈希函数冲突时，用下一个哈希函数计算一个新地址，知道不冲突为止。
$$
H_i=RH_i(key)\\
\\
i=1,2,3,\cdots,k
$$
