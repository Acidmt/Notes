[toc]

# 一. 绪论

主要考察时间复杂度和空间复杂度的分析与计算。熟记数据结构三要素即分类。

## 数据结构三要素

数据结构三要素是逻辑结构、存储结构、数据的运算。

可以用**抽象的数据类型**定义一个完整的数据结构。

- 逻辑结构

  从逻辑上描述数据与存储无关。逻辑结构分为：**线性逻辑结构和非线性逻辑**结构。

  其中线性表是典型的线性逻辑结构。而集合、树和图是典型的非线性结构。

  <img src="https://image.sybblogs.fun/img-common/202403101346585.jpg" alt="数据的逻辑结构分类图" style="zoom:25%;" />

  4类基本结构关系：

  <img src="https://image.sybblogs.fun/img-common/202403101349441.jpg" alt="4类基本结构关系" style="zoom: 15%;" />

- 存储结构

  是指数据结构在计算机中的表示，也叫物理结构。是用计算机语言实现的逻辑结构，依赖于计算机语言。

  存储结构主要有：顺序存储、链式存储、索引存储和散列存储。

  1. 顺序存储

     将逻辑上相邻的元素存储在物理位置也相邻的存储单元中，数据元素之间的逻辑关系由元素的存储位置来表示。

     如：C语言中用数组来实现顺序存储结构。

     结构优点是：可以实现随机存取，每个元素占用最少的存储空间。缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。

  2. 链式存储

     不要求逻辑上相邻的元素在物理位置上也相邻，借助指针实现元素之间的逻辑关系。

     优点是：不会出现外部碎片，能充分利用所有存储单元。缺点是每个元素因存储指针而额外占用存储空间，且只能实现顺序存取。

  3. 索引存储

     在存储结点信息的同时，还建立附加的索引表。通俗讲索引就是目录，一般形式是：关键字$+$地址。

     若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引。

     <img src="https://image.sybblogs.fun/img-common/202304162013420.png" alt="索引存储结构2" style="zoom: 25%;" />

     优点是：检索速度快。缺点是附加的索引表额外占用存储空间，另外增加和删除数据时也要修改索引表，会花费较多时间。

  4. 散列存储

     根据结点的关键字直接计算出该结点的存储地址。如：哈希表。

     优点是：检索、增加和删除结点的操作很快。缺点是若散列函数设计不好，则可以出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

注意：数据的逻辑结构独立于其存储结构。而数据的存储结构不能独立于逻辑结构而存在。另外在存储数据时，不仅要存储数据元素的值，还要存储数据元素之间的关系。

问题$1$：对于两种不同的数据结构，逻辑结构或物理结构一定不相同吗？

> 应该注意到，数据的运算也是数据结构的一个重要方面。
>
> 对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同。比如二又树和二叉排序树，二叉排序树可以采用二叉树的逻辑表示和存储方式，前者通常用于表示层次关系，而后者通常用于排序和查找：虽然它们的运算都有建立树、插入结点，删除结点和查找结点等功能，但对于二叉树和二叉排序树，这些运算的定义是不同的，以查找结点为例，二叉树的时间复杂度为$O(n)$，而二叉排序树的时间复杂度为$O(\log_2n)$。

问题$2$：试举一例，说明对相同的逻辑结构，同一种运算在不同的存储方式下实现时，其运算效率不同。

> 线性表既可以用顺序存储方式实现，又可以用链式存储方式实现．在顺序存储方式下，在线性表中插入和删除元素，平均要移动近一半的元素，时间复杂度为面在链式存储方式下，插入和删除的时间复杂度都是$O(1)$

## 算法和算法评价

算法是对特定问题求解步骤的一种描述。

如果一个算法时间复杂度是$O(n^2)$，说明算法的时间复杂度$T(n)\le cn^2$($c$为比例系数)。即$T(n)=O(n^2)$，其算法执行时间与$n^2$成正比。需要注意的是时间复杂度$T(n)$是问题规模$n$的函数，其问题规模仍然是$n$而不是$n^2$。

==算法时间复杂度计算==：可以分为三种题型。

- 循环主体中的变量参与循环条件的判断

  此类题应该找出主体语句中与$T(n)$成正比的循环变量，将之代入条件中进行计算。例如：

  ~~~c
  //程序1：
  int i=1;
  while(i<=n)
      i=i*2;
  
  //程序2：
  int y=5;
  while((y+1)*(y+1)<n)
      y=y+1;
  ~~~

  对于程序$1$：当循环次数$t=1$时，$i=1*2$；当$t=2$时，$i=1*2*2$；当$t=3$时，$i=1*2*2*2\cdots$。所以有$2^t\le n$，取对数后得$t\le\log_2n$，则$T(n)=\log n$。

  对于程序$2$：当循环次数$t=1$时，$(5+1+1)^2\ge n$；当$t=2$时，$(5+1+1+1)^2\ge n$；当$t=3$时，$(5+1+1+1+1)^2\ge n\cdots$故$(5+1+t)^2\ge n$，所以$t<\sqrt{n}-6$，即$T(n)=O(\sqrt{n})$。

- 循环主体中的变量与循环条件无关

  此类题采用数学归纳法或直接累计循环次数，多层循环时从内到外分析，忽略单步语句、条件判断语句，只关注主体语句执行次数。

  ~~~c
  for(i=0;i<=n,i++)//循环条件1
  	for(j=0;j<=i;j++)  //循环条件2
  		for(k=1;k<=j;k++) //循环条件3
  			x++ 		//循环主体
  ~~~

  忽略循环主体本身，只关注其执行次数，多层循环，由内向外依次累加 ，经过分析可以写出：
  $$
  f(n)=\sum_{i=1}^{n}\sum_{j=1}^{i}\sum_{k=1}^{j}1\approx \frac{n*(n+1)*(2n+1)}{6}
  $$
  即$T(n)=O(n^3)$

- 递归类型

  递归程序一般使用公式进行地推。

  ~~~c
  int fact(int n){
  	if (n<=1)
  		return 1  // 递归出口
  	return n*fact(n-1) //循环主体 
  }
  ~~~

  $$
  T(n)=1+T(n-1)=1+1+t(n-2)=\cdots=n-1+T(1)
  $$

  即$T(n)=O(n)$

# 二. 线性表

常考内容：线性表概念、线性表的实现(顺序存储、链式存储)、线性表的应用(大题)。

线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。

线性表定义要求：数据具有相同的数据类型、写有限的序列。

## 顺序表

顺序存储是一种支持随机存取的存储结构。顺序表特点是逻辑顺序与物理顺序相同。

注意：线性表中元素的二位序是从$1$开始，而数组中元素的下标是从$0$开始。

若一个顺序表结构存储线性表最常用的操作是：存取第$i$个元素及其前驱和后继元素、存取指定序号的元素并在最后进行插入、删除操作。

顺序表的插入、删除、按值查找时间复杂度都是$O(n)$。

若长度为$n$的非空线性表采用顺序存储，在表$i$个位置插入一个元素，则$i$的合法范围应该是$1\le i\le n+1$。因为线性表序号是从$1$开始，而在第$n+1$个位置位置插入元素相当于在表尾追加元素。

顺序表的插入算法中，当$n$个空间已满时，可再申请增加分配$m$个空间，若申请失败，则说明系统没有**$n+m$个连续**的可分配存储空间。因为顺序存储需要连续的存储空间，在申请时需要申请$n+m$个连续的存储空间，然后将线性表原来的$n$个元素复制到新申请的$n+m$个连续的存储空间的前$n$个单元中。

## 链式表

链式存储结构比顺序存储结构能更方便表示各种逻辑结构。链表通常分为：单链表、双链表、循环单链表、循环双链表、静态链表。

另外为了方便运算的实现，通常会增加一个头结点。引入头结点后还有额外两个优点：

1. 由于第一个数据结点的位置背存放在头结点的指针域中，因此链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理。
2. 无论链表是否为空，其头指针都是指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到统一。

若给定$n$个元素的一维数组，建立一个有序单链表的最低时间复杂度是$O(n\log_2n)$

> 若先建立链表，然后依次插入建立有序表，则每插入一个元素就需要遍历链表寻找插入位置，即直接插入排序，所以时间复杂度为$O(n^2)$。若先将数组排好序，在建立链表，则建立链表时间复杂度是$O(n)$，数组排序最好时间复杂度是$n\log_2n$，所以总时间复杂度是$O(n\log_2n)$。

### 单链表

注意头插法、尾插法插入步骤。单链表按序号(按值)查找结点、求表长的时间复杂度为$O(n)$。

插入结点操作情况分为两种：前插和后插

- 后插情况

  结点$p$后面插入一个新结点$s$。插入代码如下：

  ~~~c
  s->next=p->next;
  p->next=s;
  ~~~

- 前插情况

  结点$p$前面插入一个新结点$s$。插入代码如下：

  ~~~c
  s->next=p->next;
  p->next=s;
  temp=s->data;
  s->data=p->data;
  p->data=temp;
  ~~~

  思路是仍然让新结点$s$插入到$p$结点后面，然后将两个结点的$data$域交换。

删除结点也分为两种情况：删除当前结点和删除后结点。

- 删除后结点

  删除结点$p$后面的结点$s$。插入代码如下：

  ~~~c
  q=p->next;
  p->next=q->next;
  free(q);
  ~~~

- 删除当前结点

  删除当前的结点$p$。插入代码如下：

  ~~~c
  q=p->next;
  p->next=q->next;
  p->data=q->data;
  free(q);
  ~~~

  删除当前结点$p$的操作可以用删除$p$的后继结点操作实现。实质就是将其后继结点的值赋予其自身，然后删除后继结点。

### 双链表

单链表如果要访问某个结点的前驱结点，只能从头开始遍历。所以访问后继结点时间复杂度是$O(1)$，访问前驱结点时间复杂度是$O(n)$。

为了克服这个困难引入了双链表。双链表中有两个`prior`和`next`指针分别指向结点的前驱和后继。双链表结点$p$所指的结点之后插入新结点$s$，插入操作如下：

~~~c
s->next=p->next;
p->next->prior=s;
s->prior=p;
p->next=s;
~~~

删除双链表中结点$p$的后继结点$q$。插入代码如下：

~~~c
p->next=q->next;
q->next->prior=p;
free(q);
~~~

适用情况：方便插入和删除数据情况。

双链表与单链表相比优点是更方便访问前后相邻的结点。

### 循环单链表

循环单链表和单链表区别是，表中最后一个结点的指针不是NULL，而改为指向头结点，从而形成一个环。所以循环单链表在任何一个位置的上插入和删除元素都是等价的。并且循环链表可以从任何一个结点处遍历整个链表。

有时对循环单链表设置尾指针而不设置头指针，以达到操作效率更高的目的。其原因是，若设头指针，对在表尾插入元素需要$O(n)$的时间复杂度，而若设的是尾指针$r$，则`r->next`就是头指针，对表头的或表尾插入元素都只需要$O(1)$的时间复杂度。

<img src="https://image.sybblogs.fun/img-common/202305221703001.png" alt="循环链表" style="zoom:50%;" />

某循环单链表头指针为`head`，当`head->next->next=head`时，线性表长度可能是$0$或$1$。

> 对含有一个元素的循环单链表，头结点的`next`域指向该唯一结点，该元素结点的`next`域指向头结点。而对于空链表，`head->next->next=head->next`成立。因为头结点`next`指针指向自己。

### 循环双链表

循环链表：表头结点的prior指向表尾结点；表尾结点的next指向头结点。

循环双链表不需要考虑表头表尾的界限操作。

<img src="https://image.sybblogs.fun/img-common/202305221713236.png" alt="循环双链表" style="zoom:50%;" />

在循环双链表L中，某结点`p`为尾结点时，`p->next==L`。表示链表为空时，其头结点`prior`和`next`域都等于`L`。

一个链表如果最常用操作是在末尾插入结点和删除结点，则选用带头结点的循环双链表最为合适。因为在链表末尾删除或插入一个结点时，需要修改其修改其相邻结点的指针域。而寻找尾结点和尾结点的前驱结点时，只有带头结点的双循环链表时间最少。

### 静态链表

与单链表不同的是静态链表是分配一整片连续的内存空间，各个结点集中安置。

<img src="https://image.sybblogs.fun/img-common/202305221746658.png" alt="静态链表" style="zoom: 25%;" />

静态链表特点是需要分配较大的空间，插入和删除元素不需要移动元素。



