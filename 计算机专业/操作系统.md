[toc]

# 一. 操作系统概述

计算机层次结构：裸机(指纯硬件，包含CPU、内存、硬盘和主板等)、操作系统、应用程序和用户。结构依次往上。

<img src="https://image.sybblogs.fun/img-common/202401301810925.png" alt="计算机系统层次结构" style="zoom:50%;" />

操作系统(Operating System，OS) 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。

从上面定义可以得到操作系统以下特点：

1. 操作系统是系统资源的管理者。这里的系统资源包含硬件和软件资源。
2. 向上层提供方便易用的服务。上层即用户和应用程序。
3. 是最接近硬件的一层软件。

## 1. 操作系统提供的服务

这一门课主要学习的是操作系统是系统资源的管理者，即操作系统会提供：处理机(CPU)管理、存储器管理、文件管理和设备管理。

向上层提供方便易用的服务主要是用户和应用程序不需要直接对硬件进行繁琐复杂的操作，而是通过操作系统简化这些操作。这其实体现了封装思想，即操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作，系统发出命令即可。操作系统提供的易用服务有：

- GUI：图形化用户接口(Graphical User Interface)

  用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。

  例子：在Windows操作系统中，删除-一个 文件只需要把文件“拖拽”到回收站即可。

- 命令接口

  1. 联机命令接口实例(cmd)。联机命令接口$=$交互式命令接口

     联机命令接口就是一个指令对应一个执行。

  2. 脱机命令接口(bat文件)。脱机命令接口$=$批处理命令接口

     批处理是提前预输入多个指令，让系统一次性全部执行。

- 程序接口

  可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。

  如：写C语言"Hello world"程序时，在`printf`函数的底层就使用到了操作系统提供的显式相关的系统调用。

  系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式。有的教材中系统调用又称为广义指令。

这里的命令接口和程序接口也可以统称为用户接口。

<img src="https://image.sybblogs.fun/img-common/202401301810925.png" alt="计算机系统层次结构" style="zoom:50%;" />

所以上图用户和应用程序与操作系统之间的有接口，用户通过命令接口可以直接和操作系统进行交互。应用程序可以通过程序接口与操作系统进行交互。

最后操作系统作为最接近硬件的层次需要实现对硬件机器的拓展。如果一个计算机中没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机。

操作系统对硬件机器的拓展是将CPU、 内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。

## 2. 操作系统特征

操作系统有并发、共享、虚拟和异步四个特征。其中共享和并发是两个最基本的特征，二者互为存在条件。

- 并发

  这里的并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。如指令流水线。

  而并行：指两个或多个事件在同一时刻同时发生。如双接口访存。

  操作系统的并发性指计算机系统中"同时"运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。

  操作系统出现就是为了支持"多道程序技术"。因此操作系统和并发是一起诞生的。

  ==注意(重要考点)==：单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行。多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。比如Intel的第八代i3处理器就是$4$核CPU，意味着可以并行地执行$4$个程序。即使是对于$4$核CPU来说，只要有$4$个以上的程序需要"同时"运行，那么并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性。

- 共享

  共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

  两种资源共享方式：互斥共享和同时共享。

  1. 互斥共享方式

     系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。

     如使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。

  2. 同时共享方式

     系统中的某些资源，允许一个时间段内由多个进积"同时"对它们进行访问。

     同时共享方式：使用QQ发送文件$A$，同时使用微信发送文件$B$。宏观上看，两边都在同时读取并发送文件说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。

  所谓的"同时"往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)。

并发和共享之间的关系：并发性指计算机系统中同时存在着多个运行着的程序。共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。

还是通过上面发送文件例子来解释并发与共享的关系。使用QQ发送文件$A$，同时使用微信发送文件$B$。

1. 两个进程正在并发执行(并发性)

   如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。

2. 需要共享地访问硬盘资源(共享性)

   如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。

所以并发性和共享性是互为存在的关系。

- 虚拟

  虚拟是指把一个物理上的实体变为若千个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。

  如：GTA5需要$4$GB的运行内存，QQ需要$256$MB的内存，迅雷需要$256$MB的内存，网易云音乐需要$256$MB的内存等。假如电脑只有$4$GB运行内存，这些程序同时运行的内存要远大于$4$GB，但仍然可以在电脑上运行，这就是虚拟存储技术，实际只有$4$GB的内存，在用户看来似乎远远大于$4$GB。这就是虚拟技术中的"空分复用技术"。

  另外如果用户打开多个软件，但实际上只有一个单核的CPU，但这多个程序仍然可以运行。这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有$6$个CPU在同时为自己服务。这就是虚拟技术中的"时分复用技术"。微观上处理机在各个微小的时间段内交替着为各个进程服务。

  所以虚拟技术分为时分复用技术和空分复用技术。

显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。

- 异步

  异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

  由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。

如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。

总结：并发和共享互为存在条件。没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。

## 3. 操作系统的发展与分类

主要讲述操作系统在各个阶段的主要解决的问题及各自的优缺点。

- 手工操作阶段

  程序员将代码写在纸带上，有孔的地方是$1$，没有孔的地方表示$0$。之后将写好后的纸带放到纸带机上，之后计算机从纸带机中读取要用到的程序，程序运行完毕后，将运行结果输出到纸带机上，最后程序员从纸带机上取走运行后的程序。

  <img src="C:\Users\Acid\OneDrive\图片\本机照片\408\操作系统\手工操作阶段.png" alt="手工操作阶段" style="zoom:33%;" />

  这种运行方式主要慢在程序员将纸带放入纸带机及从纸带机中取走云心结果这几步。

  <img src="https://image.sybblogs.fun/img-common/202401311432608.png" alt="手工操作阶段2" style="zoom: 33%;" />

  上面$J1,J2$是两个程序，可以看出手工操作阶段主要缺点是：用户独占全机、人机速度矛盾导致资源利用率极低。计算机工作事件只有上面红色的一小段。

- 单道批处理系统

  为了解决上面手工阶段缺点，发明了单道批处理系统，在这个阶段引入脱机输入$/$输出技术(用外围机$+$磁带完成)，并由监督程序负责控制作业的输入、输出。

  各个程序员可以把自己的程序放入纸带机，之后会由外围机将多个纸带程序数据先放到磁带机上，之后计算机可以直接从这个磁带中读取数据。磁带读写速度比纸带机快很多。

  <img src="https://image.sybblogs.fun/img-common/202401311437970.png" alt="单道批处理系统" style="zoom: 33%;" />

  此时的计算机中会运行监督程序，由这个程序控制自动从磁带中输入输出数据。

  <img src="https://image.sybblogs.fun/img-common/202401311438410.png" alt="单道批处理系统2" style="zoom: 33%;" />

  采用这种系统，计算机利用率提高很多

  <img src="https://image.sybblogs.fun/img-common/202401311440778.png" alt="单道批处理系统3" style="zoom:33%;" />

  主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

  主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之，后才能调入下一道程序。CPU有大量的时间是在空闲等待$I/O$完成。资源利用率依然很低。

- 多道批处理系统

  为了解决上述问题，多道批处理系统诞生，在这个阶段操作系统正式出现。操作系统支持多道程序并发运行。

  在多道批处理系统中，每次可以往内存中读入多道程序，然后让这些程序并发运行。

  这个阶段计算机利用率大大提高

  <img src="https://image.sybblogs.fun/img-common/202401311444112.png" alt="多道批处理系统" style="zoom:33%;" />

  主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持"忙碌"状态，系统吞吐量增大。

  主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。如：无法调试程序$/$无法在程序运行过程中输入一些参数)

- 分时操作系统

  分时操作系统：计算机以时间片为单位轮流为各个用户$/$作业服务，各个用户可通过终端与计算机进行交互。

  主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

  主要缺点：不能优先处理一些紧急任务。操作系统对各个用户$/$作业都是完全公平的，循环地为每个用户$/$作业服务一个时间片，不区分任务的紧急性。

- 实时操作系统

  为了能让用户处理一些紧急任务。有了实时操作系统。

  在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。而实时操作系统又可以细分为：

  1. 硬实时系统
     必须在绝对严格的规定时间内完成处理。如导弹控制系统和自动驾驶系统。
  2. 软实时系统
     能接受偶尔违反时间规定

  主要优点：能够优先响应--些紧急任务，某些紧急任务不需时间片排队。如火车订票系统。

- 其他操作系统
  1. 网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享( 如文件共享)和各台计算机之间的通信。( 如: Windows NT就是一种典型的网络操作系统，网站服务器就可以使用)。
  2. 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。
  3. 个人计算机操作系统：如Windows XP、MacOS，方便个人使用。

## 4. 操作系统的运行机制

由程序员编写的程序是应用程序。而操作系统内核是由一个一个内核程序组成的，所以操作系统内核简称内核。内核是操作系统最核心的部分，也是最接近硬件的部分。甚至可以说，一个操作系统只需要内核就足够了，如Docker技术就仅需要Linux内核。而操作系统的功能也未必都在内核中，如GUI。

操作系统内核作为"管理者"，有时会让CPU执行一些特权指令，如：内存清零指令。这些指令影响重大，只允许"管理者"，即操作系统内核来使用。

普通的应用程序只能使用"非特权指令"，如：加法指令、减法指令等。

在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。但CPU无法区分特权指令是应用程序的指令还是内核程序的指令。为了能让CPU区分CPU会分为两种状态：内核态(管态或核心态)和用户态(目态)。

- 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令
- 处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令

CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，$1$表示内核态，$0$表示用户态。

内核态与用户态的切换：

1. 刚开始时，CPU为内核态，操作系统内核程序先在CPU上运行。
2. 开机完成后，如果操作系统上运行应用程序，此时内核程序会执行一条特权指令，这个特权指令会把PSW标志位从内核态转换为用户态。这样就完成了CPU状态切换
3. 接着操作系统内核会让出CPU使用权，让应用程序在CPU上运行。
4. 假如当前应用程序中有一条特权指令，CPU可以识别出这个特权指令，但此时CPU处于用户态。所以会引发一个中断信号。
5. 处于用户态的CPU会接受中断信号，之后会立即变为核心态，并停止运行当前应用程序，转而运行处理中断信号的内核程序。
6. 这个中断使操作系统再次夺回CPU控制权。
7. 之后操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序。

所以内核态转换为用户态：执行一条特权指令，即修改PSW的标志位为"用户态"，这个动作意味着操作系统将主动让出CPU使用权

而用户态转换为内核态：由"中断"引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权

除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，但凡需要操作系统介入的地方，都会触发中断信号

## 5. 中断和异常

CPU上会运行两种程序，一种是操作系统内核程序，一种是应用程序。内核是整个系统管理者，在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序，这个应用程序运行过程中会发生中断，中断是让操作系统内核夺回CPU使用权的唯一途径。结合上一节内容这里不难理解中断重要性。

中断作用：让操作系统内核强行夺回CPU的控制权。使CPU从用户态变为内核态。

中断分为两种类型：内中断和外中断。

### 5.1 内中断

内中断产生和当前执行的指令有关，中断的信号来源于CPU内部。

如上面提到的例子，一个应用程序应用在用户态，假如这个应用程序有一个特权指令，CPU执行这条特权指令时发现此时正在处于用户态。于是这个非法的事件会触发一个中断信号，CPU会拒绝执行这条指令。接着CPU会自动切换到内核态开始处理中断信号相关的内核程序。

<img src="https://image.sybblogs.fun/img-common/202401311647354.png" alt="内中断例子" style="zoom:33%;" />

有时候即使用户执行的是非特权指令也会发生中断。如执行除法指令时发现除数为$0$。

另一个例子，一个应用程序运行在用户态，有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令，即陷入指令，该指令会引发一个内部中断信号。接着CPU会转向处理中断信号的内核程序。所以可以看出当一个应用程序执行陷入指令时，就意味着这个应用程序主动把CPU使用权还给操作系统内核，想让操作系统内核为其提供一些服务。之前提到的系统调用就是通过陷入指令完成的。

需要强调的是陷入指令是一个特殊指令，不是特权指令。

### 5.2 外中断

外中断产生和当前执行的指令无关，中断信号来源于CPU外部。

典型的例子是时钟中断，即由硬件时钟部件发送来的中断信号。这个部件会每隔一段时间给CPU发送一个时钟中断信号，通过时钟中断信号就可以实现多道程序并发运行了。

<img src="https://image.sybblogs.fun/img-common/202401311655643.png" alt="外中断例子" style="zoom:33%;" />

假设此时系统当中想要并发运行两个应用程序。而时钟部件每个$50$ms给CPU发送一个时钟中断信号。

- 首先应用程序$1$运行在用户态。当CPU执行两条应用程序$1$指令后，时钟部件发现已经过了$50$ms，此时会给CPU发送一个中断信号。这个中断信号来自于CPU外部。
- 之后CPU会切换到内核态，转而处理中断内核程序。当执行这个内核程序时候，CPU会知道应用程序$1$已经执行了$50$ms
- 接着内核程序会把CPU使用权给应用程序$2$。之后CPU切换为用户态执行应用程序$2$。

- 之后再过$50$ms时钟部件会再次给CPU发送中断信号。重复上述过程就完成两个程序并发运行。

除了由时钟部件发出的中断信号，有时候也会由$I/O$设备发出中断信号。根据之前学习的计算机组成原理可以直到CPU在每个执行周期末尾都会检查有没有外部中断信号。

### 5.3 中断分类

有的教材会称内中断为**异常**或例外。外中断叫**中断**。

异常可以分为三类：陷阱(陷入)、故障、终止

1. 陷阱

   由陷入指令引发，是应用程序故意引发的，即当一个应用程序想要操作系统提供服务时候，就会故意引发这个异常。其实这也是系统调用的原理。

2. 故障

   是一种由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。 如：整数除$0$、缺页故障。

3. 终止

   由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：非法使用特权指令。

### 5.4 中断机制的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询"中断向量表"，以此来找到相应的中断处理程序在内存中的存放位置。

<img src="https://image.sybblogs.fun/img-common/202401311712647.png" alt="中断向量表" style="zoom: 50%;" />

显然这里的中断处理程序就是一种内核程序，需要运行在内核态。

总结：

<img src="https://image.sybblogs.fun/img-common/202401311713889.png" alt="中断总结" style="zoom: 33%;" />

## 6. 系统调用

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。

所以"系统调用"是操作系统提供给应用程序(程序员$/$编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。

这个平时编程时使用的函数调用其实是很类似的。但还是有区别，系统调用是比高级语言提供的库函数更为底层的一个接口。

<img src="https://image.sybblogs.fun/img-common/202401311724026.png" alt="系统调用和库函数区别" style="zoom: 50%;" />

另外一些库函数不涉及系统调用，如取绝对值函数。设计系统调用有创建一个新文件函数等。

有一种情况，当打印时，如果两个进程可以随意地、并发地共享打印机资源这样会得到错误的打印内容。所以系统调用是必须的。即解决方法是由操作系统内核对共享资源进行统一的管理， 并向上提供"系统调用"，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。

系统调用分类：

<img src="https://image.sybblogs.fun/img-common/202401311730304.png" alt="系统调用分类" style="zoom: 33%;" />

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管， 因此**凡是与共享资源有关的操作(如存储分配、$I/O$操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求**，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

假设一个应用程序想要进行系统调用，这个调用过程如下：

- 首先这个应用程序的指令会被处于用户态的CPU一个一个执行。当这个应用程序需要用到系统调用时，需要用传参数指令，给CPU寄存器中传递必要的参数。如在某一个寄存器中存放参数$1$。这个参数$1$指明了系统调用类型，如fork。传递参数过程有多条，主要要看系统调用需要传递几个参数。操作系统会根据应用程序提供的参数来判断想要的服务是哪种。

  <img src="https://image.sybblogs.fun/img-common/202401311805865.png" alt="系统调用过程" style="zoom:33%;" />

- 当这些参数都放入寄存器之后，应用程序就会执行一条特殊的指令，即陷入指令。这个陷入指令的执行会引发一个内中断。CPU检测到这个内部中断信号后发现是由trap(陷阱)指令引起的，于是CPU就会暂停运行这个应用程序转而去处理陷入指令的应用程序。这个程序就是系统调用入口程序。

  <img src="https://image.sybblogs.fun/img-common/202401311812877.png" alt="系统调用过程2" style="zoom: 33%;" />

- 显然这个系统调用入口程序属于内核程序，因此CPU会切换为内核态。这个中断程序会检擦CPU寄存器中的参数，通过第一个参数会知道应用程序需要的是哪种类型的系统调用服务。接着入口程序就会调用与之对应的处理程序。让处理程序在CPU上运行。

  <img src="https://image.sybblogs.fun/img-common/202401311813830.png" alt="系统调用过程3" style="zoom:33%;" />

- 当系统调用处理完成后，CPU会再转回到用户态。接着执行之前的应用程序。

  <img src="https://image.sybblogs.fun/img-common/202401311814690.png" alt="系统调用过程4" style="zoom: 33%;" />

总的来说系统调用过程是：传递系统调用参数$\rightarrow$执行陷入指令$/$trap指令$/$访管指令(用户态)$$\rightarrow$$执行相应的内请求核程序处理系统调用(核心态)$$\rightarrow$$返回应用程序

<img src="https://image.sybblogs.fun/img-common/202401311816177.png" alt="系统调用过程5" style="zoom:33%;" />

注意: 

1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态
2. 法出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。

## 7. 操作系统体系结构

经过之前的学习计算机系统结构如下：

<img src="https://image.sybblogs.fun/img-common/202401301810925.png" alt="计算机系统层次结构" style="zoom:50%;" />

操作系统的内部可以进一步进行划分：一部分是内核功能(如时钟管理，中断处理)，另一部分是非内核功能(如GUI)。

<img src="https://image.sybblogs.fun/img-common/202401311824025.png" alt="操作系统内核" style="zoom:33%;" />

这里的时钟管理就是利用时钟中断实现的计时功能。原语是一种特殊的程序，具有原子性。也就是说，这段程序的运行必须一气呵成，不可被"中断"。Ubuntu、CentOS 的开发团队，其主要工作是实现非内核功能，而内核都是用了Linux内核。

### 7.1 大内核与微内核

总之内核是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。还有一种划分方式由于对进程管理、存储器管理、设备管理等功能属于对数据结构的操作，不会直接涉及硬件，所以这些不属于内核。按照这样思路划分如下：

<img src="https://image.sybblogs.fun/img-common/202401311836190.png" alt="计算机系统层次结构划分" style="zoom:33%;" />

上面这种划分方式会对系统性能造成一定的影响。

<img src="https://image.sybblogs.fun/img-common/202401311839703.png" alt="操作系统体系结构" style="zoom: 33%;" />

假设现在有个应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理。

- 采用大内核体系结构，应用程序向操作系统提出服务请求，这个时候CPU会从用户态切换为内核态开始运行这一些列的内核程序
- 而如果采用是微内核体系结构，应用程序向操作系统提出服务请求，如果使用到进程管理、存储管理、设备管理相关的功能这些管理也需要得到内核的支持，所以会切换为内核态，在得到内核支持后再次转为用户态。因此每一个模块都需要请求内核服务，每次请求都会涉及到CPU状态转换的过程。

因此采用大内核结构只需要两次变态即可。如果采用微内核体系结构整个过程就需要六次变态。而需要注意的是变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能。

操作系统体系结构总结：

<img src="https://image.sybblogs.fun/img-common/202401311847463.png" alt="操作系统体系结构总结" style="zoom:33%;" />

### 7.2 其他结构体系

操作系统体系结构还有分层结构、模块化结构和外核结构。

- 分层结构操作系统

  内核分为多层，每层可以单向调用更低一层提供的接口。

  <img src="https://image.sybblogs.fun/img-common/202401311854774.png" alt="分层结构操作系统" style="zoom: 50%;" />

  最底层是硬件，最高层是用户接口，每层可调用更低一层，如第二层只能调用第一层为其提供的接口。

  优点：

  1. 便于调试和验证，自底向上逐层调试验证。
  2. 易扩充和易维护，各层之间调用接口清晰固定。由于层与层之间的接口是固定的，所以两层之间再添加一层也很简单。

  缺点：

  1. 仅可调用相邻低层，难以合理定义各层的边界。如进程需要使用到内存管理，而内存管理相关的功能有时候又需要使用到进程管理。这种相互调用关系很难定义其层次。
  2. 效率低，不可跨层调用，系统调用执行时间长。如果用户需要用到底层提供功能只能一层一层向下传递调用，所以效率低。

- 模块化结构

  一种很经典的程序设计思想，将内核分为多个模块，各模块之间相互协作。其内核$=$主模块$+$可加载内核模块。

  主模块：只负责核心功能，如进程调度、内存管理。

  可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核，如驱动程序。

  <img src="https://image.sybblogs.fun/img-common/202401311951275.png" alt="模块化结构" style="zoom: 50%;" />

  优点：

  1. 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发。如进程管理需要对外暴露多个功能接口，只要规定好这三个功能接口的参数，函数名，返回值。多个模块之间就能并行开发。
  2. 支持动态加载新的内核模块(如：安装设备驱动程序、安装新的文件系统模块到内核)，增强OS适应性
  3. 任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高

  缺点：

  1. 模块间的接口定义未必合理、实用
  2. 模块间相互依赖，更难调试和验证

- 外核

  内核负责进程调度、进程通信等功能， 外核负责为用户进程分配未经抽象的硬件资源(如磁盘存储空间)，且由外核负责保证资源使用安全。

  <img src="https://image.sybblogs.fun/img-common/202401312012918.png" alt="外核结构" style="zoom:33%;" />

  再普通的操作系统中，用户进程申请使用一片内存空间，操作系统分配这块内存空间是经过抽象的，经过虚拟化的，对于用户进程来说这些空间似乎拥有一整片连续的空间，但事实上这只是虚拟的地址空间，操作系统会将虚拟的地址空间映射到实际的物理物理空间当中。这些物理页框在实际中通常是离散的，类似于计算机组成原理中的虚拟存储技术。这里未经抽象资源指的是操作系统分配的空间在实际存储空间中是连续存放的。也就是说如果用户进程知道某些数据要被频繁的访问到，此时就可以向外核申请分配一整片连续的磁盘块。之后访问这些磁盘中的数据时，磁盘磁头移动距离会变小，性能会提升。这是外存的分配。同理内存分配也一样。

  而且外核还要保证资源使用安全，如进程$A$在内存中分配了一整片连续存储空间用于存放数据。那么另一个进程$B$想要访问这一片区域，外核就需要发现并制止，同时进程$A$要访问除这一片连续存储空间之外的空间也应该被禁止。

  优点：

  1. 外核可直接给用户进程分配"不虚拟、不抽象"的硬件资源，使用户进程可以更灵活的使用硬件资源
  2. 减少了虚拟硬件资源的"映射层"，提升效率。

  缺点：

  1. 降低了系统一致性
  2. 使系统变得更复杂

  系统中有的进程会申请虚拟的地址空间，这种申请还需要映射。而有的会申请物理真实空间。这种情况后序管理需要考虑各种情况，所以降低了系统一致性，导致系统变得复杂。

- 大内核(宏内核)与微内核

  大内核：所有的系统功能都放在内核里(大内核结构的OS通常也采用了"模块化"的设计思想)

  微内核：只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态

  <img src="https://image.sybblogs.fun/img-common/202401311839703.png" alt="操作系统体系结构" style="zoom: 33%;" />

  大内核中各个功能也是可以相互调用的，就和函数一样。

  而微内核就只会将与硬件最紧密的功能放在内核中，大多数的功能会被放到微内核之外，在这种情况下功能与功能之间的调用就不太方便了，两个管理功能之间调用就需要通过消息传递方式来进行。如进程管理模块调用存储管理模块，需要先向微内核发送消息，消息中参数就指明要调用谁，调用的参数等信息。之后会由微内核的进程通信功能把该消息传递给被调用者存储管理模块。当存储管理模块接收到进程管理消息后才会处理调用的请求。同时存储管理模块要返回调用结果，也需要通过消息传递方式让微内核协助各个模块间的调用和返回。

  大内核优点：性能高，内核内部各种功能都可以直接相互调用

  大内核缺点：

  1. 内核庞大功能复杂，难以维护
  2. 大内核中某个功能模块出错，就可能导致整个系统崩溃

  微内核优点：

  1. 内核小功能少、易于维护，内核可靠性高
  2. 内核外的某个功能模块出错不会导致整个系统崩溃

  微内核缺点：

  1. 性能低，需要频繁的切换用户态$/$核心态。
  2. 用户态下的各功能模块不可以直接相互调用，只能通过内核的"消息传递"来间接通信。

