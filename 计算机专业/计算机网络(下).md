[toc]

# 四. 网络层

根据网络层一些相关协议，和网络层设备路由器及一些算法等，实现主机与主机之间的通信。

网络层知识总览：

<img src="https://image.sybblogs.fun/img-common/202402231250263.png" alt="网络层知识总览" style="zoom:25%;" />

网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层单位是数据报。

网络层功能：

1. 路由选择与转发

   通过路由选择算法确定一条最佳路由。然后将这个分组按照路由顺序发送出去。即选择最佳路径。

2. 异构网互联

   无论是手机还是联网的电脑，或者是学校的校园网，通过这些不同的网络可以实现彼此之间的通信，这就是一个异构网络。这些异构网络互连起来就形成一个更大的网络。互连依靠路由器使得这些网络可以相互连接在一起。

3. 拥塞控制

   若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞。

   解决方法有两种：开环控制(在网络开始工作之前就将所有因素考虑到，是静态控制)和闭环控制(网络运行起来时候自动调制拥塞控制，是动态控制)。

## 1. SDN基本概念

路由器功能：转发与路由选择。

转发：达到路由器输入链路之一的数据报如何转发到该路由器的输出链路之一，即在路由器内部寻找端口输出过程。时间较短，通常用硬件解决。

路由选择：控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。即路由选择与转发相比是一个更加宏观概念。指当有很多路由器时候如何选择一条最合适的路由。时间较长，常常采用软件解决。

<img src="https://image.sybblogs.fun/img-common/202402231327815.png" alt="路由器功能" style="zoom:25%;" />

这句上面概念可以引申出数据平面与控制平面概念：

- 数据平面

  数据平面对于数据处理过程中各种具体处理转发过程。即一个分组如何从一个端口转发出去到另外一个端口之中，这是数据平面最主要的功能。对应的是转发过程。

- 控制平面

  控制平面用于控制和管理网络协议的运行，比如OSPF协议、RIP协议、BGP协议。对应的是路由选择一些功能。

### 1.1 数据平面

数据平面执行的主要功能是根据转发表进行转发，这是路由器的本地动作。转发表基于路由表生成。

<img src="https://image.sybblogs.fun/img-common/202402231330172.png" alt="转发表" style="zoom:33%;" />

可以看到转发表由两部分构成，首部和输出。首部指的是分组当中首部的$1$个或多个字段。输出指的是这个分组应该走哪个输出端口。

### 1.2 控制平面

有两种实现方法：传统方法或者叫每路由器法，及SDN方法。

- 传统方法

  路由选择算法运行在每台路由器中，并且在每台路由器中都包含转发和路由选择两种功能。因此传统方法是路由转发$+$路由选择。

  具体方法：在一台路由器中的路由选择算法与其他路由器中的路由选择算法通信(通过交换路由选择报文)，计算出路由表和转发表。另外由**路由选择处理器**执行控制平面功能。在传统的路由器中，它执行路由选择协议,维护路由选择表于关联链路状态信息，并为该路由器计算转发表。

- ==SDN方法==

  转发过程与传统方法一样。但控制平面从路由器物理上分离。路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用。

  <img src="https://image.sybblogs.fun/img-common/202402231339940.png" alt="SDN方法" style="zoom: 33%;" />

  远程控制器可能在具有高可靠性的远程数据中心中，并可能由ISP或某些第三方管理。

  具体方法：路由器通过交换包含转发表和其他路由选择信息的报文与远程控制器通信。因为计算转发并与路由器交互的控制器是用软件实现的，所以网络是"软件定义的"。另外在SDN路由器中，路由选择处理器负责与远程控制器通信，目的是接收远程控制器计算的转发表项。

  远程控制器通过软件(可编程)计算出转发表，以及和路由器进行交互。

  SDN控制平面层次：

  <img src="https://image.sybblogs.fun/img-common/202402231350255.png" alt="SDN控制平面层次" style="zoom: 33%;" />

  可以看到主要有两个组件：

  1. SDN控制器：维护准确的网络状态信息(远程链路、交换机(路由器)和主机的状态)。为运行在控制平面中的网络控制应用程序提供这些信息(逻辑集中，在多台服务器上实现)
  2. 网络控制应用程序：根据SDN控制器提供的方法，这些应用程序通过这些方法能够监视、编程和控制下面的网络设备。

  另外上图的北向API和南向API指的是接口，北向是向上提供服务，南向是向下提供服务。

  可以将上图再展开，即在SDN控制器中又细分为三个层次：

  <img src="https://image.sybblogs.fun/img-common/202402231407388.png" alt="SDN控制器" style="zoom:33%;" />

  1. 对于网络控制应用程序的接口：SDN控制器通过"北向接口"与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间读写网络状态。
  2. 网络范围状态管理层：有SDN控制平面作出的最终控制决定，将要求控制器具有有关网络的主机、链路等最新状态信息。
  3. 通信层：SDN控制器与受控网络设备之间的通信(OpenFlow协议)，包含"南向接口"。这个南向接口就可以实现SDN控制器和网络设备之间的信息交互。这里又一个很重要的协议OpenFlow协议，就是来帮助SDN远程控制器和路由器之间进行通信的协议。

例1：假定你要在SDN控制平面中实现一个新型路由选择协议)你将在哪个层次中实现该协议?

> 网络范围状态管理层。因为在这一层能获得有关网络的主机，链路，交换机和其他SDN控制设备的最新状态信息，可以根据这些信息的基础上实现新型路由选择协议，并通知给控制器落地执行。

例2：谁是从控制器跨越南向接口发送的这些报文的接收者?谁是跨越北向接口从控制器发送的这些报文的接收者?

> 受控网络设备(路由器)
>
> 网络控制应用程序

网络层两大平面总结：

<img src="https://image.sybblogs.fun/img-common/202402231419004.png" alt="网络层两大平面总结" style="zoom: 25%;" />

## 2. 路由算法及相关协议

路由器本身会有一个路由表$/$转发表。

<img src="https://image.sybblogs.fun/img-common/202402231422057.png" alt="路由转发表" style="zoom:33%;" />

只要通过这个表就可以知道这个分组经过这个路由器之后接下来往哪走。其中每一行表项通过路由算法得到。

加入这个路由器连接着很多路由器，那它的下一跳有很多种方向，可以通过路由算法决定下一跳方向。即路由算法会选择一个最佳路由，然后将这个最佳路由添加到表项中。这里的"最佳"是相对于某一种特定要求下得出的较为合理的选择情况。

路由算法分为静态路由算法和动态路由算法。

- 静态路由算法

  非自适应路由算法。由管理员手工配置路由信息(手动配置路由下一跳应该发送到哪个路由上)。

  优点：简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。

  缺点：路由更新慢，不适用大型网络。如果有一些主机撤出拓扑网络，拓扑结构会发生变化，而这个变化需要由人工更新。

- 动态路由算法

  自适应路由算法。路由器间彼此交换信息，按照路由算法优化出路由表项。

  优点：路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。

  缺点：算法复杂，增加网络负担。

  这种算法是实际生活中经常用到的。

对于上面动态路由算法还可以划分为全局性和分散性。

- 全局性

  代表性算法是链路状态路由算法。这种算法典型应用是OSPF。

  之所以叫全局性是因为所有路由器掌握完整的网络拓扑和链路费用信息。

- 分散性

  代表新的是距离向量路由算法。典型应用是RIP。

  分散性是指路由器只掌握物理相连的邻居及链路费用。

分层次路由协议：主要采用这种分层次的路由协议主要原因有两个：

1. 因特网规模大。
2. 许多单位并不想让外界知道自己的路由选择协议，但还想连入因特网。

结合上面两个原因就产生了分层次的路由选择协议。具体来说就是将因特网划分为多个小的团体。这个小的团体可以称之为自治系统AS。自治系统内使用的协议外部是完全不知道的，这样就可以尽量减少每个路由器表项个数，同时还可以使一个自治系统内的这些路由器使用的协议对于外界来说是透明的。

自治系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。

所以就把路由协议分为：内部网关协议IGP和外部网关协议EGP。这里的网关就是路由器。

- IGP

  是一个AS内使用的，常用的协议有RIP、OSPF协议。

- EGO

  是AS之间使用的，常用的协议有BGP协议。

总结：

<img src="https://image.sybblogs.fun/img-common/202402231505990.png" alt="分层次路由选择协议" style="zoom: 25%;" />

如上图两个自治系统可以想象成一个单位。每个单位内使用的路由选择协议就叫做内部网关协议。对于外部路由器$R_1,R_2$，之间进行分组转发或者是路由选择应该使用外部网关协议，常用的外部网关协议有BGP-4。

### 2.1 RIP协议与距离向量算法

内部网关协议IGP中常用两个协议是RIP和OSPF。两个区别是使用的路由选择算法不一样。RIP使用的是距离向量，OSPF使用的是链路状态。并且RIP适用于比较小的网络，OSPF适用于比较大的网络。

RIP协议是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单。RIP协议要求网络中每一个路由器都**维护从它自己到其他每一个目的网络的唯一最佳距离记录**(即一组距离)。即路由表中的每个表项要记录这个路由器到其他网络的距离，且是最佳距离(经过路由器跳数最短)。

上面距离定义：通常为"跳数"，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数$+1$。特别的，从一路由器到直接连接的网络距离为$1$。RIP允许一条路由最多只能包含$15$个路由器，因此距离为$16$表示网络不可达。所以RIP协议只适合小互联网。

<img src="https://image.sybblogs.fun/img-common/202402251549080.png" alt="R2路由表1" style="zoom: 25%;" />

上图有四个网络$Net1,Net2,Net3,Net4$，即三个路由器$R1,R2,R3$。现在以R2为研究对象看这些距离及R2的路由表。

<img src="https://image.sybblogs.fun/img-common/202402251548577.png" alt="R2路由表" style="zoom:33%;" />

上图是R2路由表表项，这个路由表建立，是通过上图每个路由器之间交换信息才能逐渐完善填满这个路由表。

而RIP协议的每一个路由器仅和**相邻路由器**交换信息。而且路由器交换的信息是**自己的路由表**，也就是当前路由器所知道的全部信息。这些信息每$30$秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过$180s$没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表，将路由表中要通过邻居的那些表项更新掉。这里强调一点是路由器刚开始工作时，只知道直接连接的网络的距离(距离为$1$)，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。

之后由于每$30$秒相邻路由器会交换一次信息，并更新路由表，经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即"收敛"。

这里最短距离或者路由表怎么更新等问题是通过**距离向量算法**解决：

其实每个路由器在交换信息的时候交换的是RIP报文。那么寻找最短距离实现步骤如下：

- 修改相邻路由器发来的RIP报文中所有表项

  对地址为$X$的相邻路由器发来的RIP报文，修改此报文中的所有项目：把"下一跳"字段中的地址改为$X$，并把所有的"距离"字段$+1$。

  <img src="https://image.sybblogs.fun/img-common/202402251614831.png" alt="距离向量算法" style="zoom:33%;" />

  $X$作为R1相邻路由器，在过了$30$s后要把自己整个路由表的信息放到一个RIP报文中，发送给R1。假如要发送的报文是`Net3,2,R2`，即$X$路由器要到Net3网，最短距离是$2$，下一条路由器走的是R2。这个报文到达R1后，R1后就会接收全部路由表信息，之后将R2发送的报文中的下一跳地址改为$X$。然后距离$+1$变为$3$，因为R1和$X$之间的距离是$1$，如果要通过$X$到达Net3距离就是$3$。所以R1路由中路由表多了一条`Net3,3,X`的报文。

- 对修改后的RIP报文中的每一个项目，进行以下步骤：

  1. R1路由表中若没有Net3，则把该项目填入R1路由表。

  2. R1路由表中若有Net3，则查看下一跳路由器地址：

     若下一跳是$X$，则用收到的项目替换源路由表中的项目。替换原因是这是最新的消息，路由表要保持最新消息。

     若下一跳不是$X$，原来距离比从$X$走的距离远则更新，否则不作处理(保留到Net3最短的表项，**但如果下一跳都是$X$则新的消息替换旧的**)。

- 若$180$s还没收到相邻路由器$X$的更新路由表，则把$X$记为不可达的路由器，即把距离设置为$16$。

- 之后每隔$30$s重复上述步骤。

例1：已知路由器R6的路由表，现收到相邻路由器R4发来的路由更新信息，试更新路由器R6的路由表。

R6路由表：

<img src="https://image.sybblogs.fun/img-common/202402251640911.png" alt="距离向量算法例1" style="zoom: 33%;" />

R4发来的路由更新信息：

<img src="https://image.sybblogs.fun/img-common/202402251640700.png" alt="2距离向量算法例1" style="zoom:33%;" />

> 将R4发来的路由更新信息：

<img src="https://image.sybblogs.fun/img-common/202402251641739.png" alt="3距离向量算法例1" style="zoom:33%;" />

> 对于Net1由于原本R6中没有到该网络记录，所以直接添加。Net2下一条是R4，而原本R6中已经有了Net2并且下一跳也是R4，所以直接将最新的替换，即R6到Net2距离变为5。最后的Net3下一跳R4距离是2，明显比原本R6中到Net3下一条是R5距离是4的更近，所以替换。最后R6表更新如下：

<img src="https://image.sybblogs.fun/img-common/202402251644652.png" alt="4距离向量算法例1" style="zoom:33%;" />

例2：考虑如图所示的子网,该子网使用了距离向量算法，下面的向量刚刚到达路由器C：来自B的向量为(5,0,8,12,6,2)；来自D的向量为(16,12,6,0,9,10)；来自E的向量为(7,6,3,9,0,4)。经过测量，C到B、D和E的延迟分别为6,3和5，那么C到达所有结点的最短路径是多少

<img src="https://image.sybblogs.fun/img-common/202402251653586.png" alt="1距离向量算法例2" style="zoom: 33%;" />

> 上图B向量表示的是B到A距离是$5$，B到B距离是$0$，B到C的距离是$8\cdots$以此类推$D,E$含义一致。主要是看向量$0$对应的位置，刚好是按照$A,B,C,D,E,F$的顺序。
>
> 由于C到B、D和E的延迟为$6,3,5$所以三个对应向量分别$+6,+3,+5$：
>
> C到B：(11,6,14,18,12,8)
>
> C到D：(19,15,9,3,12,13)
>
> C到E：(12,11,8,14,5,9)
>
> 所以C到$B/D/E$到A距离从$11,19,12$中挑选最小的$11$。C到$B/D/E$到B的距离从$6,15,11$中挑选最小的$6$。之后依次类推可以得到C到所有结点向量是(11,6,0,3,5,8)

介绍RIP报文格式：

<img src="https://image.sybblogs.fun/img-common/202402251702370.png" alt="RIP协议报文格式" style="zoom: 25%;" />

RIP报文特点是首部$+$路由部分封装到UDP用户数据报中。也就是RIP报文$+$UDP首部形成一个UDP用户数据报。由于UDP是应用层协议，所以RIP是应用层协议，使用UDP传送数据。且路由信息($20$字节$/$路由)可重复出现最多$25$个，即一个RIP报文最多可包括$25$个路由，如超过，必须再用一个RIP报文传送。

RIP报文特点：当网络出现故障时，要经过比较长的时间(例如数分钟)才能将此信息传送到所有的路由器，"慢收敛"。

<img src="https://image.sybblogs.fun/img-common/202402251706921.png" alt="RIP协议特点" style="zoom:25%;" />

如上图第一个`1`表示从本路由器到网1，第二个`1`表示这个距离是1，第三个`-`表示直接交付。同理R2的RIP报文格式也是一致。

<img src="https://image.sybblogs.fun/img-common/202402251710953.png" alt="RIP协议特点2" style="zoom:25%;" />

但如果网1发生故障，R1路由表会更新为`1,16,-`。但是很有可能这样一个更新好的报文要经过$30$s之后才能发送个R2。如果R2在这$30$s内已经把自己的报文`1,2,R1`发送给R1。此时R1收到R2路由表后会更新为`1,3,R2`。之后R1将这个消息发送给R2，R2又会更新消息`1,4,R1`。之后将这个消息再发送给R1，R1修改为`1,5,R2`，接着再发送给R2。循环往复直到R1和R2到网1距离都变为$16$时，R1和R2才知道不能到达网$1$。总的来说RIP报文特点是好消息传得快，坏消息传得慢。

RIP协议与距离向量算法总结：

<img src="https://image.sybblogs.fun/img-common/202402251718266.png" alt="RIP协议与距离向量算法总结" style="zoom:25%;" />

### 2.2 OSPF协议及链路状态算法

开放最短路径优先OSPF协议："开放"标明OSPF协议不是受某一家厂商控制，而是公开发表的。"最短路径优先"是因为使用了Djkstra提出的最短路径算法SPF。

OSPF最主要的特征就是使用分布式的链路状态协议。这个链路状态协议(算法)会在之后介绍。

OSPF特点：

1. 使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。

   其实就是之前介绍的广播形式。通过广播形式最终整个区域内所有路由器都得到了这个信息的一个副本。

2. 发送的信息就是与本路由器相邻的所有路由器的链路状态(本路由器和哪些路由器相邻，以及该链路的度量$/$代价(费用、距离、时延、带宽等))。RIP协议中只有最短距离(下一跳距离)。

3. 只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。

经过上面过程到最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。也就说每一个路由器都知道到自己网络内的所有路由器一个经历多少度量。

链路状态路由算法：

- 每个路由器发现它的邻居结点(这个过程是通过HELLO问候分组实现的)，并了解邻居节点的网络地址。

  这个过程是任何两个相邻的路由器之间都会发生的过程，任何两个相邻路由器每隔$10$s都会发送一个问候分组。这样就能确认周围那些邻站是可达的。

- 设置到它的每个邻居的成本度量`metric`。

- 构造一个DD数据库描述分组(其实就是全网的拓扑结构图)，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。
- 如果DD分组中的摘要自己都有，则邻站不做处理。如果有没有的或者是更新的，则发送LSR链路状态请求分组请求自己没有的分组和比自己新的信息。
- 收到邻站的LSR分组后，发送LSU链路状态更新分组进行更新。
- 更新完毕后，邻站返回一个LSAck链路状态确认分组进行确认。

综上就介绍OSPF协议中的五个重要类型的分组：HELLO问候分组、DD数据块描述分组、LSR链路状态请求分组、LSU链路状态更新确认分组、LSAck链路状态确认分组。

如果一个路由器的链路状态发生变化：

- 泛洪发送LSU链路状态更新分组进行更新。
- 更新完毕后，其他站返回一个LSAck链路状态确认分组进行确认。

经过上面过程到最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。之后使用Djkstra算法根据自己的链路状态数据库构造到其他节点间的最短路径。

为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域。每一个区域都有一个$32$位的区域标识符(用点分十进制表示)。区域也不能太大，在一个区域内的路由器最好不超过200个。

<img src="https://image.sybblogs.fun/img-common/202402251747657.png" alt="OSPF的区域" style="zoom:25%;" />

可以看到自治系统AS划分区域后成一个主干区域(0.0.0.0)和其他区域。主干区域作用就是来连接其他区域。同时主干区域中的路由器称为主干路由器包括$R3,R4,R7$，同时这两个路由器也可以叫做边界路由器。上面R6由于要连接到其他自治系统中，所以称为自治系统边界路由器。其他普通区域内部的路由器叫做区域内部路由器。

采用这种分层次划分区域方法，虽然使得交换信息种类增多，同时也使OSPF协议更加复杂，但可以使得每个区域内部交换路由信息通信量大大减小，因而OSPF协议就能够适用于规模较大的自治系统。

OSPF分组：

<img src="https://image.sybblogs.fun/img-common/202402251754898.png" alt="OSPF分组" style="zoom: 25%;" />

构造是OSPF分组首部$+$后面的分组(数据部分)，然后形成IP数据报数据部分，封装上IP数据报首部形成一个IP数据报进行发送。所以OSPF直接用IP数据报传送数据。

OSPF其他特点：

1. 每隔$30$min，要刷新一次数据库中的链路状态。

2. 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。

3. OSPF不存在坏消息传的慢的问题，它的收敛速度很快。

   OSPF会将收来的更新都放到自己的链路状态数据库中，然后根据整个链路状态数据库通过使用Djkstra算法来计算出一个最短路径。所以它的收敛速度快。

### 2.3 BGP协议

外部网关协议EGP，常用的协议有BGP协议。

**BGP当中是与其他AS的邻站BGP发言人交换信息**。

<img src="https://image.sybblogs.fun/img-common/202402251844735.png" alt="BGP协议" style="zoom:25%;" />

结合上图，有$5$个自治系统AS。其中有BGP发言人路由器，在配置BGP时每个系统的管理员都要选择至少一个路由器来作为自治系统的BGP发言人。一般来说BGP发言人都是通过一个网络连接在一起的。而这个BGP发言人往往就是边界路由器。

**BGP协议交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS**。并且发生变化时才会更新有变化的部分。

BGP协议交换信息的过程：

BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。这里选择较好路由是因为因特网范围很大，使得自治系统之间路由选择比较困难，所以要找到一条最佳路由相对来说很困难。因此只需要选择一个尽可能好的路由即可。

<img src="https://image.sybblogs.fun/img-common/202402251851855.png" alt="BGP协议交换信息过程" style="zoom:25%;" />

上图就是BGP发言人所构造出的自治系统连通图，是一个树形结构，只有是树形结构才能保证不会兜圈子。

所以这里的交换信息指的是交换路径的向量，也就是交换一组路径的信息。比如说到子网$1$应该走哪几个AS才能到达。BGP发言人交换路径向量例子：自治系统AS2的BGP发言人通知主干网AS的BGP发言人："要到达网络N1、N2、N3和N4可经过AS2"。

<img src="https://image.sybblogs.fun/img-common/202402251857269.png" alt="BGP协议交换向量过程" style="zoom:25%;" />

当然作为主干网也可以交换信息，因为只要是相邻的邻站都是可以交换自己的完整路由表的。所以主干网还可发出通知："要到达网络N5、N6 和N7可沿路径(AS1, AS3)"。

BGP协议报文格式：

<img src="https://image.sybblogs.fun/img-common/202402251900290.png" alt="BGP报文格式" style="zoom:25%;" />

如上图，会将BGP报文放入一个TCP报文中作为TCP报文的数据段。然后再放入IP当中进行发送。因此可以看出这个BGP是应用层协议，借助TCP传送。

即一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要先建立TCP 连接，即通过TCP传送， 然后在此连接上交换BGP报文以建立BGP会话(session)，利用BGP会话交换路由信息。这里使用TCP不用UDP原因是，TCP能提供更加可靠的服务，同样也可以简化路由选择协议。

BGP协议特点：

1. BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。
2. 在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。

BGP-4是现在最常用的BGP版本，这个版本有四种报文：

- OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方。

  上面讲过BGP报文交换需要建立在TCP连接的基础上，所以OPEN报文就是在实现一个连接的建立。同时还有一个功能就是可以认出发送方，即证实发送方的身份进行身份验证。

- UPDATE(更新)报文：通告新路径或撤销原路径。

  是最长使用的一种报文。只要有路径更新、撤销原来的路径都需要使用这个报文。

- KEEPALIVE(保活)报文：在无UPDATE时，周期性证实邻站的连通性。也作为OPEN的确认。

- NOTIFICATION(通知)报文：报告先前报文的差错。也被用于关闭TCP连接。

总结三种协议：

RIP是一种分布式的基于距离向量的内部网关路由选择协议，通过广播UDP报文来交换路由信息。

OSPF是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议(如UDP或TCP)，而是直接采用IP。

BGP是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用TCP。

<img src="https://image.sybblogs.fun/img-common/202402251912058.png" alt="三种路由协议比较" style="zoom: 33%;" />

## 3. IP数据报

TCP$/$IP协议栈：

<img src="https://image.sybblogs.fun/img-common/202402231515506.png" alt="TCPIP协议栈" style="zoom:25%;" />

协议栈自顶向下分别是应用层、传输层、网络层、链路层和物理层。有关于网络层的协议主要有ARP、IP、ICMP、IGMP四个协议。如果ARP协议在最下面自然就要为IP协议服务。IP协议也要为ICMP、IGMP两个协议进行服务。

### 3.1 IP数据报格式

一个IP可以分为首部$+$数据部分。这个数据部分也就是运输层传送单元，有TCP段和UDP段。首部可以称之为IP数据报的头部。

<img src="https://image.sybblogs.fun/img-common/202402231520273.png" alt="IP数据报" style="zoom:33%;" />

在网络层IP数据报和分组不做区分。首部具体字段如下：

<img src="https://image.sybblogs.fun/img-common/202402231543247.png" alt="IP数据报的格式" style="zoom: 25%;" />

数据部分这里不做讲解，这一部分会在传输层讲到。

可以看到首部分为固定部分和可变部分。固定部分长度是固定的，有$20$B。下面对每一个字段进行详细介绍：

- 版本字段

  有$4$位。这里的版本指的是IPv4$/$IPv6

- 首部长度

  有$4$位。可以表示$16$个数。如果首部长度是$1111$，可以说首部长度是$15$比特$/$字节。注意首部长度的单位是$4B$，所以如果首部长度$1111$，则为$15\times4=60$B。即整个首部占用$60$B。固定部分长度固定为$20$B，那么可选部分就是$40$B

  注意由于固定部分长度固定为$20$，所以首部长度范围是$0101\sim1111$。当这个IP分组的首部长度不是$4$B倍数时，就没法用首部长度表示，所以在可选部分会有一个填充字段。填充的意义就是将整个首部填充成$4$B的整数倍。这样首部长度才可以对应地表示出来。因此可以说首部长度一定是$4$B的整数倍。也即数据部分总会以$4$B整数倍开始。

  较为常用的首部长度就是$20$B，即没有可选部分。即首部$=0101$。

- 区分服务

  指期望获得哪种类型的服务。如规定优先级。这个字段使用情况很少。

- 总长度

  首部长度$+$数据部长度。单位是$1$B。大小是$16$bit。所以最大值是$2^{16}=65535$B。在实际中，永远不会达到这个上限值，因为如果长度过大就要进行分片，以满足数据链路层的MTU(最大数据传输单元)的要求。

- 标识、标志、片偏移

  之后在IP数据报分片中会详细讲到

- 生存时间(TTL)

  表示的是IP分组的保质期，每经过一个路由器，这个生存时间都会$-1$，直到变成$0$则直接丢弃。之所以要设置生存时间是为了防止无法交付的数据报无限制在网络中兜圈。字段长度是$8$bit。

- 协议

  要和版本字段区分开。占$8$位，指的是数据部分所使用的协议。即运输层传下来的报文段使用的是什么协议。具体有以下几种协议：

  <img src="https://image.sybblogs.fun/img-common/202402231609398.png" alt="IP数据报协议" style="zoom:33%;" />

  上面较为重要两个协议是TCP和UDP，这两个协议要牢记字段值。

- 首部检验和

  所占的位数是$16$位。用于检验首部，具体方法和使用二进制求和，所以称为首部检验和。之所以有这个值是因为在数据传输过程中数据报每经过一个路由器，路由器都要重新计算下首部检验和。因为一些字段，如生存时间、标志、片偏移这些字段有可能发生变化。所以要通过检验和检验一下发生变化后，数据报有没有出错。如果出错就将这个数据报丢弃，如果没出错就可以继续传输。

- 源地址和目的地址

  长度都是$32$位。即使用的是IPv4协议。

- 可选字段

  范围是$0\sim40$B，用来支持排错、测量以及安全等措施。使数据报能够实现功能变得更加丰富。

- 填充字段

  全$0$，把首部补成$4$B的整数倍。单位是$4$B。

### 3.2 IP数据报分片

先来看最大传输单元(MTU)概念：在链路层上每一个数据帧都有一个可封装的上限，这个上限就叫做最大传输单元MTU。

以太网的MTU是$1500$B。

<img src="https://image.sybblogs.fun/img-common/202402231638098.png" alt="MTU" style="zoom: 25%;" />

如上图，数据帧的中间部分即IP分组，这个IP分组MTU不能超过$1500$B。如果所传送的数据报(IP分组)长度超过某链路的MTU值，则要将其分片。

<img src="https://image.sybblogs.fun/img-common/202402231543247.png" alt="IP数据报的格式" style="zoom: 25%;" />

分片要结合上面的标识、标志、片偏移来分析。

- 标识

  同一数据报的分片使用同一标识。即一个长度过长IP分组分成片，其分片的标识一致。

- 标志

  标志字段有$3$位，但只有$2$位有意义。最高位是保留位。中间位和最低位表示如下：

  1. 中间位DF，当`DF=1`，禁止分片。当`DF=0`，允许分片。
  2. 最低位MF，当`MF=1`说明后面还有分片。当`MF=0`，代表当前分片就是最后一个分片，或者说数据报长度不长没有分片。

  可以看到只有当`DF=0`时，`MF`才有意义。

- 片偏移

  指出较长分组分片后，谋片在原分组中的相对位置。以$8$B为单位。即当前这个分片对应原来分组中的位置。

  假如一个分片的片偏移是$0000000000001$，即这个分片在原来数据报中位置是$1\times8$B$=8$B。即原来数据报中第$8$个字节开始。

  同时也可以得知，除了最后一个分片，每个分片长度一定是$8$B的整数倍。

例子：假设数据报长度不超过$1420$字节。那么有一个数据报的首部$20$B，数据部分有$3800$B。可以看到数据部分过长需要进行分片，**分割要保证尽可能使分割完的数据越大越好**，由于每个分片需要有一个$20$B的首部，所以数据部分可以分为两个$1400$B，和一个$1000$B。

<img src="https://image.sybblogs.fun/img-common/202402231716495.png" alt="IP分片" style="zoom:25%;" />

现在具体分析一下每个数据片的片偏移量是多少。

第一个数据片片偏移量是$0$，因为数据第一个数据片，数据部分是从第一个字节开始的。所以第一个数据片的片偏移量是$0$。

第二个分片的数据部分是$1400$B，由于第一个分片结束位置是$1399$，所以第二个分片要从$1400$B位置开始，结束位置是$2799$B。所以片偏移量是$\frac{1400}{8}=175$。

第三个分片从$2800\sim3799$B。所以片偏移量是$\frac{2800}{8}=350$。

最后将三个分片的片偏移值放入分片的首部即可。

<img src="https://image.sybblogs.fun/img-common/202402231725111.png" alt="IP数据报分片例题" style="zoom:25%;" />

IP数据报单位总结：总长度单位是$1$B、片偏移单位是$8$B、首部长度单位是$4$B。

### 3.3 IPv4地址

以太网中，一台主机要给另一台主机通信，就要直到接收方主机地址是多少。具体来说就是需要直到这个主机在哪个网络、在这个网络下对应的哪台主机。这个寻找主机过程也就是确认IP地址过程。

IP地址其实就是在因特网中给每一台主机接口以及路由器的接口赋予一个全球唯一的标识符。因此这个IP地址就可以很方便寻址，再进行接下来的通信、资源共享等。

IP编址的历史阶段：分类的IP地址(其实就是将一个很大的IP空间进行划分)$\rightarrow$子网划分(由于对于IP需求增大产生的)$\rightarrow$构成超网(是一种新型的无分类编制方法)。

IP地址：全世界唯一的$32$位$/4$字节标识符，标识路由器主机的接口。并不是一个IP地址就标识一个主机，一个主机有很多接口(无线接口和有线接口)。自然路由器也会连接多个主机，这样路由器每个接口也都会分配一个唯一的IP地址。

IP地址标识：网络号$+$主机号。网络号就是确定这个主机在哪个区域，主机号就是确认在这个区域内的哪台主机，或者说是哪个接口。

<img src="https://image.sybblogs.fun/img-common/202402231821289.png" alt="IP地址例子" style="zoom:33%;" />

显示中网络例子如下：

<img src="https://image.sybblogs.fun/img-common/202402231822502.png" alt="互联网中的IP" style="zoom:25%;" />

上图有$6$个网络，并且是两种类型的网络。外围三个部分是一个网络，因为它们都是路由器的一个接口所连接的主机。并且网桥不能分割广播域，所以用网桥链路层连接起来的网段仍然是一个局域网，而且只能有一个网络号。

如上图所示，外围最左边的是LAN1，其网络号是$222.1.3.0$。外围最上边的是LAN2，网络号是$222.1.1.0$。外围最右边的是LAN3，网络号是$222.1.2.0$。

上图中间的是三台路由器，每个路由器都有三个端口。所以说路由器总有两个或两个以上的端口。可以看到每个路由器接口处都对应一个唯一的网络号的IP地址。

所以说路由器可以划分广播域，其实就是路由器不同接口可以连接不同网络的。上图中绿色的区域也是一种特殊的网络，称为无编号网络。称为网络原因是这里有IP地址。

将一个很大的地址空间分为几类，这样就可以合理划分IP地址资源。

<img src="https://image.sybblogs.fun/img-common/202402231859707.png" alt="分类IP地址" style="zoom:25%;" />

如上图可以看到总共是将网络分为五类。分发主要是靠前面的第一位(A类)，第二位(B类)，第三位(C类)，第四位(D,E类)。

第一种A类地址网络号是$1$B，即八位，且第一位是$0$。B类网络号是$2$B，即16位，且前两位是$1,0$。C类网络号是$3$B，且前三位是$1,1,0$。

最后的D、E两类前四位是$1110$和$1111$，D类地址是多播地址，在一对多通信的时候才会使用。E类地址保留为今后使用。具体解释如下：

- A类IP：0.0.0.0$\sim$127.255.255.255

  0$\sim$127，其中0代表任何地址，127代表回环测试地址，因此，A类地址的实际范围是$1\sim126$，默认子网掩码是255.0.0.0


- B类IP：128.0.0.0$\sim$191.255.255.255

  128$\sim$191，其中128.0.0.0和191.255.0.0为保留IP，实际范围是128.1.0.0$\sim$191.254.0.0，子网掩码：255.255.0.0

- C类IP：192.0.0.0$\sim$223.255.255.255

  192$\sim$223,其中192.0.0.0和223.255.255.0为保留IP，实际范围是192.0.1.0$\sim$223.255.254.0；子网掩码：255.255.255.0

- D类IP：224.0.0.0$\sim$239.255.255.255

  224.0.0.0$\sim$239.255.255.255用于多点广播

- E类IP：240.0.0.0$\sim$255.255.255.254

  255.255.255.255用于广播地址。

上面子网掩码会在之后讲到，子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。

之所以要将网络分类，是因为不同类型的网络连接的主机数差别很大，分类后可以更好满足用户需求。

要注意的是分类后所得到的所有IP地址并不是都可以使用的。如下一些特殊IP地址不能使用：

<img src="https://image.sybblogs.fun/img-common/202402231908934.png" alt="特殊IP地址" style="zoom:25%;" />

如上图所示一系列地址是不能用来作为主机或者路由器具体接口IP的。

另外还有一类地址是私有IP地址，这些地址特点就是如果将其中地址放到互联网上，路由器是无法识别这些IP的，只适用于内部网络。

<img src="https://image.sybblogs.fun/img-common/202402231915767.png" alt="私有IP地址" style="zoom: 25%;" />

对于这些内部地址如何去跟外部通信，就是之后要讲的NAT技术。上图网段个数相当于能分配的网络号个数。

再来看看三类网络使用范围：

<img src="https://image.sybblogs.fun/img-common/202402231936630.png" alt="分类IP使用范围" style="zoom: 33%;" />

- A类网络号使用位数是$7$位，减$2$，是因为如果网络号全$0$，对应IP地址是本网络的意思；第二个如果网络号变为$127$，此时就是特殊地址中的环回地址。所以可以使用网络个数要$-2$。

  另外可以看到主机号位数是$24$位，但是还要减去一个全$0$主机号(本网网络号)，再减去一个全$1$的(广播地址)。

- B类网络号可使用位数是$14$位。减去一个全$0$。即$128.0.0.0$是不指派的。

  最后网络最大主机数还是要减去全$0$(本网络)和全$1$(广播分组)。

- C类网络号可使用是$24$位。减去一个全$0$，即$192.0.0.0$是不指派的。

  最后网络最大主机数还是要减去全$0$(本网络)和全$1$(广播分组)。

### 3.4 网络地址转换NAT

上面介绍的私有IP地址，只能在本地专用网中使用。如果将其中地址放到互联网上，路由器是无法识别这些IP的。

<img src="https://image.sybblogs.fun/img-common/202402231915767.png" alt="私有IP地址" style="zoom: 25%;" />

即路由器对目的地址是私有IP地址的数据报一律不进行转发。但仍然可以和互联网上的主机进行通信，需要用到网络地址转换NAT。

网络地址转换NAT ( Network Address Translation)：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。

<img src="https://image.sybblogs.fun/img-common/202402241305610.png" alt="网络地址转换NAT" style="zoom:25%;" />

其实只需要在专用网和因特网之间的路由器上安装NAT软件，有了这个软件路由器就称为NAT路由器。它有多个有效的外部全球IP地址。所有使用本地地址的主机在和外界通信的时候，都需要经过NAT路由转换就可以实现和外部主机通信。

<img src="https://image.sybblogs.fun/img-common/202402241328161.png" alt="网络地址转换NAT2" style="zoom:25%;" />

如上图，假如专用网中的一台主机$A$要和外部主机$B$进行通信，$A$会给$B$发送一个数据报，在网络层数据报要封装源IP地址和目的IP地址。之后到了传输需要加上端口号(传输层会讲到)。之后这个数据报到了NAT路由器，就需要实现一个网络地址转换功能，其实就是将源IP地址和端口号替换为下图NAT转换表中对应的值。如果$A$主机源地址和端口号是$192.168.0.3:30000$，则根据转换表需要替换为$172.38.1.5:40001$。至此这样一个数据报地址就可以被路由器及主机所识别进行转发。

本质是需要通过NAT路由器才能将消息发送给因特网上的主机$B$。这个NAT相当于这个专用网络中的代表。同理接收数据原理一致。

网络地址转换实现关键是NAT路由器有一个转换表。这个转换表由WAN端(广域网)和LAN端(局域网)构成：

<img src="https://image.sybblogs.fun/img-common/202402241334589.png" alt="NAT转换表" style="zoom: 33%;" />

可以看到每个十进制IP地址后面还有一个端口号，这个端口号可以唯一标识主机当中的某一个具体进程，在传输层会具体讲到。

### 3.5 子网划分与子网掩码

之前讲过可以将一个很大的地址空间分为几类，这样就可以合理划分IP地址资源。

<img src="https://image.sybblogs.fun/img-common/202402231859707.png" alt="分类IP地址" style="zoom:25%;" />

但是这种分类有缺点：

1. IP地址空间的利用率有时很低。

   假如一个公司申请一个$B$类网络，但是分配的主机并不会很多，这样会浪费IP地址，同时还会使IP地址的空间资源过早使用完。

2. 两级IP地址不够灵活。

   比如一个公司需要在一个新的地点，马上开通一个新的网络，但是需要向网络服务提供商(ISP)提出申请一个IP地址。所以不够灵活。

解决上述两个问题就需要用到子网划分。之前学过的IP地址结构是网络号$+$主机号，而子网划分就是将主机号当中的一部分较高的位数拿出来作为子网号。剩下部分再作为一个主机号。这就是划分子网的一个思想。

<img src="https://image.sybblogs.fun/img-common/202402241414589.png" alt="子网划分" style="zoom: 25%;" />

上面网络号$+$主机号的就是两级IP地址，下面的网络号$+$子网号$+$主机号的是三级IP地址。某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网如何划分。要注意子网号最少一位没有，最多情况下要留两位给主机号。

<img src="https://image.sybblogs.fun/img-common/202402241438098.png" alt="通过子网进行网络划分" style="zoom:25%;" />

如上图，是一个B类IP地址，这个路由器连接的网络地址是$145.13.0.0$，也就是说所有能够到达这个网络分组都会经过这个路由器再转发给这个单位的各个主机中。可以看到上图将这个网络划分为$3$个子网，但是这三个子网对外展示的还是一个网络地址，即$145.13.0.0$。假如有一个数据报的目的地址是这个网络中$145.13.3.10$主机，但是作为从外部过来的分组只知道应该传给路由器$145.13.0.0$，之后路由器会通过子网掩码发送给内部IP地址是$145.13.3.10$的主机。

子网掩码由一系列连续的$0/1$构成的二进制数，$1$的个数取决于网络号位数，剩下的主机号对应$0$。上面$145.13.3.10$的二级子网掩码如下：

<img src="https://image.sybblogs.fun/img-common/202402241450382.png" alt="子网掩码" style="zoom:33%;" />

如果一个外部IP分组进入到本单位某一个子网某个主机内，此时就需要路由器实现识别的功能，需要从收到的IP分组中提取出目的IP地址，进而根据这个目的地址判断是应该发给本单位的哪个子网，然后再发送给那个子网，因此就会对这个分组再划分一个三级IP地址形式：

<img src="https://image.sybblogs.fun/img-common/202402241454035.png" alt="三级子网掩码" style="zoom:25%;" />

可以看到只有主机号是$0$，网络号和子网掩码都是$1$。之后子网掩码与IP地址逐位相与，就得到子网网络地址。$145.13.3.10$与对应的子网掩码$255.255.255.0$做与运算结果是$145.13.3.0$。

例1：已知IP地址是$141.14.72.24$，子网掩码是$255.255.192.0$， 求网络地址。

> 将$141.14.72.24$与$255.255.192.0$进行与运算，其实只用求$72$与$192$与运算即可。结果为：$141.14.64.0$。

快速计算方法需要记住以下常用的二进制转换表：

<img src="https://image.sybblogs.fun/img-common/202402241509169.png" alt="常用网络地址二进制" style="zoom:25%;" />

如果子网掩码是$255.255.254.0$，网络地址还是$141.14.64.0$。这个例子就说明同样的IP地址和不同子网掩码可以与运算得出相同的网络地址。但是这两个掩码所达到的效果不一样。第一个子网掩码的子网号是$192$对应的二进制是$11000000$，只占了两位，剩下的$14$位是主机号。第二个子网掩码子网号$254$对应的二进制是$11100000$，即子网号占了$3$位，剩下的$13$位是主机位。因此这两个子网掩码中可以划分主机个数以及每一个子网中可以使用的最大主机数是不同的。

例2：某主机的IP地址为$180.80.77.55$，子网掩码为$255.255.252.0$。若该主机向其所在子网发送广播分组，则目的地址可以是多少

> 由于是广播分组，所以主机位全是$1$，且子网掩码前两位是$255$，故目的主机是$180.80.?.255$，即只用求出中间的子网号即可，$252$对应的二进制是$11111100$，所以子网号有$6$位，子网掩码与IP地址$77$的二进制$01001101$的前六位与运算，结果是$76(01001100)$。由于子网掩码只有六位，剩下十位全是主机号，且是广播分组故全$1$，即$79(01001111)$，故目的地址为$180,80,79.255$。

使用子网时分组如何转发：

<img src="https://image.sybblogs.fun/img-common/202402241438098.png" alt="通过子网进行网络划分" style="zoom:25%;" />

对于每个路由器都有一个转发表(路由表)，路由表中有目的网络地址、目的网络子网掩码、下一跳地址。转发过程如下：

1. 路由器首先会提取出这个分组中的目的IP地址，假如IP地址是$145.13.3.10$。路由器首先根据IP地址看看是否能直接交付(目的地址是否在路由器的子网中)，具体判断方法是用目的地址和三个子网的子网掩码分别进行与操作，如果结果和其中一个子网号对应上就说明应该要转发到这个子网中。注意不同子网可以使用不同的子网掩码，但是这例子中三个子网掩码相同都是$255.255.255.0$。

2. 如果目的地址在这三个子网中，就会查看这个路由表中是否有这个目的地址的特定路由。如果没有特定主机路由，就会检测路由表中有无合适目的地址路径。具体是用目的地址和路由表项的每一个子网掩码进行与运算。如果仍没有，则进入下一步默认路由，IP是$0.0.0.0$，分组会发给这个默认路由，即另外一个路由器，默认路由会重复上述过程。

路由的分组转发总结：

- 提取目的IP地址
- 是否直接交付
- 特定主机路由
- 检测路由表中有无路径
- 默认路由0.0.0.0

如果一个分组在生存时间$TTL$之内还没有找到目的主机就会将这个分组丢弃。报告分组转发出错。

### 3.6 无分类地址CIDR

是现在常用地址划分方式。CIDR就是在三级地址子网划分思想下将整个网络号和子网号合并在一起，称之为网络前缀。再次回到二级IP地址形式。

<img src="https://image.sybblogs.fun/img-common/202402241608821.png" alt="CIDR" style="zoom: 25%;" />

看似回到二级地址形式，但是和之前的网路号$+$主机号形式是不一样。网络前缀位数是可变长的，可以很灵活调整网络号的长度。这种方式被广泛使用。

CIDR特点：

1. 消除了传统的A类，B类和C类地址以及划分子网的概念。
2. 融合子网地址与子网掩码，方便子网划分。

CIDR表示法：IP地址后加上`/`，然后写上网络前缀(可以任意长度)的位数。如：$128.14.32.0/20$

CIDR把网络前缀都相同的连续的IP地址组成一个"CIDR地址块"。假如$128.14.35.7/20$是某CIDR地址块中的一个地址，其对应的二进制是$10000000\quad00001110\quad00100011\quad00000111$。即前面$20$位都是一样的。剩下的$12$位是主机号。同时也可以得到网络中最小主机号(主机位全$0$)和最大的主机号(主机位全$1$)：

<img src="https://image.sybblogs.fun/img-common/202402241626970.png" alt="CIDR最大地址和最小地址" style="zoom:33%;" />

上面最小地址表示的是本网络，另一个表示的是广播地址，如果分配主机的话是不会把这两个主机号分配给主机的。所以这个网络的CIDR地址块是$128.14.32.0/20$。

同时CIDR中仍然有子网掩码概念，同样$1$表示网络号，$0$表示主机号。上面例子中子网掩码是：$11111111\quad11111111\quad11110000\quad00000000$，也就是网络前缀有多少位，子网掩码$1$就有多少位。

CIDR有两个重要应用：构成超网和最长前缀匹配。

#### 构成超网

将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。方法是将网络前缀缩短(所有网络地址取交集)。

<img src="https://image.sybblogs.fun/img-common/202402241635537.png" alt="构成超网" style="zoom: 33%;" />

如上图有两个路由器连接在一起，R2路由器有两个端口连接着网络1和网络2。所以R1这个路由器就要维护一个路由表，路由表的主要信息包括目的网络和最佳接口(数据传到网络要走哪个接口)。可以看到网络1和网络2到R1都要走接口$a$。

<img src="https://image.sybblogs.fun/img-common/202402241638250.png" alt="构成超网2" style="zoom:33%;" />

这样的两个信息就在网络中占了两行，如果连接的网络很多，则路由表很难维护。因此CIDR会提供路由聚合方式，具体方法就是将网路前缀缩短，以达到聚合目的。

<img src="https://image.sybblogs.fun/img-common/202402241640488.png" alt="构成超网3" style="zoom:33%;" />

这个网络$1+2$合体就是通过地址取交集求得。如果网络1地址是$206.1.0.0/17$，网络2地址是$206.1.128.0/17$。这两个网络前缀都是$17$位。前面两个字节都相同是$206.1$，从第三个字节开始不一样，故将第三个字节都转换为二进制，划分到两个不同的位，之后因为是主机位所以全部为$0$。因此合体后的主机号就是$206.1.0.0/16$。

==注意==：划分子网是从少到多的过程。而构成超网是由多边少的过程，将多个聚合成一个新的地址。

例子：某路由表中有转发接口相同的$4$条路由表项，其目的网络地址分别为$35.230.32.0/21$、$35.230.40.0/21$、$35.230.48.0/21$、$35.230.56.0/21$，将该$4$条路由聚合后的目的网络地址是多少？

> 可以看到前两字节都是一样，且网络地址主机号全部为$0$。故第三字节全部转换为二进制：

<img src="https://image.sybblogs.fun/img-common/202402241655204.png" alt="构成超网4" style="zoom:33%;" />

> 可以看到前三位一样，后面不一样，所以网络前缀就是$16+3=19$。且剩下主机号都是$0$所以是$32(00100000)$。故网络地址是$35.230.32.0/19$

#### 最长前缀匹配

使用CIDR时，查找路由表可能得到几个匹配结果(跟网络掩码按位相与)，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。

例子：路由器$R0$的路由表见下表，若进入路由器$R0$的分组的目的地址为$132.19.237.5$，请问该分组应该被转发到哪一个下一跳路由器。

<img src="https://image.sybblogs.fun/img-common/202402241713131.png" alt="最长前缀匹配" style="zoom:33%;" />

思路：将目的地址和目的网络的子网掩码进行与运算，如果结果是目的网络地址就选择，如果匹配到多个目的网络地址就选择前缀最长

$132.0.0.0/8$的子网掩码是$11111111\quad0\cdots0$。$132.0.0.0/11$的子网掩码是$11111111\quad11100000\quad0\cdots0$。

$132.19.232.0/22$的子网掩码是$11111111\quad11111111\quad11111100\quad00000000$。

将目的地址$132.19.237.5$与上面三个子网掩码进行与运算前两个都可以正确匹配，而$132.19.232.0/22$子网掩码与运算，其实就是第三个字节为，即$237$和$232$进行与运算，结果为$236(11101100)$。所以地址是$132.19.236.0/22$与匹配的网络地址不一致，所以排除。另外两个能匹配到的里面选择网络前缀最长的$132.0.0.0/11$，所以下一跳是$R2$。

而最后的$0.0.0.0/0$是三个网络表项都匹配不上才会选择的地址。

## 4. 协议

发送数据时候需要经过对数据封装和解封装的过程，但是具体封装什么内容是根据不同层次协议规定的。

<img src="https://image.sybblogs.fun/img-common/202402241727819.png" alt="发送数据过程" style="zoom:33%;" />

可以看到上面两个路由器划分了两个网络。假如上面主机$1$给主机$3$发数据：

1. 首先在传输层会将文件分段(如果文件较大)，形成报文段，也就是传输层传输单元。

2. 之后在网络层，回将每个分段加上源主机IP地址和目的主机的IP地址。目的主机获取是通过DNS，是传输层要介绍的。可以看到网络层就实现了一个封装，将报文段形成一个IP数据报(分组)。分组通常指的是数据报分片后的结果，要根据链路层的MTU判断是否要分片，假如这里不分片。
3. 接着到了链路层，也要进行封装，即要加上源主机MAC地址和目的主机的MAC地址。可以看到目的主机当前是不知道在哪个位置的，所以获取目的主机的MAC地址就需要通过**ARP协议**。

### 4.1 ARP协议

首先对于每一个主机及每一个路由器都会有一个$ARP$高速缓存，存放的是IP地址与MAC地址的映射。当然这个高速缓存存放的所有表项都是一个局域网内部的主机地址与MAC地址的映射。假如当前查询这个ARP高速缓存发现$3$号主机对应的MAC地址，就可以很容易将$3$号目的主机的MAC地址封装到链路层分组中。

<img src="https://image.sybblogs.fun/img-common/202402241739564.png" alt="发送数据过程2" style="zoom: 25%;" />

但是如果ARP高速缓存中如果没有$3$号主机的映射，就要使用到ARP协议。协议具体过程是：

- 首先广播ARP分组请求，即$1$号主机要发送一个分组，这个分组主要部分是：源地址IP地址$+$目的主机IP地址$+$源主机MAC地址$+$全$1$。这里全$1$代表在局域网内有广播效应的分组，也就是$1$号主机发出这个帧，从集线器到交换机，交换机识别到广播帧末尾全$1$会将该分组从交换机所有端口转发出去，即$2,3$号主机，即右边路由器都可以收到这个分组。

- 之后$3$号分组收到这个请求分组就会返回一个响应分组，即单播ARP响应分组，这个分组会直接到$1$号主机不会转发给其他主机。这个单播响应分组分为两个部分：本主机IP地址$+$本主机的MAC帧。

  <img src="https://image.sybblogs.fun/img-common/202402241747223.png" alt="发送数据过程3" style="zoom:33%;" />

$1$号主机收到响应后会将MAC添加到分组中。在头部加上一个帧检验序列FCS。之后就构成一个链路层传输单元。之后就可以放到物理层上进行传输。

<img src="https://image.sybblogs.fun/img-common/202402241749096.png" alt="发送数据过程4" style="zoom:33%;" />

上面例子是目的主机在一个局域网内，如果$1$号主机要和$5$号主机进行通信

<img src="https://image.sybblogs.fun/img-common/202402241751167.png" alt="发送数据过程5" style="zoom: 25%;" />

这里还是要使用ARP协议，不过这里的ARP就有差别，首先还是要先看一下源主机的ARP高速缓存中有没有主机$5$的IP地址和MAC地址。而ARP只存放一个局域网内部的IP地址和MAC地址，所以这里不可能找到$5$号主机的。此时$1$号主机会先用自己的子网掩码和目的主机的IP地址进行与运算，看看是不是在自己的网段内。

如果不是在一个网段内，会将默认网关的MAC地址放入分组内进行封装，这个默认网关其实就是对外路由器网络接口，即上图的MAC6。得到这个MAC6还是通过广播ARP请求分组，其主要部分还是：源地址IP地址$+$目的主机IP地址$+$源主机MAC地址$+$全$1$。之后只有路由器会响应这个请求，返回一个单播ARP响应分组，这个分组还是两个部分：目的地址IP$+$目的主机MAC地址。这里假设默认网关是IP6：

<img src="https://image.sybblogs.fun/img-common/202402241852756.png" alt="发送数据过程6" style="zoom: 33%;" />

$1$号主机收到响应后会将MAC添加到分组中。在头部加上一个帧检验序列FCS。之后就构成一个链路层传输单元。之后就可以放到物理层上进行传输。

<img src="https://image.sybblogs.fun/img-common/202402241853735.png" alt="发送数据过程7" style="zoom:33%;" />

之后分组发送到路由器之后，路由器需要对分组进行解封装，解封装后再进行封装。这里的分组源地址的IP和MAC都变为路由器地址。之后发送给下一个路由器，由于这里是点对点传输，所以这里的目的主机的AMC应该为全$1$。如果不是点对点就应该填入正常目的主机的MAC地址。

<img src="https://image.sybblogs.fun/img-common/202402241900466.png" alt="发送数据过程8" style="zoom: 25%;" />

到了下一个路由器之后进行解封装，再使用ARP协议进行封装，这里的源主机IP和MAC地址就是当前路由器地址，发送的广播ARP请求分组会返回一个响应分组，是目的主机的IP和MAC地址。将地址封装进分组后就可以发送到目的主机。

<img src="https://image.sybblogs.fun/img-common/202402241907046.png" alt="发送数据过程9" style="zoom:25%;" />

所以总结一下ARP协议：

由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。要确定这个MAC地址需要用到ARP协议，完成主机或路由器IP地址到MAC地址的映射。即解决下一跳走哪的问题。

ARP协议使用过程：检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为$FFFF-FF-FF-FF$的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射**写入ARP缓存**($10\sim20$min更新一次)。

ARP协议4种典型情况：

1. 主机A发给本网络上的主机B：用ARP找到主机B的MAC地址。
2. 主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器(网关)的MAC地址。
3. 路由器发给本网络的主机A：用ARP找到主机A的MAC地址。 
4. 路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的MAC地址。

ARP协议是自动进行的。

例子：主机发送IP数据报给主机B，经过了$5$个路由器，请问此过程总共使用了几次ARP协议? 

<img src="https://image.sybblogs.fun/img-common/202402241934743.png" alt="ARP协议" style="zoom:33%;" />

故使用了$6$次ARP协议。

### 4.2 DHCP协议

主机在通信的时候一定要有一个IP地址，主机获得IP地址的方法有两种：静态配置和动态配置。

静态配置需要配置IP地址、子网掩码、默认网关。这里的默认网关就是之前的路由器接口的IP地址。只有通过这个IP地址局域网内部的主机才能跟外界通信。

动态配置如下：

<img src="https://image.sybblogs.fun/img-common/202402241940181.png" alt="DHCP动态配置" style="zoom:33%;" />

可以看到有两台DHCP服务器，还有一台交换机。

上面的动态主机配置协议DHCP是**应用层**协议，使用**客户$/$服务器**方式，客户端和服务端通过广播方式进行交互，基于**UDP**。

之所将应用层协议放在网络层介绍，是因为DHCP为网络层通信提供了一个基础，有了DHCP协议后才可以有IP地址。DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。即设备进入了DHCP服务器所管辖的一个局域网内，就可以动态分配一个地址给设备。

这里允许地址重用，DHCP服务器都有一个IP地址池，当一个用户离开DHCP所管辖的局域网时，DHCP会将这个这个IP回收留给下一个用户，所以达到地址重用目的。

DHCP协议工作流程：

1. 主机广播DHCP发现报文
2. DHCP服务器广播DHCP提供报文
3. 主机广播DHCP请求报文
4. DHCP服务器广播DHCP确认报文

可以看到这个过程是主机与服务器进行来回交互，这种方式称为**客户$/$服务器**方式。并且这里都采用广播方式。具体过程如下：

- 假如有一个主机现在连入局域网，主机会首先会广播给网络内所有的设备，这个广播内容是发现报文，可以试图找到网络中的DHCP服务器，服务器获得一个IP地址。
- 之后DHCP服务器获得这个地址之后，如果现在DHCP池中有地址可以分配，局域网内所有DHCP服务器都会广播应答报文，报文中服务器会拟分配给主机一个IP地址及相关配置，先到先得。即哪台DHCP服务器先发给主机IP，主机就先用这个IP。
- 接着主机向服务器请求提供IP这个地址，用广播方式是因为让其他DHCP服务器知道这个主机已经获取IP地址，其他DHCP服务器就不用再向主机发送拟地址了
- 最后DHCP服务器正式将IP地址分配给主机。

### 4.3 ICMP协议

回顾一下TCP$/$IP协议栈：

<img src="https://image.sybblogs.fun/img-common/202402241959606.png" alt="TCPIP协议栈回顾" style="zoom:25%;" />

可以看到ICMP协议和IGMP协议是位于网络层和传输层之间的协议。所以这两个协议起到一个桥梁作用。为了更有效地转发IP数据报和提高交付成功的机会。

ICMP协议支持主机或路由器可以实现差错(或异常)报告网络探询。因为在实际传输中总会有有一些分组会出错，出错的分组在网络层会直接丢弃，并发送一个差错报文给源主机。也就是说ICMP功能就是要发送特定的ICMP报文。报文结构如下：

<img src="https://image.sybblogs.fun/img-common/202402242002248.png" alt="ICMP报文结构" style="zoom:33%;" />

ICMP报文装在IP数据报的数据部分。ICMP报文具体字段如下：

<img src="https://image.sybblogs.fun/img-common/202402242003345.png" alt="ICMP报文具体字段" style="zoom: 25%;" />

- 类型是指报文具体是哪一类的。
- 代码是进一步区分某种类型中不同情况。
- 检验和用来检验整个ICMP报文
- 之后四个字节取决于ICMP报文类型
- 之后是ICMP数据部分，长度取决于类型

ICMP有两种类型：ICMP差错报文、ICMP询问报文。

#### 差错报文

差错报文有五种：

1. 终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。

   出现无法交付问题时使用。

2. 源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。

   出现因为拥塞而丢数据时使用，现在基本上不用，

3. 时间超过：当路由器收到生存时间`TTL=0`的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。

   主要在`TTL=0`，或者数据报片因为传输超时出现残缺情况。

4. 参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。

   首部字段出问题时使用。

5. 改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。

   一个网络上会有很多路由器，发送数据时没有找到最合适的路由器，这样原来的路由器就会将数据丢弃，并返回一个重定向报文高速主机这条路径不能将数据传输给目的主机。

ICMP差错报告报文中具体的数据字段：

<img src="https://image.sybblogs.fun/img-common/202402242016376.png" alt="ICMP差错报告报文数据字段" style="zoom: 25%;" />

将受到的需要进行差错报告的IP数据报的首部，以及前$8$个字节取出，作为ICMP报文的数据字段，再加上ICMP报文的前$8$个字节。就构成一个完整的差错报告报文，接着再加上IP数据报的首部就构成一个完整的数据报。再次强调ICMP差错报告报文是IP数据报也就是网络层传输单元的数据部分。

不应发送ICMP差错报文的情况：

1. 对ICMP差错报告报文不再发送ICMP差错报告报文。

   即不会对ICMP的差错，再进行差错报告。

2. 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。

3. 对具有**组播地址**的数据报都不发送ICMP差错报告报文。

   组播是一点到多点，而广播是一点到所有结点。组播具有选择性。

4. 对具有特殊地址(如$127.0.0.0$或$0.0.0.0$)的数据报不发送ICMP差错报告报文。

#### 询问报文

主要分为四种：

1. 回送请求和回答报文

   主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。

   主要应用是Ping测试目的站是否可达以及了解其相关状态。

2. 时间戳请求和回答报文

   请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。

3. 掩码地址请求和回答报文、路由器询问和通告报文

   当前已经不再使用。

ICMP具体应用有两方面：

- Ping的应用

  测试两个主机之间的连通性，使用了ICMP回送请求和回答报文。

- Traceroute

  跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。

  工作原理是假如现在有两台主机进行通信，中间有多台路由器，首先源主机会发送一连串的数据报，这些数据报生存时间TTL不一样。对于第一个数据报设置为`TTL=1`。所以到达第一个路由器时`TTL-1=0`会丢弃。丢弃后再返回给主机一个ICMP时间超时的差错报文。同理第二个数据报`TTL=2`，这样就可以测算出从主机原点到目的主机之间的路径距离。

## 5. IPv6

由于IPv4地址池消耗快，所以就学习了CIDR和NAT延缓IPv4地址的消耗，但仍然治标不治本，所以就提出IPv6这种新的地址池。

IPv6从地址位数和地址长度上扩充地址池，从根本上解决IPv4地址池不够的问题。除了IPv6解决办法同时还可以改进IPv4首部格式，改进首部$20$B的格式使得字段种类变得少一点，这样就可以加快路由器处理效率，也就是说通过改进首部格式实现快速处理$/$转发数据报的功能，同时要支持QoS。

QoS(Quality of Service，服务质量)指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。如果支持QoS就可以满足实时的以及多媒体通信的需要，所以基于这些动机就产生了IPv6。

### 5.1 IPv6数据报格式

IPv6数据报格式：

<img src="https://image.sybblogs.fun/img-common/202402251327744.png" alt="IPv6数据报格式" style="zoom:25%;" />

可以看到数据报格式包括两个部分：基本首部$+$有效载荷。其中有效载荷又包括选项和数据部分。对比IPv4就相当于将IPv4中的首部的可变部分移动到了IPv6的有效载荷中。基本首部固定$40$字节，扩展首部是对数据报有一些新的要求，如数据报要增加某些功能就放到这个扩展首部当中。所以原本IPv4的首部中，不必要的部分就可以放到扩展首部当中。可以看到IPv6灵活数据报格式就可以大大加快分组的处理速度。

数据报中的具体字段如下：

<img src="https://image.sybblogs.fun/img-common/202402251434376.png" alt="IPv6数据报具体部分" style="zoom:25%;" />

上图中有效载荷的扩展首部是可有可无的根据数据报是否需要提供其他服务，如果要就填充到扩展首部。其他字段解释：

- 版本

  指明了协议的版本，IPv6协议这个字段总是$6$

- 优先级

  区分数据报的类别和优先级。是否对数据报进行优先处理就要看这个字段。

- 流标签

  "流"是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签。

  A主机要给B主机发送一系列数据报，这一系列数据报都是一组的数据报，所以就可以称为是一个流的。这一个流中所有的数据报的流标签都是相同的值。

- 有效载荷长度

  指的是有效载荷有多少位。即扩展首部$+$数据部分的长度。

- 下一个首部

  标识下一个扩展首部或上层协议首部。

  假如当前有一个数据报，这个数据报除了基本首部，还有三个扩展首部(扩展首部$1$，扩展首部$2$，扩展首部$3$)，每一个扩展首部内都有下一个首部字段，基本首部中也有下一个首部字段。对于基本首部的下一个首部字段来说指向的是扩展首部$1$。扩展首部$1$中的下一个首部指向的是扩展首部$2$。而最后的扩展首部$3$的下一个首部字段指向的是数据部分。

- 跳数限制

  相当于IPv4中的TTL(生存时间)。达到$0$路由器就会将这个数据报丢弃，返回ICMP差错报文。

- 源地址和目的地址

  位数都是$128$位。而IPv4中源地址和目的地址只有$32$位。

IPv4和IPv6区别：

1. IPv6将地址从$32$位($4$B)扩大到$128$位($16$B)，更大的地址空间。

2. IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间。

3. IPv6将IPv4的可选字段移出首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。

4. IPv6支持即插即用(即自动配置)，不需要DHCP协议。

5. IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍。

6. IPv6只能在主机处分片，IPv4可以在路由器和主机处分片。

   就是说即使IPv6的分组很长，在路由器也是无法分片的，只能在主机处分片。

7. ICMPv6：附加报文类型"分组过大"

   由于IPv6只能在主机分片，如果链路层最大传输单元MTU很小，但是IPv6数据报很大，此时也不能分片，路由器只能丢弃并返回一个差错报告报文。这里的差错报文使用的是ICMPv6协议。

8. IPv6支持资源的预分配， 支持实时视像等要求，保证一定的带宽和时延的应用。

9. IPv6取消了协议字段，改成下一个首部字段。

10. IPv6取消了总长度字段，改用有效载荷长度字段。

11. IPv6取消了服务类型字段。

    即IPv4中的区分服务字段。

IPv6地址表示形式：

一般用冒号十六进制记法表示：$4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170$

每四个十六进制为一组总共八组。

还有一种压缩形式：如果碰到前面有连续的$0$，保证每一组至少有一个$0$即可，前面的$0$都快可以删去。如：$4BF5:0000:0000:0000:BA 5F:039A:000A:2176$压缩后格式为：$4BF5:0:0:0:BA5F:39A:A:2176$。

同时也可以采用零压缩方式：一连串连续的$0$可以被一对冒号取代。如：$FF05:0:0:0:0:0:0:B3$压缩后是$FF05::B3$。且要注意双冒号这种表示法在一个地址中仅可出现一次。

### 5.2 IPv6基本地址类型

地址类型有三种：

- 单播

  一对一通信。可做源地址，也可以做目的地址。

  <img src="https://image.sybblogs.fun/img-common/202402251518653.png" alt="IPv6基本地址类型1" style="zoom:33%;" />

- 多播

  一对多通信。只能作为目的地址，不能作为源地址。也就是一台主机要和这个多播组内的所有主机进行通信，就将多播地址放入IPv6数据报的目的地址中就可以发给这个多播组中的所有主机。IPv6并没有使用IPv4的广播地址，因为多播地址可以表示广播地址。在IPv4中的广播是发给局域网中的所有结点，对应IPv6多播之所以可以取代广播是因为广播可以想象成一组多播组中的所有主机，然后给这些主机全部发送数据报。

  <img src="https://image.sybblogs.fun/img-common/202402251519310.png" alt="IPv6基本地址类型2" style="zoom: 33%;" />

- 任播

  一对多中的一个通信。实质还是一对一通信，但只可以作为目的地址。具体表现就是假如一台主机IP数据报中所封装的目的地址是一个任播地址，它就会给任播组内的一台主机发送数据报，通常是离的最近的一台。

  <img src="https://image.sybblogs.fun/img-common/202402251519660.png" alt="IPv6基本地址类型3" style="zoom:33%;" />

如果一台主机使用的是IPv6，另一台主机使用的是IPv4，这两台主机通信过度策略要使用：双栈协议和隧道技术。

- 双栈协议

  双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。

- 隧道技术

  通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。

  <img src="https://image.sybblogs.fun/img-common/202402251522335.png" alt="IPv6向IPv4过度策略" style="zoom:33%;" />

  

  如上图两台主机之间有四台路由器，中间两个路由器是IPv4协议两边式IPv6协议。假如此时发送的是IPv6的数据报，在IPv4路由器上需要进行封装，将IPv6数据报作为IPv4的数据部分。之后进入IPv6又会将IPv4的部分去掉，以IPv6数据报的形式继续往下发送交付给主机。

  其中封装部分就是隧道技术。即将IPv6数据报封装到IPv4中。

IPv6总结：

<img src="https://image.sybblogs.fun/img-common/202402251528842.png" alt="IPv6总结" style="zoom:25%;" />

## 6. IP组播

IP数据报三种传输方式：单播、广播、组播(多播)。

- 单播

  用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式。

  这里的IP地址其实就是之前的$A,B,C$类中经常使用的地址。

  <img src="https://image.sybblogs.fun/img-common/202402261241419.png" alt="单播例子" style="zoom: 25%;" />

  如上图有$90$个主机正在接收视频服务器传来的视频数据报。单播的方式就是每一个待接收的主机都要和发送站点建立一个单播连接。因此在原站点服务器位置要根据有多少个主机接收数据就复制多少份，所以如上图$90$个主机接收，服务器就要复制$90$份IP数据报。然后再分发到各个主机当中。可以看到这种方式在实际传输中所占的带宽和资源是较多的。因为要在在发送者和每一接收者之间需要单独的数据道。

- 广播

  广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。

  这里的发送端还是一个单播的IP地址，不过目的地址是一个全$1$的广播地址，所以对应的MAC地址也是全$F$的。

单播和广播传输效率相对较低，因此就产生了比较好的传输方式：组播(多播)。

- 组播

  当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。

  可以看到广播和主播类似，不过广播会不管用户需不需要直接发送。而组播是只给一个组播组内的主机，即给有相同需求的主机。并且也不会在刚开始的发送端就复制，只有在下一个路由器就到局域网时才会在下一个路由器这里对数据报进行复制。
  
  <img src="https://image.sybblogs.fun/img-common/202402261247439.png" alt="组播例子" style="zoom:25%;" />
  
  如上图还是那个视频数据报传输的例子，可以看到发送方视频服务器不用事先复制很多份数据报，只要到一个路由器，有多个路径接收数据就会复制多份，但是复制之后实际上在每个链路上都只有一个数据报。下面的局域网当中的主机只要是属于同一个组播组的就可以收到这份数据报，也就是到了最后一步一个数据报才会变为很多数据报分发给这些主机。
  
  组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有组播路由器的支持)。组播路由器是指可以运行组播协议的路由器，这一类路由器既可以运行组播协议，也可以运行单播协议。

上面例子中数据报到了$R2,R3,R4$路由器再分发给这个组播组当中的成员主机。这些主机是通过**IP组播地址**来确定为一个组播组的。

在因特网进行通信的时候每一个主机都需要有一个全球唯一的IP地址，如果某个主机现在想要接受特定的多播组的分组，那么如何使这个多播数据报传送到主机中，显然这个组播数据报的目的地址不能是主机自己的IP地址，因为如果写为主机IP地址，就只会发给这个主机，其他同属于一个组播组中的主机都是收不到这个数据报的。因此就需要一个新的地址，用这个产生的新地址来接收组播数据报，当然其他属于这一个组播组中的主机都可以有这样一个IP组播地址，然后接收到发送给这些主机所在的组播组的数据报。

所以IP组播地址让源设备能够将分组发送给一组设备。 属于多播组的设备将被分配一个组播组IP地址(一群共同需求主机的相同标识)。这个组播地址并不是任何一个主机都直接拥有的，而是在主机实现接收数据报时才会生成这个组播地址。

组播地址范围为$224.0.0.0\sim239.255.255.255$(D类地址)，一个D类地址表示一个组播组，只能用作分组的目标地址。源地址总是为单播地址。如：观看直播时，主播是源站主机，将这些视频数据报通过组播方式发给这些正在观看直播的主机。这些主机就同属于一个组播组。所以IP组播地址只能作为目的地址而不能作为源地址。

需要注意一下几点：

1. 组播数据报也是"尽最大努力交付"，不提供可靠交付，应用于UDP。

   UDP协议虽然是不可靠交付协议，但是其优点是速度快。

2. 对组播数据报不产生ICMP差错报文。

3. 并非所有D类地址都可以作为组播地址。

组播方式大致如下：

<img src="https://image.sybblogs.fun/img-common/202402261247439.png" alt="组播例子" style="zoom:25%;" />

这个图可以分为两个部分，下面的是硬件组播(只能在本局域网内进行的硬件组播)，上面路由器叫做因特网范围内组播(没有进入到局域网范围内进行组播)。硬件组播简单但是重要，因为现在大部分主机都是通过连接局域网然后再连入因特网，所以通过因特网范围内组播后还是要进入局域网内的硬件组播。

### 6.1 硬件组播

硬件组播其实就是在局域网范围内对于一个组播的数据报，应该怎么交付给这些主机，或者说应该将数据报给哪些主机。可以结合之前学习的单播情况，假如当前发过来一个单播数据报，进入局域网之后应该交付给哪些主机，就要看这个主机的MAC地址。同样，在硬件组播这里也是要根据MAC地址来找到可以接收主播数据报的主机。

所以同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值$01-00-5E$打头，余下的$6$个十六进制位是根据IP组播组地址的最后$23$位转换得到的。

可以结合广播情况，如果当前要发送一个广播数据报，在进入局域网后要看MAC地址，如果此时目标地址MAC是全$F$，就应该把这个数据报发送给这个局域网中的所有主机，不管有没有交换机。

所以在广播数据报中，全$F$这种广播MAC地址，其实就相当于一种标识。在组播中也有这种MAC地址标识，也就是只要$01-00-5E$打头， 就可以知道这一定是一个组播MAC地址，所以就做好准备发送给局域网中的一部分主机，至于要发给哪些主机，就要看剩下的$6$位。

TCP$/$IP协议使用的以太网多播地址范围是$01-00-5E-00-00-00\sim01-00-5E-7F-FF-FF$：

<img src="https://image.sybblogs.fun/img-common/202402261338940.png" alt="硬件组播" style="zoom: 33%;" />

结合上图，由于前面的$01-00-5E$都是由$16$进制表示的。所以一个十六进制位标识二进制$4$位，所以前面$24$位固定，另外剩下的$24$位开头一位是固定的$0$，故还剩下$23$位来自D类IP地址。这$23$位要和IP地址有一个映射关系，来决定是不是同属于一个多播组。因为一个D类IP地址就标识的是一个组播组，那因此就把这个IP地址映射成MAC地址，也就变成了一个MAC地址就可以映射一个组播组，但是要注意的是在D类IP地址中，$1110$后面的$5$位是不固定的，所以会导致两个前面$9$位不一样，后面$23$位一样的IP地址映射成MAC地址后出现一样情况，如果一样就认为是一个组播组，这样就导致多播转发错误。

所以为了解决这个问题在收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。这样就可以解决D类IP地址中间五位不一样剩下$23$位一样导致多播转发错误。

### 6.2 IGMP协议与组播路由选择协议

上面介绍过IP组播两种类型，一个是在本局域网内进行硬件多播，另一个是在因特网范围内进行多播。而IGMP协议与组播路由选择协议就是在因特网范围内要使用到的协议。

IGMP在一个路由器内部所规定的协议。这个协议目的是让连在一个局域网上的组播路由器知道所连的局域网上面是否还有主机参加$/$退出了某个组播组。即一个组播路由器通过IGMP协议就可以知道它所连的局域网中，是不是还有可以接收组播数据报的主机。

而组播路由选择协议是在路由器之间进行路径选择的问题。如果只有IGMP协议是完成不了组播数据传输这样一个过程的。连接在局域网上的组播路由器必须要和其他路由器进行信息交换才能把这个组播数据报用最小的代价来传送给组播组中的全部成员。此时就需要用到组播路由选择协议。

- IGMP协议

  又叫网际组管理协议IGMP。IGMP协议让路由器知道本局域网上是否有主机(的进程)参加或退出了某个组播组。

  所以对于一个主机如果有多个进程，而这多个进程可能都是组播组成员，那每个进程其实就可以有一个组播的IP地址。

  <img src="https://image.sybblogs.fun/img-common/202402261409327.png" alt="IGMP协议" style="zoom:25%;" />

  如上图，有四个标明IP地址的主机，这四个主机全都加入组播组，它们的组播IP地址就是$226.15.37.123$。接着每个路由器通过IGMP协议就可以判断如果接收到一个组播组，要不要给局域网当中的主机。同时看可以看到，有一个主机要发送给这个组播组一个数据报，那应该走R1，R2，R3。不应该发给R4。因为R4所连的局域网当中并没有组播组的成员，所以如何避免发送给R4就需要用到路由器的IGMP协议。IGMP协议只是可以让路由器知道是不是有主机或者进程参加了或者退出了组播组。

  IGMP在协议栈中的位置如下：

  <img src="https://image.sybblogs.fun/img-common/202402241959606.png" alt="TCPIP协议栈回顾" style="zoom:25%;" />

  可以看到ICMP和IGMP都使用IP数据报传递报文。

  IGMP工作两个阶段：

  1. 某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。

  2. 本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。探寻过程还是发送一个IGMP询问报文。结果有两种：

     只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的。如果经过几次探询后没有一个主机响应，组播路由器就认为本网络，上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。

     这里需要注意，路由器在给一个局域网内的主机发送询问报文时可以发送给组播组中的所有主机，但是返回响应的速度以及所到达路由器时间是不一样的。如果组播组中有一台主机先响应路由器，其他主机就会通过监听知道就不需要再发送响应了。这样就可以减少一些不必要的通信量。

     这里所说的成员关系指的是：组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。但是不会反映这个组成员有多少个。

- 组播路由选择协议

  一个组播组中的成员是动态变化的。组播路由选择就是要找出以源主机为根节点的组播转发树。也就是说要使用这个组播路由选择协议才能顺利地将数据报发送给自己地组播组成员。

  <img src="https://image.sybblogs.fun/img-common/202402261428193.png" alt="组播路由选择协议" style="zoom:25%;" />

  可以看到这是一个树形结构。这样可以避免在路由器之间兜圈子。特点是对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。

  组播路由选择协议常使用的三种算法：

  1. 基于链路状态的路由选择

  2. 基于距离-向量的路由选择

  3. 协议无关的组播(稀疏/密集)

     可以建立在任何路由器协议之上。有稀疏和密集两种。采用协议无关这个名词主要是说，虽然在建立转发树地时候是使用单播数据报和远程路由器来联系。但是这并不要求使用相同的单播路由选择协议。稀疏和密集主要指的是一个组播组中的主机距离的远近。如果较为分散就是稀疏型，较为密集就是密集的。

IP组播总结：

<img src="https://image.sybblogs.fun/img-common/202402261435392.png" alt="IP组播总结" style="zoom:25%;" />

## 7. 移动IP

移动IP技术是移动结点(计算机$/$服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。所以移动IP目的是达到设备移动但是IP不动。

五个相关概念：

1. 移动结点

   具有永久IP地址的移动设备。

2. 归属代理(本地代理)

   一个移动结点的永久"居所"称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。可以理解为一个管家，其管理的就是移动结点在没有发生移动的时候归属网络所提供一些功能叫做归属代理

3. 永久地址(归属地址$/$主地址)

   移动站点在归属网络中的原始地址。

4. 外部代理(外地代理)

   在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。

   具体来说就是移动结点移动到了外地，就会进入到一个外部网络，这个网络中的管家就是外部代理，也可以是这个网络中的一个路由器。主要发挥作用是帮助移动结点进行正常通信。

5. 转交地址(辅地址)

   可以是外部代理的地址或动态配置的一个地址。

下面以外部代理地址作为转交地址具体讲解移动IP技术：

<img src="https://image.sybblogs.fun/img-common/202402261446570.png" alt="移动IP" style="zoom:25%;" />

主机$A$就是即将发生移动的结点，加入主机$A$从当前归属网络进入到其他外部网络。

<img src="https://image.sybblogs.fun/img-common/202402261447897.png" alt="移动IP2" style="zoom:25%;" />

当$A$刚进入外部网络时候，就会获得外部代理的转交地址(外部代理广播报文)。这个转交地址获得形式有两种：

- 一种是被动获得

  外部代理在外部网络内广播一个SMP的报文。这个报文会包含这个转交地址(外部代理的地址)。之后主机$A$收到之后就知道所在的网络外部代理，及外部代理转交地址。

- 一种是主动获得

  主机$A$主动发送一个网络报文，来获得外部代理的转交地址。

在主机$A$获得转交地址之后，就应该在归属代理注册自己的信息，即移动节点通过外部代理发送注册报文给归属代理(包含永久地址和转交地址)。

之后归属代理接收请求，并将移动节点的永久地址和转交地址绑定(以后到达该归属代理的数据报且要发往移动节点的数据报将被封装并以隧道方式发给转交地址)，并返回注册响应报文。最后外部代理接收注册响应，并转发给移动节点。

假如数据报要到达归属代理并且要发给主机$A$的数据报都会被封装并且以隧道的形式发送给转交地址(外部代理)，这样外部代理才会根据永久地址发送给具体移动节点，即主机$A$。

如果主机$A$移动到了下一个网络：

1. 在新外部代理登记注册一个转交地址。
2. 新外部代理给本地代理发送新的转交地址(覆盖旧的)
3. 通信

当主机$A$回到了归属网络：

1. A向本地代理注销转交地址。
2. 按原始方式通信。

## 8. 网络层设备

路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。

<img src="https://image.sybblogs.fun/img-common/202402261520201.png" alt="路由器" style="zoom:25%;" />

上图是路由器结构图，可以分为两个部分：路由选择部分和分组转发部分。

- 路由选择

  路由选择部分核心部件和路由选择处理机。根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。

  因此路由选择部分就是为构建一个完整的路由表而服务的。

- 分组转发

  分组转发又包含多个输入端口、交换结构、多个输出端口。核心部件是交换结构。

  交换结构：根据转发表(路由表得来)对分组进行转发。可以将分组从一个固定端口输出到另一个最佳端口。

这里转发要和路由选择区分开，转发是把一个分组从一个输入端口转发到另一个输出端口。而路由选择就比较宏观，指的是在路由之间选择一个合适的路径把信息从源站发送到目的主机。转发是在内部的，路由选择是外部的。

并不是任何一个分组只要进了这个路由器，就会通过交换结构输出去，要分情况：若收到RIP$/$OSPF分组等，则把分组送往路由选择处理机。若收到数据分组，则查找转发表并输出。

输入端口详细信息：

<img src="https://image.sybblogs.fun/img-common/202402261529957.png" alt="输入端口和输出端口" style="zoom:25%;" />

首先会从链路上接收分组，交给物理层处理，这个物理层只是单纯进行比特接收。之后到了链路层就会按照链路层协议来接收传送分组的帧，之后会把帧头和帧尾去掉，然后交付给网络层。网络层处理是先要对这个分组进行判断，如果是路由器之间交换路由信息的分组，就会把这个分组交给路由选择处理机来进行处理和计算。如果是数据分组就会放入交换结构当中再选一个合适的端口进行输出。

假如当前有一堆数据分组到了网络层处理时候就需要排队，排队原因是假如第一个分组正在查询转发表，并且选一个合适的端口转发，这会产生一定的延迟，那么如果第一个分组还没有查完，第二个分组就已经到达之后几个分组也会依次到达，此时就会容易产生时延。所以也可以看出输入端口中的查找和转发功能在路由器的交换功能中是最重要的。

输出端口详细信息：

<img src="https://image.sybblogs.fun/img-common/202402261540258.png" alt="输出端口详细信息" style="zoom:25%;" />

输出端口先回从交换结构接收到一个分组，然后再把这些分组放到网络层处理分组中排队，可以看到网络层处理分组是一个队列。分组过多超过发送速率情况下，分组就需要在网络层缓存中暂存。这个网络层处理会产生时延。所以若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。因此**路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因**。

三层设备区别：

三层是物理层、链路层、网络层。这三层三个代表设备是路由器、网桥、集线器。

- 路由器：可以互联两个不同网络层协议的网段。
- 网桥：可以互联两个物理层和链路层不同的网段。
- 集线器：不能互联两个物理层不同的网段。

<img src="https://image.sybblogs.fun/img-common/202402261548993.png" alt="三层设备区别" style="zoom: 33%;" />

路由表与路由转发：

路申表根据路由选择算法得出的，主要用途是路由选择，总用软件来实现。

路由表结构是：目的网络IP地址$+$子网掩码$+$下一跳IP地址$+$接口。

<img src="https://image.sybblogs.fun/img-common/202402261550527.png" alt="路由表" style="zoom:33%;" />

上面的接口可选。下面的默认路由是只要当前发送的分组在路由表中找不到所对应的表项，就应该发送给默认路由。

转发表由路由表得来，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必需的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射。

所以路由表和转发表区别是：路由表是由路由选择算法得出的。转发表是由路由表得出的，而且还要结合主机具体信息来确定输出的端口。并且路由表主要是选择下一跳应该走哪个路由器(下一跳IP地址)。

# 五. 传输层

主要研究进程之间的通信问题。

知识总览：

<img src="https://image.sybblogs.fun/img-common/202402261618501.png" alt="传输层只是总览" style="zoom:25%;" />

传输层只有主机才有的层次，也就是在端系统两个主机才会有一层传输层。传输层为应用层提供服务，同时也可以使用网络层的服务。

传输层功能：

1. 传输层提供进程和进程之间的逻辑通信。

   注意网络层提供的是主机之间的逻辑通信。

2. 复用和分用

   复用指的是发送方不同的应用进程都可以使用同一个传输层的协议来传送协议。而分用指的是接收方在传输层在去除报文首部之后能够将这些数据送交给正确的进程。

3. 传输层对收到的报文进行差错检测

   网络层的首部校验和只是校验首部，不会校验数据部分。这里传输层会对数据进行检错。

4. 传输层有两种协议：UDP和TCP

UDP和TCP

- UDP

  无连接的用户数据报协议。

  传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。

  特点：不可靠，无连接，时延小，适用于小文件。

- TCP

  面向连接的传输控制协议。

  传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。

  特点：可靠，面向连接，时延大，适用于大文件。

传输层的寻址与端口：传输层功能之一是分用和复用。

复用：应用层所有的应用进程都可以通过传输层再传输到网络层。

分用：传输层从网络层收到数据后交付指明的应用进程。

在传输层也会有网络层IP地址及链路层MAC地址一样都快有唯一标识一个主机。在传输层唯一可以标识一个进程的是端口。即端口是传输层的SAP(服务访问点)，标识主机中的应用进程。这个端口是一个逻辑端口$/$软件端口。端口用端口号标识，端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。端口号长度为$16$bit，能表示$65536$个不同的端口号。

端口号根据数字大小范围可以分为：服务端使用的端口号和客户端使用端口号。其中服务端口号可以具体分为：

1. 熟知端口号$0\sim1023$

   给TCP$/$IP最重要的一些应用程序，让所有用户都知道。

2. 登记端口号$1024\sim49151$

   为没有熟知端口号的应用程序使用的。

而客户端使用端口号(范围是：$49152\sim65535$)：仅在客户进程运行时才动态选择。客户端使用端口号只有在使用时才会进行分配，而且是操作系统随机分配的。只要进程一结束，端口号会被操作系统收回分配给新的进程。

<img src="https://image.sybblogs.fun/img-common/202402261717398.png" alt="传输层寻址与端口" style="zoom:33%;" />

一些熟知端口号需要牢记：

<img src="https://image.sybblogs.fun/img-common/202402261718258.png" alt="一些熟知端口号" style="zoom:33%;" />

在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。

套接字结构：套接字`Socket=(主机IP地址+端口号)`。

## 1. UDP协议

UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。

UDP的主要特点：

1. UDP是无连接的，减少开销和发送数据之前的时延。

2. UDP使用最大努力交付，即不保证可靠交付。

   网络层是不可靠交付，如果传输层使用UDP协议，也不会保证可靠交付，此时可靠交付就由应用层保证。

3. UDP是面向报文的，适合一次性传输少量数据的网络应用。

   面向报文指的是应用层给UDP多长的报文，UDP就照样发送。

   <img src="https://image.sybblogs.fun/img-common/202402261725242.png" alt="面向报文" style="zoom: 33%;" />

   即一次发一个完整报文。因此应用程序就需要选择大小合适的报文。提供报文太长在网络层就会分片，因此会影响网络层传输效率。如果报文太小，报文传送到网络层，IP数据报的数据部分就相比IP首部来说小很多，所以网络层效率也会降低。

4. UDP无拥塞控制，适合很多实时应用(如：视频通话)。

5. UDP首部开销小，是$8$B，但TCP是$20$B。

UDP首部由首部字段$+$数据字段构成。

<img src="https://image.sybblogs.fun/img-common/202402261745382.png" alt="UDP首部格式" style="zoom: 25%;" />

数据字段可有可无，如果没有，则UDP首部为$8$B。首部字段四个部分介绍如下：

- 源端口号

  是可有可无的。如果发送数据报需要收到对方的回复就需要源端口号。

- 目的端口号

  必须要有的。发送目的主机哪个进程。

- UDP长度

  指的是整个UDP用户数据报的长度。也就是首部$+$数据字段。

- UDP检验和

  检测整个UDP数据报是否有错，错就丢弃

分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP"端口不可达"差错报告报文。下面详细介绍UDP校验过程：

<img src="https://image.sybblogs.fun/img-common/202402261749251.png" alt="UDP校验" style="zoom: 33%;" />

可以看到，首部数据的首部部分中，有一个伪首部字段。伪首部和下面的IP数据报的首部类似。因为伪首部中包含源IP地址及目的IP地址，以及`17`这个字段。这个`17`代表的是IP数据报首部的协议字段，这个协议字段就是在说明数据部分使用的是什么字段，这里数据部分使用的是UDP协议，即传输层使用UDP协议。所以这里对应的协议字段值是$17$。

伪首部只有在计算检验和时才出现，不向下传送也不向上递交。即发送端和接收端在校验数据和首部有没有发生问题时才会出现伪首部。其他传输过程中这个伪首部自始至终不会出现。伪首部几个字段如下：

- `0`字段固定字段，固定为$0$

- `17`字段

  协议字段，`17`指的是封装UDP报文的IP数据报首部协议字段是`17`。

- UDP长度

  UDP首部$+$数据部分长度(不包括伪首部)

UDP伪首部校验过程：

<img src="https://image.sybblogs.fun/img-common/202402261800826.png" alt="UDP校验过程" style="zoom:33%;" />

上图是一个UDP用户数据报，数据部分需要是$4$B整数倍。在发送端过程：

1. 填上伪首部

2. 全$0$填充校验和字段

   将首部第四个字段填上全$0$

3. 全$0$填充数据部分(UDP数据报要是$4$B整数倍)

4. 伪首部$+$首部$+$数据部分采用二进制反码求和

   <img src="https://image.sybblogs.fun/img-common/202402261826496.png" alt="UDP校验过程求和" style="zoom: 33%;" />

5. 把和求反码填入检验和字段，即将上面UDP首部检验和全$0$字段替换为求和结果的反码。

6. 去掉伪首部，发送。

在接收端过程：

1. 填上伪首部

2. 伪首部$+$首部$+$数据部分采用二进制反码求和
3. 结果全为$1$则无差错，否则丢弃数据报$/$交给应用层附上出差错的警告。

## 2. TCP协议

TCP协议特点：

1. TCP是面向连接(虚连接)的传输层协议。

   面向连接是指，应用程序在使用TCP协议之前必须要先建立好一个连接。在传送数据完毕后再释放这个连接。

2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。

   所以TCP协议不能用于广播及多播形式。

3. TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。

   可靠有序，不丢不重

4. TCP可以提供全双工通信

   发送端和接收端可以同时发送数据也可以同时接收数据。由于这个特点，TCP协议连接的两端都会设置发送缓存和接收缓存。

   发送缓存中存放准备发送的数据和已发送但尚未收到确认的数据。接收缓存中存放按序到达但尚未被接受应用程序读取的数据和不按序到达的数据。

5. TCP面向字节流

   流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是虽然应用进程和TCP交互是一次发送一个数据块，这个数据块大小可以是不一样的。但是TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。

   <img src="https://image.sybblogs.fun/img-common/202402261901476.png" alt="TCP协议特点" style="zoom: 33%;" />

   如上图发送方文件会按照字节进行编号。在发送的时候会把字节放入TCP缓存中，在发送的时候会不定长取走一部分字节组成TCP报文段，在这个报文段上加上TCP头部形成一个完整报文段之后放到链路上进行传输。所以可以看到TCP是面向字节流的。

==TCP报文段首部格式==：

<img src="https://image.sybblogs.fun/img-common/202402261905779.png" alt="TCP报文段首部格式" style="zoom: 33%;" />

可以看到主要分为两个部分：首部$+$TCP数据部分。首部除了有$20$B的固定首部外，还有选项(长度可变)，以及填充字段(首部是$4$B整数倍)。具体字段介绍如下：

- 源端口与目的端口

  占用$16$位。

- 序号

  在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。

  <img src="https://image.sybblogs.fun/img-common/202402261901476.png" alt="TCP协议特点" style="zoom: 33%;" />

  结合上图，报文段首部内的序号字段其实就是第一个字段编号值。如上图$3,2,1+$TCP头部的报文段，其首部内的序号字段是$1$。

- 确认号

  期望收到对方下一个报文段的第一个数据字节的序号。若确认号为$N$，则证明到序号$N-1$为止的所有数据都已正确收到。

  <img src="https://image.sybblogs.fun/img-common/202402261915427.png" alt="TCP报文段首部格式2" style="zoom: 33%;" />

  假如当前接收端已经接收发送端送来的前三个数据。之后接收端会向发送端发送一个确认报文段，这个确认报文段中的首部就会有确认号字段。这个确认号字段应该是期待对方下一个要发送报文段的第一个字节。如上图$1,2,3$号字节已经接收，那确认报文段中确认字节就是$4$。

- 数据偏移(首部长度)字段

  TCP报文段的数据起始处距离TCP报文段的起始处有多远，以$4$B位单位，即$1$个数值是$4$B。也就是数据起始处离整个报文起始处有多远。其实就是TCP首部长度。

- 六个重要的控制位

  1. 紧急位URG

     `URG=1`时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。

  2. 确认位ACK

     `ACK=1`时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为$1$。

  3. 推送位PSH

     `PSH=1`时， 接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。

     与上面紧急位区别是紧急位在TCP缓存中新进来的报文段中，`URG=1`则这个报文段会直接到TCP缓存头部尽快被发送出去，这是在发送端的优先处理。

     而PSH主要是在接收方的紧急处理。假如TCP缓存中收到很多报文段，如果其中有一个报文段的`PSH=1`，那么这个报文段会首先交给应用层进程。

  4. 复位RST

     `RST=1`时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。同时RST置为$1$还可以用来拒绝一个非法报文段，或者说是拒绝打开一个连接。

  5. 同步位SYN

     `SYN=1`时，表明是一个连接请求$/$连接接受报文。

     主机$A$和主机$B$要建立TCP连接，主机$A$发送的TCP请求中`SYN=1`。之后主机$B$收到请求报文后也会回复一个确认报文，这个确认报文中的`SYN=1`。

  6. 终止位FIN

     `FIN=1`时，表明此报文段发送方数据已发完，要求释放连接。

- 窗口字段

  指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。

  假如$A$给$B$发数据，$B$发送给$A$的报文中的窗口字段就代表了$B$能容纳的数据量。$A$接收到这个数据报之后就可以根据窗口字段设置自己的发送发送缓存。

- 检验和

  检验首部$+$数据，检验时要加上$12$B伪首部，第四个字段(协议字段)为$6$，在UDP中协议字段是$17$。

- 紧急指针

  `URG=1`时才有意义，指出本报文段中紧急数据的字节数。

  紧急指针指的是紧急数据的末尾在报文段当中的位置。假如紧急指针指向的是$50$，那么TCP数据部分从第$1$个字节到第$50$字节都是紧急数据。

- 选项

  是一个长度可变的字段。可以代表：最大报文段长度MSS、窗口扩大、时间戳、选择确认等
